#+STARTUP: latexpreview
* Definitions
** Abstraction
Generalization of process.
It is great did to name an abstraction ([[Denotational semantics]]).
** Actual type
[[Data type]] recieved by ->[[Type inference][inferring]]->compiling->execution.
** Algebra
"al-jabr" - assemble parts.
A system of algebra based on given axioms.

---

1) Abstract algebra - the study of number systems and operations within them.
2) Algebra - vector space over a field with a multiplication.
** Alpha equivalence
Alpha equivalence - in [[Expression][expressions]] process is literally the same, but names of parameters accordingly different (then they are synonyms).
** Anamorphism
[[Morphism]] from a [[Coalgebra][coalgebra]] to the final coalgebra for that [[Endofunctor][endofunctor]].
Is a [[function]] that generates a sequence by repeated [[Application][application]] of the function to its previous result.
** Anonymous function
[[Lambda function]] without the name to [[Bind][bind]] to.
** Application
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen
** Applicative
See [[Applicative functor]] for [[Category theory]] description.
Sequencing functorial computations.

#+begin_src haskell
(<*>) :: f (a -> b) -> f a -> f b
#+end_src

Requires [[Functor]] to exist.
Requires [[Monoid][Monoidal]] structure. And has structure rules, that are separate from what happens inside it.
Structure goes through Monoidal process.

[[Data type]]s can have several applicative implementations.
*** Applicative laws
**** Identity law
#+begin_src haskell
pure id <*> v = v
#+end_src
**** Composition law
Function composition works regularly.
#+begin_src haskell
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
#+end_src
**** Homomorphism law
Applying the function doesn't change the structure around values.
#+begin_src haskell
pure f <*> pure x = pure (f x)
#+end_src
**** Interchange law
On condition that internal order of evaluation is preserved - order of operands is not relevant.
#+begin_src haskell
u <*> pure y = pure ($ y) <*> u
#+end_src

*** Special applicatives
**** Identity applicative
#+begin_src haskell
-- Applicative f =>
-- f ~ Identity
type Id = Identity
instance Applicative Id
  where
    pure :: a -> Id a
    (<*>) :: Id (a -> b) -> Id a -> Id b

mkId = Identity
xs = [1, 2, 3]

const <$> mkId xs <*> mkId xs'
-- [1,2,3]
#+end_src
**** Constant applicative
It holds only to one value. The function does not exist and `b` is phantom.
#+begin_src haskell
-- Applicative f =>
-- f ~ Constant e
type C = Constant
instance Applicative C
  where
    pure :: a -> C e a
    (<*>) :: C e (a -> b) -> C e a -> C e b

pure 1
-- 1
pure 1 :: Constant String Int
-- Constant {getConstant = ""}
#+end_src

**** Maybe applicative
"There also can be no function at all."

If function might not exist - embed `f` in Maybe structure, and use Maybe applicative.
#+begin_src haskell
-- f ~ Maybe
type M = Maybe
pure :: a -> M a
(<*>) :: M (a -> b) -> M a -> M b
#+end_src
**** Either applicative
`pure` is `Right`.
Defaults to `Left`.
And if there is two Left's - to Left of the first argument.
**** Validation applicative
The Validation data type isomorphic to Either, but has accumulative Applicative on the error side.
For this Applicative there is no corresponding Bind or Monad instance. Validation is an example of, "An applicative functor that is not a monad."
** Applicative functor
Applicative functor - [[Lax monoidal functor]] with [[Tensorial strength]].
See [[Applicative]].
** Arbitrary function
Depends on type and generates values of the type.
** Arbitrary type class
[[Type class]] of [[QuickCheck]].Arbitrary (that is reexported by QuickCheck) for creating a generator/distribution of values.
Useful function is arbitrary - that autoassumes/generates values.
** Argument
Is an input value to a [[Function][function]].
** Arity
Number of [[Parameter][parameters]] of the [[Function][function]].
  * nullary - f()
  * unary   - f(x)
  * binary  - f(x,y)
  * ternary - f(x,y,z)
  * n-ary   - f(x,y,z..)
** As-pattern
#+begin_src haskell
f list@(x, xs) = ...
#+end_src
** Assertion
Statement.
Утверждение.
** Associative law
$$ \forall (a,b,c) \in S : \; P(a,P(b,c)) \equiv P(P(a,b),c) $$,
Etymology:
Joined by a common purpose.
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".
** Base case
A part of a [[Recursion][recursive]] [[Function][function]] that trivially produces result.
** Basis
$$ \beta\alpha\sigma\iota\varsigma $$ - stepping

The initial point, unreducible axioms and terms that spawn a theory.
AKA see [[Category theory]], or Euclidian geometry basis.
** Beta normal form
No [[Beta reduction][beta reduction]] is possible.
** Beta reduction
Applying [[Function][function]] to an [[Argument][argument]].
** Binary
Two of something.
** Binary operation
$$ \forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S $$
** Binary tree
#+begin_src haskell
data BinaryTree a =
    [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)
#+end_src
** Bind
Eq between two objects.
Parameter of the function = argument that applied to the function
Variables = values.
** Bottom value
#+begin_src haskell
-- _ fits *.
#+end_src

Is a non-value used to denote the program cannot return a values.
** Calculus of constructions
Extends the [[Curry–Howard correspondence]] to the proofs in the full intuitionistic predicate calculus (includes proofs of quantified statements).
Type theory, typed programming language, and constructivism (phylosophy) foundation for mathematics.
Directly relates to Coq programming language.
** Cardinality
Number of elements.

Number of possible implementations for a given type signature.

On sum - add cardinalities.
On product - multiply cardinalities.
** Cartesian product
${\forall a \in A, \forall b \in B : A \times B = \overset{\rightharpoonup}{(a,b)}}$.
Any function is a subset of Cartesian product.
** Category
Category (/C/) consists of the [[Basis]]:
  1. Objects - ob(/C/). A node. Object of some type. Often sets, than it is [[SET category]].
  2. [[Morphism]]s - C(a,b), [[Hom-set][hom(a,b)]]. Mappings, total functions.
  3. Binary operation "Composition of morphisms": $$ \forall a, b, c : \; C(a, b) \circ C(b, c) \equiv C(a, c) $$
  4. Axiom of [[Associative law][Associativity]]: $$ f_{a \to b}, g_{b \to c}, h_{c \to d} : \; h \circ (g \circ f) \equiv (h \circ g) \circ f $$.
  5. Axiom of two sided [[Identity]] of morphisms: $\forall x \, \exists  id_{x : x \to x},  \forall f_{a \to x},  \forall g_{x \to b} : \; id_x \circ f_{a \to x} \equiv f_{a \to x}, \; g_{x \to b} \circ id_x \equiv g_{x \to b}$ (both left and right identity)

From these axioms, one can prove that there is exactly one identity morphism for every object.
*** Object
See [[Category]]
** Closed-form expression
Closed-form expression - a mathematical expression that can be evaluated in a finite number of operations. It may contain constants, variables, certain "well-known" operations (e.g., + − × ÷), and functions (e.g., nth root, exponent, logarithm, trigonometric functions, and inverse hyperbolic functions), but usually no limit.
** Closed set
Closed set - a set whose complement is an open set.
Closed set is a form of [[Closed-form expression]]. Set can be closed in under a set of operations.
** Closure
Set has closure under an operation if performance of that operation on members of the set always produces a member of the same set; in this case we also say that the set is closed under the operation.
** Coalgebra
Structures that are dual (in the category-theoretic sense of reversing arrows) to unital associative [[Algebra][algebras]].
Every coalgebra, by vector space duality, reversing arrows - gives rise to an algebra. In finite dimensions, this duality goes in both directions. In infinite - it should be determined.
** CoArbitrary
Pseudogenerates a function basing on resulting type.
#+begin_src haskell
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
#+end_src
** CoC
See [[Calculus of constructions]].
** Codomain
Codomain - target set of a function in $X \to Y$.
** Combinator
Lambda term without free variables.

Higher-order [[Function][function]] that uses only function application and earlier defined combinators to define a result from its arguments.

Narrow meaning: A function or definition with no free variables.

Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Combinator
A function or definition with no free variables.
** Commutative law
$$ \forall (a,b) \in S : \; P(a,b) \equiv P(b,a) $$
** Composition
Axiom of [[Category]].
** Compose
See: [[Function composition]]
** Concatenate
Link together sequences.
** Concrete type
** Conjunction
AND
#+begin_src haskell
 * *
#+end_src
** Cons
Short for [[Construct]].
** Cons cell
Cell that values may inhabit.
** Constant
Nullary constructor
** Constrain
See: [[Ad hoc polymorphism]]
** Construct
#+begin_src haskell
(:) :: a -> [a] -> [a]
#+end_src
** Constructor
1. [[Type constructor]]
2. [[Data onstructor]]

Also see: [[Constant]]
** Curry–Howard correspondence
Computer programs are mathematical proofs.
** Curry–Howard isomorphism
See [[Curry–Howard correspondence]].
** Currying
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Data constant
See: [[Constant]]
** Data constructor
One instance that [[Inhabit][inhabit]] [[Data type][data type]].

Constant value - nullary data constructor.
** Data declaration
[[Data type]] definition.
** data declaration
[[Data type]] declaration is the most general and versatile form to create a new data type.
Form:
#+begin_src haskell
data [context =>] type typeVars1..n
  = con1  c1t1..i
  | ...
  | conm  cmt1..q
  [deriving]
#+end_src haskell
** Data type
Data type, type.
*** Algebraic data type
Composite type formed by combining other types.
*** Higher-kinded data type
Any combination of * and ->

Type that take more types as arguments.
*** Product data type
[[Algebraic data type]] formed by logical [[Conjuction][conjunction]] (AND ' ').
*** Sum data type
[[Algebraic data type]] formed by logical [[Disjunction][disjunction]] (OR '|').
** Declaration
Top-level [[Bind][bindings]] which allow us to name [[Expression][expressions]].
** Dependent type
Type and variable have rules regarding values.

A value of a variable has a role on the resulting Type.
Or Type has rule for values.
** Derived instance
Type classes such as Eq, Enum, Ord, Show can have instances generated based definition of data type.
** Disjunction
OR
** Dispatch
Send, transmission, reference.
** Domain
Source set of a function in $$ X \to Y $$.
** Effect
Observable action.
** Endofunctor
Is a [[Functor][functor]] which [[Domain][domain]] and [[Codomain][codomain]] are the same [[Category][category]].
** Evaluation
For FP see [[Bind]].
** Expected type
[[Data type]] [[Type inference][inferred]] from the text of the code.
** Expression
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class
1. Can be used as [[Value][value]].
2. Passed as an [[Argument][argument]].
** Fold
Higher-order function ruturns accumulated result from recursive data structure applying a function.
** Free variables
Variables in the fuction that is not bound by the head.
They live empty and fuction as so is not fully applied.
** Function
A varying quantity depends on another quantity.

$$ x \in X, y \in Y : \; f^{X \to Y} = \overset{\rightharpoonup}{G}(x,y) $$

Directionality and property of invariability emerge from one another.
#+begin_src haskell
-- domain func codomain
   *      ->   *
#+end_src

Function is a mathematical [[Operation][operation]].

Function = Total function = Pure function. Function theoretically posible to momoized.
[[Partial function]].
Inverse function - often partially exists (partial function).
** Injection
[[Function]] one-to-one injects from domain to codomain.
Keeps distinct pairing of elements of domain and image.
Every element in image coresponds to one element in domain.

$$ \forall a,b \in X, \; f(a)=f(b) \Rightarrow a=b $$

Denotion:
#+begin_src text
↣
>->
f : X ↣ Y
#+end_src
$f : X \rightarrowtail Y$

Corresponds to [[Monomorphism]].
*** Injective
See [[Injection]].
*** Injective function
See [[Injection]].
** Surjection
[[Function]] uses codomain fully.

$$ \forall y \in Y, \exists x \in X $$

Denotation:
#+begin_src text
↠
->>
f : X ↠ Y
#+end_src
$$ f : X \twoheadrightarrow Y $$

Corresponds to [[Epimorphism]].
*** Surjective
See [[Surjection]].
*** Surjective function
See [[Surjection]].
** Bijection
[[Function]] complete one-to-one pairing of elements of domain and codomain (image).
It means function both [[Surjection][surjective]] (so image == codomain) and [[Injection][injective]] (every domain element has unique correspondence to the image element).

For bijection inverse always exists.

Bijective operation holds the equivalence of domain and codomain.

Denotation:
#+begin_src text
⤖
>->>
f : X ⤖ Y
#+end_src
LaTeX needed to combine symbols:
$$ \newcommand*{\twoheadrightarrowtail}{\mathrel{\rightarrowtail\kern-1.9ex\twoheadrightarrow}} f : X \twoheadrightarrowtail Y $$
*** Bijective
See [[Bijection]].
*** Bijective function
See [[Bijection]].
** Permutation
[[Bijective]] [[function]] from [[Domain][domain]] to itself.
** Function application
Function application is applying the function to an argument from its domain to obtain the resulting value from its range.
** Function body
[[Expression]] that haracterizes the process.
** Function composition
#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
#+end_src

In Haskell inline composition requires:
#+begin_src haskell
h.g.f $ i
#+end_src
** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
** Function range
The range of a function refers to either the codomain or the image of the function, depending upon usage. Modern usage almost always uses range to mean image.
So, see [[Function image]].
** Functor
Functor is a map between categories.

#+begin_src haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src
Functor is a type class for function application "over/through" ignored/untouched structure f.
Functor abides [[Functor laws]].
** Functor laws
Type instance of functor should abide this laws:
1. Identity law
#+begin_src haskell
fmap id == id
#+end_src
2. Composition law
#+begin_src haskell
fmap (f.g) == fmap f . fmap g
#+end_src
In words, it is if several functions are composed and then fmap is applied on them - it should be the same as if functions was fmapped and then composed.
** Fundamental theorem of algebra
Any non-constant single-variable polynomial with complex coefficients has at least one complex root.
Also derives that the field of complex numbers is algebraically closed.
** Gen type
Generator. List it returns gets infinitely cycled.
** Girard–Reynolds polymorphic lambda calculus
See [[System F]].
** Higher-order function
Function arity > 1.

----

A) Has function as an argument.
B) Evaluates to function.
** Hindley–Milner type system
Classical type system for the [[Lambda calculus]] with [[Parametric polymorphism]] and [[Type inference]].
Where types marked as polymorphic variables, and overall type inference is possible all over the code.
Also known as Damas–Milner or Damas–Hindley–Milner system.
** HOF
See: [[Higher-order function]]
** Idempotence
After the initial application operation can be applied multiple times without changing the result.
Example: Start and Stop buttons on machines.
** Identity
*** Two-sided identity of a [[Predicate][predicate]]
$$ P() $$ is [[Commutative][commutative]].
$$ \exist e \in S, \forall a \in S : \; P(e,a)=P(a,e)=a $$
*** Left identity of a [[Predicate][predicate]]
$$ \exist e \in S, \forall a \in S : \; P(e,a)=a $$
*** Right identity of a [[Predicate][predicate]]
$$ \exist e \in S, \forall a \in S : \; P(a,e)=a $$

Identity only possible with morphism.
There is also a distinct [[Zero]] value.
** Identity function
Return itself.
(\x.x)
#+begin_src haskell
id :: a -> a
#+end_src
** Idiom
Idiom - something having a meaning that cannot be derived from the conjoined meanings.
Meaning can be special for language speakers or human with particular knowledge.

For different meaning - it is [[Applicative functor]].
** Idiomatic
See [[Idiom]].
** Impredicative
Self-referencing definition.

---

/Antonym - [[Predicative]]./
** Infix
Operaton in-between variables.
** Inhabit
What [[Values][values]] inhabit [[Data type][data type]]
** Initial object
Initial object - is an object I in category C: $$ \exists I \in C: \; \forall X \in C, \exists ! (I \to X) $$.
** Interface
Point of mutual meeting. Code behind interface determines how data is consumed.
** IO
Type for values whose evaluations has a posibility to cause side effects.
** IO ()
Pure programming language uses `IO ()` for functions that for the same circumstances in the code space - can return a different result.
** Kind
Kind -> Type -> Data
** Lambda calculus
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and application using variable [[Bind][binding]] and substitution.
** Lambda cube
λ-cube shows the dimentions of generalization from simply typed [[Lambda calculus]] to [[Calculus of constructions]].

Each dimension of the cube corresponds to a new way of making objects depend on other objects:
  * ([[First-class polymorphism]]) - terms allowed to depend on types, corresponding to polymorphism.
  * ([[Higher-order polymorphism]]) - types depending on terms, corresponding to dependent types.
  * ([[Type class]]) - types depending on types, corresponding to type operators.
** Lambda function
Function of [[Lambda calculus]].
** Language option
Language option - control what variations of the language are permitted.
It has a set of allowed values: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html, which can be supplied to Language [[Pragma]].
** Leaf
 _
** Left associative
Same level [[Exression][expression]] parts in reality follow grouping from left to right.
$$ (\lambda x . x)(\lambda y . y)z \equiv ((\lambda x . x)(\lambda y . y))z $$
** Level of code
There are mainly three levels of Haskell code.
- [[Type level]]: part that works with [[Data type][data types]]
- [[Term level]]: logical execution part of the code
- Compile level: level when code compiles/compiled
** Lexical scope
Scope search sourcecode blocks structure determined.
** Lift
Lift is to do a function application through the data structure.
** Linear type
Type system and algebra that also track the multiplicity of data.
There are 3 general linear type groups:
 * 0 - exists only at type level and is not allowed to be used at value level. Aka `s` ins ST-Trick.
 * 1 - data that is not duplicated
 * 1< - all other data, that can be duplicated multiple times.

Linear types are great to control/minimize resource usage.
** Local
[[Scope]] applies only in an area
** Magma
Set with a single binary operation.

The category of magmas, denoted $$ Mag $$, has as objects sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).
** Module
Importable organization unit.
** Modulus
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Monoid
[[Semigroup]] that has [[Identity]] value.

#+begin_src haskell
class Monoid m where
mempty :: m
mappend :: m -> m -> m
mconcat :: [m] -> m
mconcat = foldr mappend mempty
#+end_src
*** Abelian or commutative monoid
Very helpful at concurrent or distributed processing.
*** Monoid laws
#+begin_src haskell
-- Left identity
mempty <> x = x
-- Right identity
x <> mempty = x
-- Associativity
x <> mempty = x (y <> z) = (x <> y) <> z
mconcat = foldr (mempty <>)
#+end_src
** Morphism
μορφή /morphe/ form
Map between two objects in an abstract [[Category][category]].

Morphism is a generalization ($$ f(x*y) \equiv f(x) \diamond f(y) $$) of [[Homomorphism]] ($$ f(x*y) \equiv f(x) * f(y) $$).
Under morphism almost always mean homomorphism-like properties.

If some morphism corresponds to function requirements - than it is a [[Function]].
*** Homomorphism
ὁμός /homos/ same (chosen by initial Anglish mistranslation "similar")
μορφή /morphe/ form
similar form

Homomorphism is a map between two algebraic structures of the same type, that preserves the operation of the structures.
This means a map $$ f:A\to B $$ between two sets $$ A, B $$ equipped with the same structure such that, if $$ ∗ $$ is an operation of the structure (supposed here, for simplification, to be a binary operation), then $$ f(x*y)=f(x)*f(y) $$.

The concept of homomorphism has been generalized under the name of [[Morphism][morphism]] to many other structures that either do not have an underlying set, or are not algebraic.

Homomorphisms send identities to identities and inverses to inverses.
Homomorphism preserves operations, as such:
'*' homomorphism - map between '*' and preserves '*' operations
  (which can be):
  * semigroup
  * monoid
  * groups
  * ring
  * linear map
  * module
  * algebra
*** Identity morphism
Identity morphism - or simply identity: $$ x \in C : \; id_{x}=1_{x} : x \to x $$
Composed with other morphism gives same morphism.
*** Monomorphism
μονο /mono/ only
μορφή /morphe/ form

Initial set of /f/ is fully uniquely mapped onto the image of /f/.
Left is mono (uniquely) mapped to the right, so left [[Domain][domain]] can be equal or less to the right [[Codomain][codomain]].
It is [[Injection][injective]].
It always has a inverse morphism.

$$ f^{X \to Y}, \forall x \in X \, \exists y=f(x) \vDash f(x) = f_{mono}(x) $$ - from [[Homomorphism]] context
$$ f_{mono} \circ g1 \equiv f_{mono} \circ g2 \vDash \; g1 \equiv g2 $$ - from general [[Morphism]] context
Thus it is left canselable.
**** Monomorphic
See [[Monomorphism]].
*** Epimorphism
επι /epi/ on, over
μορφή /morphe/ form

Image fully uses codomain - epimorphism.
It is surjective.

$$ f^{X \to Y}, \forall y \in Y \, \exists f(x) \vDash f(x)=f_{epi}(x) $$ - from [[Homomorphism]] context
$$ g_1 \circ f_{epi} \equiv g_2 \circ f_{epi} \vDash \; g_1 = g_2 $$ - from general [[Morphism]] context
Thus it is right canselable.

Left is epi to the right. So left is bigger or equal then the right. And right is a projection of the left.
**** Epimorphic
See [[Epimorphism]].
*** Isomorphism
ἴσος /isos/ equal
μορφή /morphe/ form

Morphism that has inverse morphism.
[[Bijection][Bijective]] [[Homomorphis][homomorphism]] is also isomorphism.

$$ f^{-1, b \to a} \circ f^{a \to b} \equiv id^a, \; f^{a \to b} \circ f^{-1, b \to a} \equiv id^b $$

2 reasons for non-isomorphism:
- function at least ones collapses a values of domain into one value in codomain
- image (of a function in codomain) does not fill-in codomain. Then isomorphism can exists for image but not whole codomain.
**** Isomorphic
See [[Isomorphism]].
*** Endomorphism
ενδο /endo/ internal
μορφή /morphe/ form

Morphism whose [[Domain][domain]] equals the [[Codomain][codomain]].
Epimorphism is a [[Monoid]], because of [[Catogoty]] [[Composition]].
**** Automorphism
[[Endomorphism]] that is [[Isomorphism]].
*** Catamorphism
κατά /kata/ downward
μορφή /morphe/ form

Denotes the unique [[Homomorphism][homomorphism]] from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
** Kernel
Kernel of a [[Homomorphism]] is a number that measures the degree that homomorphism fails to meet [[Injective][injectivity]] (AKA be [[Monomorphic]]).
It is a number of elements that collide and fail injectivity, thou Kernel [x | x <- 0 || x >= 2].

Denotation:
$$ \operatorname{ker}T = \{ \mathbf{v} \in V:T(\mathbf{v}) = \mathbf{0}_{W} \} $$.
*** Kernel homomorphism
Morphism of elements from the [[Kernel]]. Map of elements that make main [[Morphism]] not [[Monomorphic]] ([[Injective]]).
** newtype declaration
Creates a new type from old type using a new constructor.
#+begin_src haskell
newtype FirstName = FirstName String
#+end_src haskell

Data will have exactly the same representation at runtime, as the type that is wrapped.

#+begin_src haskell
newtype Book = Book (Int, Int)
#+end_src haskell
#+begin_src text
      (,)
      / \
Integer Integer
#+end_src
** Node
#+begin_src text
 *
/ \
#+end_src
** NonEmpty list data type
Data.List.NonEmpty
Has a Semigroup instance but can't have a Monoid instance. It never can be an empty list.

#+begin_src haskell
data NonEmpty a = a :| [a]
  deriving (Eq, Ord, Show)
#+end_src haskell

:| - an infix data costructor that takes two (type) arguments. In other words :| returns a product type of left and right
** Normal form
In context: [[Beta normal form]]
** Nothing
Any Haskell expression can't return nothing.
** Open formula
[[Function]] with [[Arity][arity]].
** Operation
As also called [[Function][function]].
Used in mathematics. Word often used for [[Infix][infix]] operations.
** Operator
[[Infix]] [[Function][function]].
** Orphan type instance
[[Type instance]] that appeared from inconsistent code base. Duplicate of instance, or instance present on [[Type class][type class]] or on [[type]] level.

Solution for addressing orphan instances:
1. You defined the type but not the type class?
Put the instance in the same module as the type so that the type cannot be imported without its instances.
2. You defined the type class but not the type?
Put the instance in the same module as the type class definition so that the type class cannot be imported without its instances.
3. Neither the type nor the type class are yours?
Define your own newtype wrapping the original type and now you’ve got a type that “belongs” to you for which you can rightly define type class instances. There are means of making this less annoying which we’ll discuss later.
** Parameter
Or Formal Parameter - named varible of a [[Function][function]].
** Partial application
Part of [[Function][function]] [[parameter][parameters]] [[Application][applied]].
** Partial function
Does not cover all cases.
Unsafe and causes trouble.
** Pointfree
Point-free style, or Tacit programming is a paradigm in which function definition does not notate arguments. Instead definitions merely compose other functions.
** Polymorphism
At once several forms.

To [[Abstraction][abstract]] over [[Data types][data types]].


/Antonym - [[Monomorphism]]./

Types:
*** Levity polymorphism
Levity polymprphism is when polymorphism works with lifted and [[Unlifted type][unlifted types]].
*** Parametric polymorphism
[[Abstraction][Abstracting]] over [[Data type][data types]] by [[Parameter][parameter]].

/In most languages named as 'Generics' (generic programming)./

Types:
**** Let-bound polymorphism
It is property chosen for Haskell type system.
Haskell is based on Hindley-Milner type system, it is let-bound.
It means that to have strict [[Type inference][type inference]] - if `let` and `where` declarations a polymorphic - $\lambda$ declarations - should be not.
So:
#+begin_src haskell
foo :: (Int, Char)
foo = (\f -> (f 1, f 'a')) id
#+end_src
Is illigal in Haskell.

Lambda-bound function (i.e., one passed as argument to another function) cannot be instantiated in two different ways, if there is a let-bound polymorphism.
**** Constrained polymorphism
Constrained [[Parametric polymorphism]].
**** First-class polymorphism
More default term: [[Impredicative polymorphism]].
**** Impredicative polymorphism
The most powerful form of [[Parametric polymorphism]].
First see [[Impredicative]].

Impredicative polymorphism allows type τ entities with polymorphic types, that can contain type τ itself.
$$ T = \forall X. X \to X : \; T \in X \vDash T \in T $$
This approach has Russell's paradox (and its form - Girard's paradox).
*** Ad hoc polymorphism
Artificial [[Polymorphism][polymorphism]] dependent on incoming [[Data type][data type]].
Achieved by creating a [[Type class][type class]] [[Function][functions]].
It is interface dispatch mechanism by data types.

/Commonly known as overloading./
*** Subtype polymorphism
Allows to declare usage of a Type and all of its Subtypes.
T - Type
S - Subtype of Type
<: - subtype of
$$ S <: T = S \le T $$

Subtyping is:
If it can be done to T, and there is subtype S - then it also can be done to S.
$$ S <:T : \; f^{T \to X} \Rightarrow f^{S \to X} $$
*** Row polymorphism
# NOTE: 2019-03-11: Currently WIP in https://github.com/ghc-proposals/ghc-proposals/pull/180 
Is a lot like Subtype polymorphism, but alings itself on allowence (with | r) of subtypes and types with requested properties.
#+begin_src haskell
printX :: { x :: Int | r } -> String
printX rec = show rec.x

printY :: { y :: Int | r } -> String
printY rec = show rec.y

-- type is inferred as `{x :: Int, y :: Int | r } -> String`
printBoth rec = printX rec ++ printY rec
#+end_src
*** Kind polymorphism
Achieved using a phantom type argument in the data type declaration.
#+begin_src haskell
;;         * -> *
data Proxy a = ProxyValue
#+end_src
Then, by default the data type can be inhabited and fully work being partially defined.
But multiple instances of kind polymorphic type can be distinguished by their particular type.

Example is the [[Proxy type]]:
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- * :: Proxy Int
let proxy2 = (ProxyValue :: Proxy a)   -- * -> * :: Proxy a
#+end_src

*** Higher-rank polymorphism
Means that polymorphic types can apper within other types (types of funtion).
There is a cases where higher-rank polymorphism than the a Ad hoc - is needed. For example where ad hoc polymorphism is used in constraints of several different implementations of functions, and you want to build a function on top - and use the abstract interface over these functions.
#+begin_src haskell
-- ad-hoc polymorphism
f1 :: forall a. MyType Class a => a -> String
f1 = -- ...

-- higher-rank polymorphism
f2 :: Int -> (forall a. MyType Class a => a -> String) -> Int
f2 = -- ...
#+end_src
By moving `forall` inside the function - we can achive higher-rank polymorphism.

From: https://news.ycombinator.com/item?id=8130861
#+begin_src text
Higher-rank polymorphism is formalized using System F, and there are a few implementations of (incomplete, but decidable) type inference for it - see e.g. Daan Leijen's research page [1] about it, or my experimental implementation [2] of one of his papers. Higher-rank types also have some limited support in OCaml and Haskell.
#+end_src

Useful example aslo a [[ST-Trick monad]].
*** Linearity polymorphism
Leverages [[Linear type][linear types]].
For exampe - if fold over a dynamic array:
  1) In basic Haskell - array would be copied at every step.
  2) Use low-level unsafe functions.
  3) With Linear type function we guarantee that the array would be used only at one place at a time.

So, if we use a function (* -o * -o -o *) in foldr - the fold will use the initial value only once.
** Pragma
Pragma - instruction to the compiler placed in the source code that specifies how a compiler should process the code.
Pragma in Haskell have form:
#+begin_src haskell
{-# PRAGMA options #-}
#+end_src
** Pragma option
Values supplied to the [[Pragma]] directive.
** Predicate
[[Assertion]] includes variable.
Notation: $$ P(x) $$
[[Application]] of [[Argument][argument]] results in true or false predicate.
** Predicative
Non-self-referencing definition.

---

/Antonym - [[Impredicative]]./
** Principal type
The most generic [[Data type][data type]] that still typechecks.
** Principle of compositionality
The meaning of a complex [[Expression][expression]] is determined by the meanings of its constituent expressions and the rules used to combine them.
** Proxy type
Proxy type holds no data, but has a phantom parameter of arbitrary type (or even kind). Able to provide type information, even though has no value of that type (or it can be may too costly to create one).
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- a has kind `Type`
let proxy2 = (ProxyValue :: Proxy List) -- a has kind `Type -> Type`
#+end_src
** Purity
[[Referantial transparency][Referential transparent]] [[Function][function]]
** Quantifier
Specifies the quantity of specimens.

Two most common quantifiers $$ \forall $$ and $$ \exists $$.
** Recursion
Repeated function application allow computing results that may require indefinite amount of work.
** Redex
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction
See [[Beta Reduction]]
** Referential transparency
Function returns the same output given the same values to evaluate.

[[Expression]] is referentially transparent if can be replaced with its corresponding resulting value without change for program's behavior.
Such [[Functions][functions]] are called [[Pure][pure]].
** Relation
Is not directed and not limited.
** REPL
Interactive CLI. Read-eval-print loop.
** Scope
Area where [[Bind][bind]] is accessible.
** Sectioning
Writing [[Function][function]] in a parentheses. Allows to pass around [[Partial application][partially applied]] [[Function][functions]].
** Semantics
Philosophical study of meaning.
*** Operational semantics
Properties, such as correctness, safety or security, are verified by constructing proofs from logical [[Assertion][statements]] about execution and procedures.

Good to solve in-point localized tasks.
Process of abstraction.
*** Denotational semantics
Constructing mathematical objects (called denotations), that describe the meanings.

Good to achive more broad approach/meaning.
Also see [[Abstraction]].
*** Axiomatic semantics
Describing effect of operation on assertions about the overall state.

Good for examining interconnections.
Empirical process.
** Semigroup
$$ \forall (a,b,c) \in S : \; P(a,P(b,c)) \equiv P(P(a,b),c) $$

Semigroup - [[Magma]] with [[Associative law][associative law]].
Semigroup is closed (forms a closed set).

Defined in Haskell as:
#+begin_src haskell
class Semigroup a where
(<>) :: a -> a -> a
#+end_src

** Set
Well-defined collection of distinct objects.
** SET category
[[Category]] in which [[Object][objects]] are sets.
** Shadowing
Global scope variable overriden by variable in local scope.
** Shrinking
Process of reducing coplexity in the test case - re-run with smaller values and make sure that the test still fails.
** Singleton
Singleton - unit set - set with exactly one element.
Also 1-tuple.
** Smart constructor
Place extra constraints on the construction of values.
** Spine
#+begin_src text

  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

  :
 / \
_   :
   / \
  _   :
     / \
    _  []

#+end_src
** Statement
Declarative sentence that is true or false.
Gonzales: "What code does."
** Static typing
Static typechecking occurs at [[Level of code][compile time]]
** Structural type
Is a type in the real mathematical sence, in the Structural Type System.
The Structural Type System differentiate and compares the types basing on their properties. So all structural types have a global hierarchy of properties, types and subtypes.
Like in Haskell.
In most languages typing is not structural - but name-based.
** Superclass
Broader parent class.
** Syntatic sugar
Artificial way to make language easier to read and write.
** System F
Formalizes the notion of parametric polymorphism in programming languages.
Differs from the simply typed lambda calculus by the introduction of universal [[Quantifier][quantification]] over types.
** Tail call
Final result of the function
** Tail recursion
Tail calls are recursive invocantions of itself.
** Terminal object
Terminal object - is an object I in category C: $$ \exists I \in C : \; \forall X \in C, \, \exists ! (X \to I) $$.
** Term level
See: [[Level of code]]
** Tuple
Data type that stores multiple values withing a single value.
Tuples by [[Arity][arity]]:
  * empty, [[Unit][unit]]          - 0
  * pair, two-tuples     - 2
  * thriple, three-tuple - 3
** Type
Type - [[Set][set]] of values.
See [[Data type]]
** Type alias
Create new type constructor, and use all data structure of base type.
** Type class
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
** Type class inheritance
[[Type class]] has a [[Superclass][superclass]].
** Type constant
See: [[Constant]]
** Type constructor
Name of [[Data type][data type]]

Nullary type constructor is [[Type constant]]
** type declaration
Synonim for existing type. Uses the same data constructor.
#+begin_src haskell
type FirstName = String
#+end_src haskell
Used to distinct one entities from other entities, while they have the same type.
Also main type functions can operate on a new type.
** Type inference
Automatic [[Data type][data type]] detection of [[Expresion][expression]].
** Type instance
Unique [[Type class][type class]]->[[Data type][type]] pairing.
Defines type class->type methods.
** Type level
See: [[Level of code]]
** Type variable
Refer to an unspecified type in Haskell type signature.
** Uncurry
Replace number of [[Function][functions]] with [[Tuple][tuple]] of number of values
** Undefined
Value helps to do typechecking
** Unit
Value, [[Data type][type]]. Represents nothing. Empty [[Tuple][tuple]]
** Unlifted type
Type that directly exist on the hardware. The type abstraction can be completely removed.
With unlifted types Haskel type system directly manages data in the hardware.
** Unsafe
[[Function]] that does not cover some edge case.
** Variable
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funсtions]].
** Variadic
Variadic funtion has a indefinite [[Arity][arity]]. Assepts a variable number of [[Argument][arguments]].
** Zero
Zero is the value operation with which always gives Zero value.
$n, zero \in C : \forall n, zero*n=zero$
There is also distinct [[Identity]] value.
** Application memory
| Storage of                        | Block name    |
|-----------------------------------+---------------|
| All not currently processing data | Heap          |
| Function call, local variables    | Stack         |
| Static and global variables       | Static/Global |
| Instructions                      | Binary code   |

When even Main invoked - it work in Stack, and called Stack frame. Stack frame size for function calculated when it is compiled.
When stacked Stack frames exceed the Stack size - stack overflow happens.
*** Heap
See [[Application memory]].
*** Stack
See [[Application memory]].
** Monoidal functor
Functors between [[Monoid][monoidal]] [[Category][categories]] that preserves monoidal structure.
** Tensor
Object existing out of planes, thus it can translate objects from one plane into another.
They can be tried to be described with knowledge existing inside planes, but representation would always be partial, aka [[Ambigram]].
Tensor of rank 1 is a vector.

Tensors can be seen as [[Functor]]s.
** Ambigram
Object which from different points of view has different projections. Thou from projections only partial understanding of object is drawn.

While this word has two contradictory meaning, one was chosen.
** Hom-set
Collection of all [[Morphism][morphisms]] from X to Y.

Denotation:
$$ hom(X,Y) $$
*** Hom-functor
For C (locally small category), its hom-functor is the functor $$ hom:C^{op} \times C \to Set $$,
from the product category of the category C wit its opposite category to the category Set of sets.

Denotation:
variants:
$$ H_A &=& \mathrm{Hom}(-, A) $$
$$ h_A &=& {\cal C}(-, A) $$
$$ Hom(A,-) : C \to Set $$

Hom-bifunctor:
$$ Hom(-,-):C^{op} \times C \to Set $$
** Covariant
The property of [[Basis]], in which if new basis is a linear combination of the prior basis, and the change of basis proportional for a descriptions of [[Tensor]]s in this basisis.

Denotation:
Components for covariant basis denoted in the upper indices:
$$ V_{i} = x $$
** Covariant functor
More inline term is [[Covariant cofunctor]]
** Covariant cofunctor
See [[Covariant]].
** Contravariant
The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis inverse-proportional for the description of a [[Tensor]]s in this basisis.

Denotation:
Components for contravariant basis denoted in the upper indices:
$$ V^{i} = x $$

The inverse of a covariant transformation is a contravariant transformation. Whenever a vector should be invariant under a change of basis, that is to say it should represent the same geometrical or physical object having the same magnitude and direction as before, its components must transform according to the contravariant rule.

** Contravariant functor
More inline term is [[Contravariant cofunctor]]
** Contravariant cofunctor
See [[Contravariant]].
** Iff
If and only if, exectly when, just.
Denotation:
$$ \iff $$
** Natural transformation
Natural transformation provides a way of transforming one [[Functor]] into another while respecting the internal structure (i.e., the [[Composition]] of [[Morphism]]s) of the [[Category][categories]] involved.
Natural transformation is a "morphism of functors", especially in functor categories.

** Shift operator
Shift operator defined by Lagrange through Differential operator.
$$ \displaystyle T^{t}=e^{t{\frac {d}{dx}}} $$
*** Shift
See [[Shift operator]]
** Differential operator
Denotation.
$$ {d \over dx}, D, \,D_{x}}, {\displaystyle \partial _{x}}. $$
Last one is partial.

$$ e^{t{\frac {d}{dx}} $$ - [[Shift]].
*** Differential
See [[Differential operator]]
* Give definitions
** Kleisli category
** Free object
** Thin category
** Partial order
** Total order
** Preorder
** Identity type
** Constant type
** Arbitrary
** Gen
** Context
aka
#+begin_src haskell
Eq a => a -> Set a -> Set a
#+end_src
** ST-Trick monad
ST is like a lexical scope, where all the variables/state disappear when the function returns
https://wiki.haskell.ohttps://www.schoolofhaskell.com/school/to-infinity-and-beyond/older-but-still-interesting/deamortized-strg/Monad/ST
https://dev.to/jvanbruegge/what-the-heck-is-polymorphism-nmh
** Lax monoidal functor
** Tensorial strength
** Strong monad
** Testing
*** Write tasts algorithm
1. Pick the right language/stack to implement features.
2. How expensive breakage can be.
3. Pick the right tools to test this.
*** Property testing types
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
|                          | Exhaustive                           | Randomized                           | Unit test (Single sample) |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
| Whole set of values      | Exhaustive property test             | Randomised property test             |                           |
| Special subset of values | Exhaustive specialised property test | Randomised specialised property test |                           |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
* Citations
"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))
* Good code
** Type aliasing
Use data type aliases to deferentiate logic of values.
** Type wideness
Parametric polymorphism is broader then constrained polymorphism
Unconstrained means most flexible, but the most useless.
The more constrained system has more usefulness.
** Read Conventions of variables (page 176)
** Print
print :: Show a => a -> IO ()
print a = putStrLn (show a)
** Read code evaluation (488 on-ward)
** Fold
foldr spine recursion intermediated by the folding
foldl spine folding is unconditional, then solding starts.

So foldr can terminate at any point, while foldl unconditionally recurses across the spine, even if it infinite.
** Computation model
Model the domain and types before thinking about how to write computations.
** Make bottoms only local
** Newtype wrap is ideally transparent for compiler and does not change performance
** Instances of types/type classes must go with code you write
** Functions can be abstracted as arguments
** Infix operators can be bind to arguments
** Arbitrary
Product types can be tested as a product of random generators.
Sum types require to implement generators with separate constructors, and picking one of them, use `oneof` or `frequency` to pick generators.

** Principle of Separation of concerns
** Function composition
In Haskell inline composition requires:
#+begin_src haskell
  h.g.f $ i
#+end_src
Function application has a higher priority than composition. That is why parentheses over argument are needed.
This precedence allows idiomatically compose partially applied functions.

But it is a way better then:
#+begin_src haskell
  h (g (f i))
#+end_src
** Functor application
Function application on n levels beneath:
#+begin_src haskell
(fmap.fmap) function twoLevelStructure
#+end_src

How fmap.fmap typechecks:
#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
fmap :: Functor f => (m -> n) -> f m -> f n
fmap :: Functor g => (x -> y) -> g x -> g y

(.) :: (Functor f, Functor g)
  => ((g x -> g y) -> f.g (x) -> f.g (y))
  -> ((x -> y) -> g x -> g y)
  -> (x -> y) -> f.g (x) -> f.g. (y)
fmap.fmap :: (x -> y) -> f.g (x) -> f.g. (y)
#+end_src
** Parameter order
In functions parameter order is important.
It is best to use first the most reusable parameters.
And as last one the one that can be the most variable, that is important to chain.
** Applicative monoid
There can be more then one valid Monoid for a data type. &&
There can be more than one valid Applicative instance for a data type. ->
There can be differnt Applicatives with different Monoid implementations.
** Creative process
*** Pick phylosophy principles one to three the more - the harder the implementation
*** Draw the most blurred representation
*** Deduce abstractions and write remotely what they are
*** Model of computation
**** Model the domain
**** Model the types
**** Think how to write computations
*** Create
* Useful functions to remember
** Prelude
#+begin_src haskell
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
#+end_src
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo
*** List operations
#+begin_src haskell
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
#+end_src
** Data.List
#+begin_src haskell
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
#+end_src
** Data.Char
#+begin_src haskell
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
#+end_src
** QuickCheck
#+begin_src haskell
quickCheck :: Testable prop => prop -> IO ()

quickCheck . verbose - run verbose mode
#+end_src
* Investigate
** Control.Monad
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
** What been evaluated already
:sprint name
* Tools
** Search over the Haskell packages code: Codesearch from Aelve
https://codesearch.aelve.com/
* Libs
** Parsers - megaparsec
** CLIs - optparse-applicative
** HTML - Lucid
** Web applications - Servant
* Misc
