#+startup: latexpreview
#+startup: entitiespretty

* Introduction

Important notes on Haskel, category & related fields.

GitHub&GitLab parse ORG into HTML only partially. Good quality HTML export is in the `README.html`, it is hosted at https://blog.latukha.com/haskell-notes.html.

This is complex ORG notes file with LaTeX formulas.
To get:
  * LaTeX formulas
  * Interlinks
  * Navigation
use capable editor.

If something - =<<<This is a radio target>>>= - for =org-mode= linking.

Elisp snippet for you to prettify '<<<Radio targets>>>' to '_Radio targets_':
#+begin_src elisp
;;;; 2019-06-12: NOTE: Prettify '<<<Radio targets>>>' to be shown as 'Radio targets' when org-descriptive-links set
;;;; This is improvement of the code from: Tobias&glmorous: https://emacs.stackexchange.com/questions/19230/how-to-hide-targets
;;;; There exists library created from the sample: https://github.com/talwrii/org-hide-targets
(defcustom org-hidden-links-additional-re "\\(<<<\\)[[:print:]]+?\\(>>>\\)"
  "Regular expression that matches strings where the invisible-property of the sub-matches 1 and 2 is set to org-link."
  :type '(choice (const :tag "Off" nil) regexp)
  :group 'org-link)
(make-variable-buffer-local 'org-hidden-links-additional-re)

(defun org-activate-hidden-links-additional (limit)
  "Put invisible-property org-link on strings matching `org-hide-links-additional-re'."
  (if org-hidden-links-additional-re
      (re-search-forward org-hidden-links-additional-re limit t)
    (goto-char limit)
    nil))

(defun org-hidden-links-hook-function ()
  "Add rule for `org-activate-hidden-links-additional' to `org-font-lock-extra-keywords'.
    You can include this function in `org-font-lock-set-keywords-hook'."
  (add-to-list 'org-font-lock-extra-keywords
                '(org-activate-hidden-links-additional
                  (1 '(face org-target invisible org-link))
                  (2 '(face org-target invisible org-link)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-hidden-links-hook-function)
#+end_src

=SCHT:= and metadata in =:PROPERTIES:= - of my =org-drill= practices, please just run =org-drill-strip-all-data=.

* Contents :TOC:noexport:
- [[#introduction][Introduction]]
- [[#definitions][Definitions]]
  - [[#abstraction][<<<Abstraction>>>]]
    - [[#][/*/]]
  - [[#algebra][<<<Algebra>>>]]
    - [[#-1][/*/]]
    - [[#algebraic][<<<Algebraic>>>]]
    - [[#algebraic-structure][<<<Algebraic structure>>>]]
      - [[#-2][/*/]]
  - [[#alpha-equivalence][<<<Alpha equivalence>>>]]
  - [[#ambigram][<<<Ambigram>>>]]
  - [[#ancient-greek-and-latin-prefixes][Ancient Greek and Latin prefixes]]
    - [[#-3][/*/]]
  - [[#application][<<<Application>>>]]
  - [[#application-memory][<<<Application memory>>>]]
  - [[#argument][<<<Argument>>>]]
    - [[#argument-of-a-function][<<<Argument of a function>>>]]
      - [[#-4][/*/]]
  - [[#as-pattern][<<<As-pattern>>>]]
  - [[#binary][<<<Binary>>>]]
  - [[#binary-tree][<<<Binary tree>>>]]
  - [[#bind][<<<Bind>>>]]
    - [[#-5][/*/]]
  - [[#bottom-value][<<<Bottom value>>>]]
    - [[#-6][/*/]]
  - [[#bound][<<<Bound>>>]]
    - [[#-7][/*/]]
  - [[#cartesian-product][<<<Cartesian product>>>]]
    - [[#-8][/*/]]
  - [[#case][<<<Case>>>]]
  - [[#category-theory][<<<Category theory>>>]]
    - [[#-9][/*/]]
    - [[#abelian-category][<<<Abelian category>>>]]
    - [[#composition][<<<Composition>>>]]
      - [[#-10][/*/]]
    - [[#endofunctor-category][<<<Endofunctor category>>>]]
    - [[#functor][<<<Functor>>>]]
      - [[#-11][/*/]]
      - [[#power-set-functor][<<<Power set functor>>>]]
        - [[#power-set-functor-laws][<<<Power set functor laws>>>]]
          - [[#-12][/*/]]
          - [[#power-set-functor-identity-law][<<<Power set functor identity law>>>]]
          - [[#power-set-functor-composition-law][<<<Power set functor composition law>>>]]
        - [[#lift][<<<Lift>>>]]
          - [[#-13][/*/]]
        - [[#power-set-functor-is-a-free-monad][<<<Power set functor is a free monad>>>]]
      - [[#forgetful-functor][<<<Forgetful functor>>>]]
        - [[#-14][/*/]]
      - [[#identity-functor][<<<Identity functor>>>]]
      - [[#endofunctor][<<<Endofunctor>>>]]
        - [[#-15][/*/]]
      - [[#applicative-functor][<<<Applicative functor>>>]]
        - [[#-16][/*/]]
        - [[#applicative-laws][<<<Applicative laws>>>]]
          - [[#applicative-identity-law][<<<Applicative identity law>>>]]
          - [[#applicative-composition-law][<<<Applicative composition law>>>]]
          - [[#applicative-homomorphism-law][<<<Applicative homomorphism law>>>]]
          - [[#applicative-interchange-law][<<<Applicative interchange law>>>]]
        - [[#applicative-function][<<<Applicative function>>>]]
          - [[#lifta][<<<liftA*>>>]]
            - [[#lifta-1][<<<liftA>>>]]
            - [[#lifta2][<<<liftA2>>>]]
            - [[#lifta2-][<<<liftA2 (<*>)>>>]]
            - [[#lifta2-lifta2-][<<<liftA2 (liftA2 (<*>))>>>]]
            - [[#lifta3][<<<liftA3>>>]]
          - [[#conditional-applicative-computations][Conditional applicative computations]]
        - [[#special-applicatives][<<<Special applicatives>>>]]
          - [[#identity-applicative][<<<Identity applicative>>>]]
          - [[#constant-applicative][<<<Constant applicative>>>]]
          - [[#maybe-applicative][<<<Maybe applicative>>>]]
          - [[#either-applicative][<<<Either applicative>>>]]
          - [[#validation-applicative][<<<Validation applicative>>>]]
        - [[#monad][<<<Monad>>>]]
          - [[#-17][/*/]]
          - [[#monad-laws][<<<Monad laws>>>]]
            - [[#monad-left-identity-law][<<<Monad left identity law>>>]]
            - [[#monad-right-identity-law][<<<Monad right identity law>>>]]
            - [[#monad-associativity-law][<<<Monad associativity law>>>]]
          - [[#monad-type-class][<<<Monad type class>>>]]
            - [[#monadplus-type-class][<<<MonadPlus type class>>>]]
              - [[#-18][/*/]]
          - [[#functor---applicative---monad-progression][Functor -> Applicative -> Monad progression]]
          - [[#monad-function][<<<Monad function>>>]]
            - [[#return-function][<<<Return function>>>]]
            - [[#join-function][<<<Join function>>>]]
              - [[#-19][/*/]]
              - [[#join--fmap--][join . fmap == (=<<)]]
            - [[#bind-function][<<<Bind function>>>]]
              - [[#-20][/*/]]
                - [[#-21][(>>=)]]
                - [[#-22][>>=]]
                - [[#-23][(=<<)]]
                - [[#-24][=<<]]
            - [[#sequencing-operator---][<<<Sequencing operator>>> (>>) == (*>):]]
            - [[#monadic-versions-of-list-functions][Monadic versions of list functions]]
            - [[#liftm][<<<liftM*>>>]]
              - [[#liftm-1][<<<liftM>>>]]
              - [[#liftm2][<<<liftM2>>>]]
          - [[#comonad][<<<Comonad>>>]]
          - [[#kleisli-category][<<<Kleisli category>>>]]
          - [[#special-monad][<<<Special monad>>>]]
            - [[#identity-monad][<<<Identity monad>>>]]
            - [[#maybe-monad][<<<Maybe monad>>>]]
            - [[#either-monad][<<<Either monad>>>]]
            - [[#error-monad][<<<Error monad>>>]]
            - [[#list-monad][<<<List monad>>>]]
              - [[#-25][/*/]]
            - [[#reader-monad][<<<Reader monad>>>]]
            - [[#writer-monad][<<<Writer monad>>>]]
            - [[#state-monad][<<<State monad>>>]]
        - [[#alternative-type-class][<<<Alternative type class>>>]]
          - [[#-26][/*/]]
      - [[#monoidal-functor][<<<Monoidal functor>>>]]
      - [[#fusion][<<<Fusion>>>]]
    - [[#hask-category][<<<Hask category>>>]]
      - [[#-27][/*/]]
    - [[#magma][<<<Magma>>>]]
      - [[#mag-category][<<<Mag category>>>]]
        - [[#-28][/*/]]
      - [[#semigroup][<<<Semigroup>>>]]
        - [[#-29][/*/]]
        - [[#monoid][<<<Monoid>>>]]
          - [[#-30][/*/]]
          - [[#monoid-laws][<<<Monoid laws>>>]]
            - [[#monoid-left-identity-law][<<<Monoid left identity law>>>]]
            - [[#monoid-right-identity-law][<<<Monoid right identity law>>>]]
            - [[#monoid-associativity-law][<<<Monoid associativity law>>>]]
          - [[#commutative-monoid][<<<Commutative monoid>>>]]
            - [[#-31][/*/]]
          - [[#group][<<<Group>>>]]
            - [[#-32][/*/]]
            - [[#commutative-group][<<<Commutative group>>>]]
              - [[#-33][/*/]]
              - [[#ring][<<<Ring>>>]]
                - [[#-34][/*/]]
    - [[#morphism][<<<Morphism>>>]]
      - [[#-35][/*/]]
      - [[#homomorphism][<<<Homomorphism>>>]]
        - [[#-36][/*/]]
      - [[#identity-morphism][<<<Identity morphism>>>]]
        - [[#identity][<<<Identity>>>]]
          - [[#two-sided-identity-of-a-predicate][<<<Two-sided identity of a predicate>>>]]
          - [[#left-identity-of-a-predicate][<<<Left identity of a predicate>>>]]
          - [[#right-identity-of-a-predicate][<<<Right identity of a predicate>>>]]
        - [[#identity-function][<<<Identity function>>>]]
      - [[#monomorphism][<<<Monomorphism>>>]]
        - [[#-37][/*/]]
      - [[#epimorphism][<<<Epimorphism>>>]]
        - [[#-38][/*/]]
      - [[#isomorphism][<<<Isomorphism>>>]]
        - [[#-39][/*/]]
      - [[#endomorphism][<<<Endomorphism>>>]]
        - [[#automorphism][<<<Automorphism>>>]]
          - [[#-40][/*/]]
        - [[#-41][/*/]]
      - [[#catamorphism][<<<Catamorphism>>>]]
        - [[#-42][/*/]]
      - [[#kernel][<<<Kernel>>>]]
        - [[#kernel-homomorphism][<<<Kernel homomorphism>>>]]
      - [[#anamorphism][<<<Anamorphism>>>]]
    - [[#object][<<<Object>>>]]
      - [[#-43][/*/]]
      - [[#terminal-object][<<<Terminal object>>>]]
      - [[#initial-object][<<<Initial object>>>]]
    - [[#set-category][<<<Set category>>>]]
    - [[#natural-transformation][<<<Natural transformation>>>]]
      - [[#-44][/*/]]
      - [[#natural-transformation-component][<<<Natural transformation component>>>]]
        - [[#-45][/*/]]
      - [[#natural-transformation-in-haskell][<<<Natural transformation in Haskell>>>]]
    - [[#hom-set][<<<Hom set>>>]]
    - [[#category-dual][<<<Category dual>>>]]
          - [[#-46][/*/]]
  - [[#closure][<<<Closure>>>]]
    - [[#-47][/*/]]
  - [[#coalgebra][<<<Coalgebra>>>]]
  - [[#concatenate][<<<Concatenate>>>]]
  - [[#conjunction][<<<Conjunction>>>]]
  - [[#constructor][<<<Constructor>>>]]
  - [[#context][<<<Context>>>]]
    - [[#-48][/*/]]
  - [[#contravariant][<<<Contravariant>>>]]
    - [[#-49][/*/]]
  - [[#covariant][<<<Covariant>>>]]
    - [[#-50][/*/]]
  - [[#data-type][<<<Data type>>>]]
    - [[#-51][/*/]]
    - [[#actual-type][<<<Actual type>>>]]
    - [[#algebraic-data-type][<<<Algebraic data type>>>]]
      - [[#-52][/*/]]
    - [[#cardinality][<<<Cardinality>>>]]
    - [[#data-constant][<<<Data constant>>>]]
    - [[#data-constructor][<<<Data constructor>>>]]
    - [[#data-declaration][<<<data declaration>>>]]
    - [[#dependent-type][<<<Dependent type>>>]]
      - [[#-53][/*/]]
    - [[#gen-type][<<<Gen type>>>]]
    - [[#higher-kinded-data-type][<<<Higher-kinded data type>>>]]
      - [[#-54][/*/]]
    - [[#newtype-declaration][<<<newtype declaration>>>]]
    - [[#principal-type][<<<Principal type>>>]]
    - [[#product-data-type][<<<Product data type>>>]]
    - [[#proxy-type][<<<Proxy type>>>]]
    - [[#static-typing][<<<Static typing>>>]]
    - [[#structural-type][<<<Structural type>>>]]
      - [[#-55][/*/]]
    - [[#structural-type-system][<<<Structural type system>>>]]
      - [[#-56][/*/]]
    - [[#sum-data-type][<<<Sum data type>>>]]
    - [[#tuple][<<<Tuple>>>]]
    - [[#type-alias][<<<Type alias>>>]]
    - [[#type-class][<<<Type class>>>]]
      - [[#-57][/*/]]
      - [[#arbitrary-type-class][<<<Arbitrary type class>>>]]
        - [[#arbitrary-function][<<<Arbitrary function>>>]]
      - [[#coarbitrary-type-class][<<<CoArbitrary type class>>>]]
        - [[#-58][/*/]]
      - [[#type-class-inheritance][<<<Type class inheritance>>>]]
      - [[#derived-instance][<<<Derived instance>>>]]
        - [[#-59][/*/]]
    - [[#type-constant][<<<Type constant>>>]]
    - [[#type-constructor][<<<Type constructor>>>]]
    - [[#type-declaration][<<<type declaration>>>]]
    - [[#typed-hole][<<<Typed hole>>>]]
      - [[#-60][/*/]]
    - [[#type-inference][<<<Type inference>>>]]
      - [[#-61][/*/]]
    - [[#type-class-instance][<<<Type class instance>>>]]
    - [[#type-rank][<<<Type rank>>>]]
      - [[#-62][/*/]]
    - [[#type-variable][<<<Type variable>>>]]
    - [[#unlifted-type][<<<Unlifted type>>>]]
      - [[#-63][/*/]]
    - [[#data-structure][<<<Data structure>>>]]
      - [[#cons-cell][<<<Cons cell>>>]]
      - [[#construct][<<<Construct>>>]]
        - [[#-64][/*/]]
      - [[#leaf][<<<Leaf>>>]]
      - [[#node][<<<Node>>>]]
    - [[#linear-type][<<<Linear type>>>]]
      - [[#-65][/*/]]
    - [[#nonempty-list-data-type][<<<NonEmpty list data type>>>]]
    - [[#session-type][<<<Session type>>>]]
  - [[#declaration][<<<Declaration>>>]]
  - [[#differential-operator][<<<Differential operator>>>]]
    - [[#-66][/*/]]
  - [[#disjunction][<<<Disjunction>>>]]
  - [[#dispatch][<<<Dispatch>>>]]
  - [[#distributive-axiom][<<<Distributive axiom>>>]]
    - [[#-67][/*/]]
  - [[#dynamic-scope][<<<Dynamic scope>>>]]
  - [[#effect][<<<Effect>>>]]
  - [[#evaluation][<<<Evaluation>>>]]
  - [[#expected-type][<<<Expected type>>>]]
  - [[#expression][<<<Expression>>>]]
    - [[#-68][/*/]]
    - [[#closed-form-expression][<<<Closed-form expression>>>]]
    - [[#rhs][<<<RHS>>>]]
    - [[#lhs][<<<LHS>>>]]
    - [[#redex][<<<Redex>>>]]
  - [[#first-class][<<<First-class>>>]]
  - [[#first-order-logic][<<<First-order logic>>>]]
    - [[#-69][/*/]]
  - [[#free-variable][<<<Free variable>>>]]
  - [[#function][<<<Function>>>]]
    - [[#-70][/*/]]
    - [[#arity][<<<Arity>>>]]
    - [[#bijection][<<<Bijection>>>]]
      - [[#-71][/*/]]
    - [[#combinator][<<<Combinator>>>]]
    - [[#function-application][<<<Function application>>>]]
      - [[#-72][/*/]]
    - [[#function-body][<<<Function body>>>]]
    - [[#function-composition][<<<Function composition>>>]]
      - [[#-73][/*/]]
    - [[#function-head][<<<Function head>>>]]
    - [[#function-range][<<<Function range>>>]]
    - [[#higher-order-function][<<<Higher-order function>>>]]
      - [[#-74][/*/]]
      - [[#fold][<<<Fold>>>]]
    - [[#injection][<<<Injection>>>]]
      - [[#-75][/*/]]
    - [[#partial-function][<<<Partial function>>>]]
    - [[#purity][<<<Purity>>>]]
      - [[#-76][/*/]]
    - [[#sectioning][<<<Sectioning>>>]]
    - [[#surjection][<<<Surjection>>>]]
      - [[#-77][/*/]]
    - [[#unsafe][<<<Unsafe>>>]]
    - [[#variadic][<<<Variadic>>>]]
    - [[#domain][<<<Domain>>>]]
    - [[#codomain][<<<Codomain>>>]]
    - [[#open-formula][<<<Open formula>>>]]
    - [[#recursion][<<<Recursion>>>]]
      - [[#-78][/*/]]
      - [[#base-case][<<<Base case>>>]]
      - [[#tail-recursion][<<<Tail recursion>>>]]
  - [[#fundamental-theorem-of-algebra][<<<Fundamental theorem of algebra>>>]]
  - [[#guerrilla-patch][<<<Guerrilla patch>>>]]
  - [[#homotopy][<<<Homotopy>>>]]
    - [[#-79][/*/]]
  - [[#idiom][<<<Idiom>>>]]
    - [[#-80][/*/]]
  - [[#iff][<<<Iff>>>]]
  - [[#impredicative][<<<Impredicative>>>]]
  - [[#infix][<<<Infix>>>]]
  - [[#inhabit][<<<Inhabit>>>]]
  - [[#interface][<<<Interface>>>]]
  - [[#io][<<<IO>>>]]
  - [[#kind][<<<Kind>>>]]
  - [[#lambda-calculus][<<<Lambda calculus>>>]]
    - [[#-81][/*/]]
    - [[#lambda-abstraction][<<<Lambda abstraction>>>]]
    - [[#lambda-cube][<<<Lambda cube>>>]]
      - [[#-82][/*/]]
    - [[#lambda-function][<<<Lambda function>>>]]
      - [[#lambda-expression][<<<Lambda expression>>>]]
      - [[#anonymous-function][<<<Anonymous function>>>]]
    - [[#beta-reduction][<<<\beta-reduction>>>]]
      - [[#-83][/*/]]
      - [[#beta-normal-form][<<<\beta-normal form>>>]]
        - [[#-84][/*/]]
    - [[#calculus-of-constructions][<<<Calculus of constructions>>>]]
      - [[#-85][/*/]]
    - [[#curryhoward-correspondence][<<<Curry–Howard correspondence>>>]]
      - [[#-86][/*/]]
    - [[#currying][<<<Currying>>>]]
      - [[#-87][/*/]]
    - [[#hindleymilner-type-system][<<<Hindley–Milner type system>>>]]
    - [[#reduction][<<<Reduction>>>]]
      - [[#-88][/*/]]
    - [[#beta-eta-normal-form][<<<\beta-\eta normal form>>>]]
      - [[#-89][/*/]]
    - [[#eta-abstraction][<<<\eta-abstraction>>>]]
      - [[#-90][/*/]]
  - [[#lense][<<<Lense>>>]]
  - [[#level-of-code][<<<Level of code>>>]]
    - [[#-91][/*/]]
    - [[#term-level][<<<Term level>>>]]
    - [[#type-level][<<<Type level>>>]]
    - [[#compile-level][<<<Compile level>>>]]
      - [[#-92][/*/]]
    - [[#runtime-level][<<<Runtime level>>>]]
  - [[#lexical-scope][<<<Lexical scope>>>]]
    - [[#-93][/*/]]
  - [[#local-scope][<<<Local scope>>>]]
    - [[#-94][/*/]]
  - [[#module][<<<Module>>>]]
  - [[#modulus][<<<Modulus>>>]]
    - [[#-95][/*/]]
  - [[#monkey-patch][<<<Monkey patch>>>]]
  - [[#nothing][<<<Nothing>>>]]
  - [[#operation][<<<Operation>>>]]
    - [[#binary-operation][<<<Binary operation>>>]]
      - [[#-96][/*/]]
  - [[#operator][<<<Operator>>>]]
    - [[#shift-operator][<<<Shift operator>>>]]
      - [[#-97][/*/]]
  - [[#orphan-type-instance][<<<Orphan type instance>>>]]
  - [[#parameter][<<<Parameter>>>]]
    - [[#-98][/*/]]
  - [[#partial-application][<<<Partial application>>>]]
    - [[#-99][/*/]]
  - [[#pattern-guard][<<<Pattern guard>>>]]
    - [[#-100][/*/]]
  - [[#permutation][<<<Permutation>>>]]
  - [[#phrase][<<<Phrase>>>]]
  - [[#point-free][<<<Point-free>>>]]
    - [[#-101][/*/]]
    - [[#blackbird][<<<Blackbird>>>]]
      - [[#-102][/*/]]
    - [[#swing][<<<Swing>>>]]
    - [[#squish][<<<Squish>>>]]
  - [[#polymorphism][<<<Polymorphism>>>]]
    - [[#-103][/*/]]
    - [[#levity-polymorphism][<<<Levity polymorphism>>>]]
    - [[#parametric-polymorphism][<<<Parametric polymorphism>>>]]
      - [[#rank-1-polymorphism][<<<Rank-1 polymorphism>>>]]
        - [[#-104][/*/]]
      - [[#let-bound-polymorphism][<<<Let-bound polymorphism>>>]]
      - [[#constrained-polymorphism][<<<Constrained polymorphism>>>]]
        - [[#ad-hoc-polymorphism][<<<Ad hoc polymorphism>>>]]
            - [[#-105][/*/]]
      - [[#impredicative-polymorphism][<<<Impredicative polymorphism>>>]]
        - [[#-106][/*/]]
      - [[#higher-rank-polymorphism][<<<Higher-rank polymorphism>>>]]
        - [[#-107][/*/]]
    - [[#subtype-polymorphism][<<<Subtype polymorphism>>>]]
    - [[#row-polymorphism][<<<Row polymorphism>>>]]
    - [[#kind-polymorphism][<<<Kind polymorphism>>>]]
    - [[#linearity-polymorphism][<<<Linearity polymorphism>>>]]
  - [[#pragma][<<<Pragma>>>]]
    - [[#language-pragma][<<<LANGUAGE pragma>>>]]
      - [[#language-option][<<<LANGUAGE option>>>]]
        - [[#useful-by-default][Useful by default]]
        - [[#allowambiguoustypes][<<<AllowAmbiguousTypes>>>]]
        - [[#applicativedo][<<<ApplicativeDo>>>]]
        - [[#constrainedclassmethods][<<<ConstrainedClassMethods>>>]]
        - [[#cpp][<<<CPP>>>]]
        - [[#derivefunctor][<<<DeriveFunctor>>>]]
        - [[#explicitforall][<<<ExplicitForAll>>>]]
        - [[#flexiblecontexts][<<<FlexibleContexts>>>]]
        - [[#flexibleinstances][<<<FlexibleInstances>>>]]
        - [[#generalizednewtypederiving][<<<GeneralizedNewtypeDeriving>>>]]
        - [[#implicitparams][<<<ImplicitParams>>>]]
        - [[#lambdacase][<<<LambdaCase>>>]]
        - [[#multiparamtypeclasses][<<<MultiParamTypeClasses>>>]]
        - [[#multiwayif][<<<MultiWayIf>>>]]
        - [[#overloadedstrings][<<<OverloadedStrings>>>]]
        - [[#partialtypesignatures][<<<PartialTypeSignatures>>>]]
        - [[#rankntypes][<<<RankNTypes>>>]]
        - [[#scopedtypevariables][<<<ScopedTypeVariables>>>]]
        - [[#tuplesections][<<<TupleSections>>>]]
        - [[#typeapplications][<<<TypeApplications>>>]]
        - [[#typesynonyminstances][<<<TypeSynonymInstances>>>]]
        - [[#undecidableinstances][<<<UndecidableInstances>>>]]
        - [[#viewpatterns][<<<ViewPatterns>>>]]
        - [[#datatypecontexts][<<<DatatypeContexts>>>]]
      - [[#how-to-make-a-ghc-language-extension][How to make a GHC LANGUAGE extension]]
  - [[#predicative][<<<Predicative>>>]]
  - [[#principle-of-compositionality][<<<Principle of compositionality>>>]]
  - [[#psi-combinator][<<<\Psi-combinator>>>]]
    - [[#-108][/*/]]
  - [[#quantifier][<<<Quantifier>>>]]
    - [[#-109][/*/]]
    - [[#forall-quantifier][<<<Forall quantifier>>>]]
      - [[#-110][/*/]]
  - [[#referential-transparency][<<<Referential transparency>>>]]
    - [[#-111][/*/]]
  - [[#relation][<<<Relation>>>]]
    - [[#-112][/*/]]
  - [[#repl][<<<REPL>>>]]
  - [[#scope][<<<Scope>>>]]
  - [[#semantics][<<<Semantics>>>]]
    - [[#operational-semantics][<<<Operational semantics>>>]]
    - [[#denotational-semantics][<<<Denotational semantics>>>]]
    - [[#axiomatic-semantics][<<<Axiomatic semantics>>>]]
  - [[#set][<<<Set>>>]]
    - [[#-113][/*/]]
    - [[#closed-set][<<<Closed set>>>]]
    - [[#power-set][<<<Power set>>>]]
    - [[#hom-set-1][<<<Hom-set>>>]]
      - [[#hom-functor][<<<Hom-functor>>>]]
    - [[#singleton][<<<Singleton>>>]]
  - [[#shadowing][<<<Shadowing>>>]]
  - [[#shrinking][<<<Shrinking>>>]]
  - [[#smart-constructor][<<<Smart constructor>>>]]
  - [[#spine][<<<Spine>>>]]
  - [[#statement][<<<Statement>>>]]
    - [[#-114][/*/]]
    - [[#predicate][<<<Predicate>>>]]
  - [[#superclass][<<<Superclass>>>]]
  - [[#syntatic-sugar][<<<Syntatic sugar>>>]]
  - [[#system-f][<<<System F>>>]]
    - [[#-115][/*/]]
  - [[#tail-call][<<<Tail call>>>]]
  - [[#tensor][<<<Tensor>>>]]
    - [[#-116][/*/]]
  - [[#testing][<<<Testing>>>]]
    - [[#property-testing][<<<Property testing>>>]]
      - [[#function-property][<<<Function property>>>]]
      - [[#property-testing-types][<<<Property testing types>>>]]
      - [[#generator][<<<Generator>>>]]
        - [[#-117][/*/]]
        - [[#custom-generator][Custom generator]]
      - [[#reusing-test-code][<<<Reusing test code>>>]]
        - [[#test-commutative-property][<<<Test Commutative property>>>]]
        - [[#test-symmetry-property][<<<Test Symmetry property>>>]]
        - [[#test-equivalence-property][<<<Test Equivalence property>>>]]
        - [[#test-inverse-property][<<<Test Inverse property>>>]]
      - [[#quickcheck][<<<QuickCheck>>>]]
        - [[#manual-automation-with-quickcheck-properties][Manual automation with QuickCheck properties]]
    - [[#write-tests-algorithm][Write tests algorithm]]
  - [[#thunk][<<<Thunk>>>]]
  - [[#uncurry][<<<Uncurry>>>]]
  - [[#undefined][<<<Undefined>>>]]
  - [[#unit][<<<Unit>>>]]
  - [[#variable][<<<Variable>>>]]
    - [[#-118][/*/]]
  - [[#zero][<<<Zero>>>]]
  - [[#modular-arithmetic][<<<Modular arithmetic>>>]]
    - [[#-119][/*/]]
  - [[#property][<<<Property>>>]]
    - [[#-120][/*/]]
    - [[#associative-law][<<<Associative law>>>]]
      - [[#-121][/*/]]
    - [[#left-associative][<<<Left associative>>>]]
    - [[#basis][<<<Basis>>>]]
    - [[#commutativity][<<<Commutativity>>>]]
      - [[#-122][/*/]]
    - [[#idempotence][<<<Idempotence>>>]]
      - [[#-123][/*/]]
  - [[#backpack][<<<Backpack>>>]]
  - [[#nullary][<<<Nullary>>>]]
  - [[#arbitrary][<<<Arbitrary>>>]]
- [[#give-definitions][Give definitions]]
  - [[#commuting-diagram][<<<Commuting diagram>>>]]
  - [[#const-functor][<<<Const functor>>>]]
  - [[#free-object][<<<Free object>>>]]
  - [[#thin-category][<<<Thin category>>>]]
  - [[#identity-type][<<<Identity type>>>]]
  - [[#constant-type][<<<Constant type>>>]]
  - [[#gen][<<<Gen>>>]]
  - [[#st-trick-monad][<<<ST-Trick monad>>>]]
    - [[#-124][/*/]]
  - [[#lax-monoidal-functor][<<<Lax monoidal functor>>>]]
  - [[#tensorial-strength][<<<Tensorial strength>>>]]
  - [[#strong-monad][<<<Strong monad>>>]]
  - [[#either][<<<Either>>>]]
    - [[#-125][/*/]]
  - [[#weak-head-normal-form][<<<Weak head normal form>>>]]
    - [[#-126][/*/]]
  - [[#function-image][<<<Function image>>>]]
    - [[#-127][/*/]]
  - [[#maybe][<<<Maybe>>>]]
  - [[#inverse][<<<Inverse>>>]]
  - [[#inversion][<<<Inversion>>>]]
  - [[#inverse-function][<<<Inverse function>>>]]
  - [[#inverse-morphism][<<<Inverse morphism>>>]]
  - [[#invertible][<<<Invertible>>>]]
  - [[#invertibility][<<<Invertibility>>>]]
  - [[#partial-inverse][<<<Partial inverse>>>]]
  - [[#define-language-pragma-options][<<<Define LANGUAGE pragma options>>>]]
    - [[#existentialquantification][<<<ExistentialQuantification>>>]]
    - [[#gadts][<<<GADTs>>>]]
    - [[#generalizednewtypeclasses][<<<GeneralizedNewTypeClasses>>>]]
    - [[#funcitonaldependencies][<<<FuncitonalDependencies>>>]]
  - [[#ghc-debug-keys][<<<GHC debug keys>>>]]
    - [[#-ddump-ds][<<<-ddump-ds>>>]]
      - [[#-128][/*/]]
  - [[#ghc-optimize-keys][<<<GHC optimize keys>>>]]
    - [[#-foptimal-applicative-do][<<<-foptimal-applicative-do>>>]]
  - [[#ghc-check-keys][<<<GHC check keys>>>]]
    - [[#-wno-partial-type-signatures][<<<-Wno-partial-type-signatures>>>]]
  - [[#generalised-algebraic-data-types][<<<Generalised algebraic data types>>>]]
    - [[#-129][/*/]]
  - [[#order-theory][<<<Order theory>>>]]
    - [[#domain-theory][<<<Domain theory>>>]]
    - [[#lattice][<<<Lattice>>>]]
    - [[#order][<<<Order>>>]]
      - [[#preorder][<<<Preorder>>>]]
        - [[#total-preorder][<<<Total preorder>>>]]
      - [[#partial-order][<<<Partial order>>>]]
        - [[#-130][/*/]]
    - [[#partial-order-1][<<<Partial order>>>]]
    - [[#total-order][<<<Total order>>>]]
  - [[#universal-algebra][<<<Universal algebra>>>]]
  - [[#relation-1][<<<Relation>>>]]
    - [[#reflexivity][<<<Reflexivity>>>]]
      - [[#-131][/*/]]
    - [[#irreflexivity][<<<Irreflexivity>>>]]
      - [[#-132][/*/]]
    - [[#transitivity][<<<Transitivity>>>]]
      - [[#-133][/*/]]
    - [[#symmetry][<<<Symmetry>>>]]
      - [[#-134][/*/]]
    - [[#equivalence][<<<Equivalence>>>]]
      - [[#-135][/*/]]
    - [[#antisymmetry][<<<Antisymmetry>>>]]
      - [[#-136][/*/]]
    - [[#asymmetry][<<<Asymmetry>>>]]
      - [[#-137][/*/]]
  - [[#cryptomorphism][<<<Cryptomorphism>>>]]
    - [[#-138][/*/]]
  - [[#lexically-scoped-type-variables][<<<Lexically scoped type variables>>>]]
  - [[#abstract-data-type][<<<Abstract data type>>>]]
    - [[#-139][/*/]]
  - [[#adt][<<<ADT>>>]]
  - [[#concrete-type][<<<Concrete type>>>]]
  - [[#functional-dependencies][<<<Functional dependencies>>>]]
  - [[#monolocalbinds][<<<MonoLocalBinds>>>]]
  - [[#kindsignatures][<<<KindSignatures>>>]]
  - [[#explicitnamespaces][<<<ExplicitNamespaces>>>]]
  - [[#combinator-pattern][<<<Combinator pattern>>>]]
  - [[#symbolic-expression][<<<Symbolic expression>>>]]
    - [[#-140][/*/]]
  - [[#polynomial][<<<Polynomial>>>]]
    - [[#-141][/*/]]
  - [[#data-family][<<<Data family>>>]]
  - [[#type-synonym-family][<<<Type synonym family>>>]]
  - [[#indexed-type-family][<<<Indexed type family>>>]]
    - [[#-142][/*/]]
  - [[#typefamilies][<<<TypeFamilies>>>]]
  - [[#error][<<<Error>>>]]
  - [[#exception][<<<Exception>>>]]
  - [[#constraintkinds][<<<ConstraintKinds>>>]]
- [[#citations][Citations]]
- [[#good-code][Good code]]
  - [[#good-type-aliasing][<<<Good: Type aliasing>>>]]
  - [[#good-type-wideness][<<<Good: Type wideness>>>]]
  - [[#good-read-conventions-of-variables-page-176][<<<Good: Read Conventions of variables (page 176)>>>]]
  - [[#good-print][<<<Good: Print>>>]]
  - [[#good-read-code-evaluation-488-on-ward][<<<Good: Read code evaluation (488 on-ward)>>>]]
  - [[#good-fold][<<<Good: Fold>>>]]
  - [[#good-computation-model][<<<Good: Computation model>>>]]
  - [[#good-make-bottoms-only-local][<<<Good: Make bottoms only local>>>]]
  - [[#good-newtype-wrap-is-ideally-transparent-for-compiler-and-does-not-change-performance][<<<Good: Newtype wrap is ideally transparent for compiler and does not change performance>>>]]
  - [[#good-instances-of-typestype-classes-must-go-with-code-you-write][<<<Good: Instances of types/type classes must go with code you write>>>]]
  - [[#good-functions-can-be-abstracted-as-arguments][<<<Good: Functions can be abstracted as arguments>>>]]
  - [[#good-infix-operators-can-be-bind-to-arguments][<<<Good: Infix operators can be bind to arguments>>>]]
  - [[#good-arbitrary][<<<Good: Arbitrary>>>]]
  - [[#good-principle-of-separation-of-concerns][<<<Good: Principle of Separation of concerns>>>]]
  - [[#good-function-composition][<<<Good: Function composition>>>]]
  - [[#good-point-free][<<<Good: Point-free>>>]]
    - [[#good-point-free-is-great-in-multi-dimentions][<<<Good: Point-free is great in multi-dimentions>>>]]
  - [[#good-functor-application][<<<Good: Functor application>>>]]
  - [[#good-parameter-order][<<<Good: Parameter order>>>]]
  - [[#good-applicative-monoid][<<<Good: Applicative monoid>>>]]
  - [[#good-creative-process][<<<Good: Creative process>>>]]
    - [[#pick-phylosophy-principles-one-to-three-the-more---the-harder-the-implementation][Pick phylosophy principles one to three the more - the harder the implementation]]
    - [[#draw-the-most-blurred-representation][Draw the most blurred representation]]
    - [[#deduce-abstractions-and-write-remotely-what-they-are][Deduce abstractions and write remotely what they are]]
    - [[#model-of-computation][Model of computation]]
      - [[#model-the-domain][Model the domain]]
      - [[#model-the-types][Model the types]]
      - [[#think-how-to-write-computations][Think how to write computations]]
    - [[#create][Create]]
  - [[#good-about-operators----][<<<Good: About operators (<$) (**>) (<**) (>>)>>>]]
  - [[#good-about-operators-mapm_-sequence_][<<<Good: About operators mapM_ sequence_>>>]]
  - [[#good-guideliles][<<<Good: Guideliles>>>]]
    - [[#wikihaskell][Wiki.haskell]]
      - [[#documentation][Documentation]]
        - [[#comments-write-in-application-terms-not-technical][Comments write in application terms, not technical.]]
        - [[#tell-what-code-needs-to-do-not-how-it-does][Tell what code needs to do not how it does.]]
      - [[#haddoc][Haddoc]]
        - [[#put-haddock-comments-to-ever-exposed-data-type-and-function][Put haddock comments to ever exposed data type and function.]]
        - [[#haddock-header][Haddock header]]
      - [[#code][Code]]
        - [[#try-to-stay-closer-to-portable-haskell98-code][Try to stay closer to portable (Haskell98) code]]
        - [[#try-make-lines-no-longer-80-chars][Try make lines no longer 80 chars]]
        - [[#last-char-in-file-should-be-newline][Last char in file should be newline]]
        - [[#symbolic-infix-identifiers-is-only-library-writer-right][Symbolic infix identifiers is only library writer right]]
        - [[#every-function-does-one-thing][Every function does one thing.]]
  - [[#good-use-typed-holes-to-progress-the-code][<<<Good: Use Typed holes to progress the code>>>]]
  - [[#good-haskell-has-infinite-terms-not-not-infinite-types][<<<Good: Haskell has infinite terms not not infinite types.>>>]]
  - [[#good-use-type-sysnonims-to-differ-the-information][<<<Good: Use type sysnonims to differ the information>>>]]
  - [[#good-controlmonaderror---controlmonadexcept][<<<Good: Control.Monad.Error -> Control.Monad.Except>>>]]
  - [[#good-monad-or-applicative][<<<Good: Monad OR Applicative>>>]]
      - [[#start-writing-monad-using-return-ap-liftm-liftm2--instead-of-do][Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>=']]
      - [[#basic-case-when-applicative-can-be-used][Basic case when Applicative can be used]]
      - [[#applicative-block-vs-monad-block][Applicative block vs Monad block]]
  - [[#good-haskell-package-versioning-policy][<<<Good: Haskell Package Versioning Policy>>>]]
    - [[#-143][/*/]]
  - [[#good-linear-type][<<<Good: Linear type>>>]]
  - [[#good-exception-vs-error][<<<Good: Exception vs Error>>>]]
  - [[#good-let-vs-where][<<<Good: Let vs. Where>>>]]
- [[#bad-code][Bad code]]
  - [[#bad-pragma][<<<Bad pragma>>>]]
    - [[#bad-dangerous-language-pragma-option][Bad: Dangerous LANGUAGE pragma option]]
- [[#useful-functions-to-remember][Useful functions to remember]]
  - [[#prelude][Prelude]]
    - [[#ord][Ord]]
    - [[#calc][Calc]]
    - [[#list-operations][List operations]]
  - [[#datalist][Data.List]]
  - [[#datachar][Data.Char]]
  - [[#quickcheck-1][QuickCheck]]
- [[#investigate][Investigate]]
- [[#tools][Tools]]
  - [[#ghc-pkg][ghc-pkg]]
  - [[#search-over-the-haskell-packages-code-codesearch-from-aelve][Search over the Haskell packages code: Codesearch from Aelve]]
  - [[#integration-of-nixosnix-with-haskell-ide-engine-hie-and-emacs-spacemacs][Integration of NixOS/Nix with Haskell IDE Engine (HIE) and Emacs (Spacemacs)]]
    - [[#1-install-the-cachix-httpsgithubcomcachixcachix][1. Install the Cachix: https://github.com/cachix/cachix]]
    - [[#2-install-hie-on-nixos-httpsgithubcominfinisilall-hiescached-builds][2. Install HIE on NixOS: https://github.com/infinisil/all-hies/#cached-builds]]
      - [[#21-cached-builds][2.1. Cached builds]]
      - [[#22-nixos-installation][2.2. NixOS installation:]]
      - [[#23-switch-to-new-configuration][2.3. Switch to new configuration:]]
    - [[#3-emacs-spacemacs-configuration][3. Emacs (Spacemacs) configuration:]]
    - [[#4-open-the-haskell-file-from-a-project][4. Open the Haskell file from a project]]
    - [[#5-be-pleased-writing-code][5. Be pleased writing code]]
    - [[#6-optional-debugging][6. (optional) Debugging]]
  - [[#debugger][Debugger]]
- [[#libs][Libs]]
  - [[#exceptions][Exceptions]]
    - [[#exceptions---optionally-pure-extensible-exceptions-that-are-compatible-with-the-mtl][Exceptions - optionally pure extensible exceptions that are compatible with the mtl]]
    - [[#safe-exceptions---safe-simple-api-equivalent-to-the-underlying-implementation-in-terms-of-power-encourages-best-practices-minimizing-the-chances-of-getting-the-exception-handling-wrong][Safe-exceptions - safe, simple API equivalent to the underlying implementation in terms of power, encourages best practices minimizing the chances of getting the exception handling wrong.]]
    - [[#enclosed-exceptions---capture-exceptions-from-the-enclosed-computation-while-reacting-to-asynchronous-exceptions-aimed-at-the-calling-thread][Enclosed-exceptions - capture exceptions from the enclosed computation, while reacting to asynchronous exceptions aimed at the calling thread.]]
  - [[#memory-management][Memory management]]
    - [[#membrain---type-safe-memory-units][membrain - type-safe memory units]]
  - [[#parsers---megaparsec][Parsers - megaparsec]]
  - [[#clis---optparse-applicative][CLIs - optparse-applicative]]
  - [[#html---lucid][HTML - Lucid]]
  - [[#web-applications---servant][Web applications - Servant]]
  - [[#io-libraries][IO libraries]]
    - [[#conduit---practical-monolythic-guarantees-termination-return][Conduit - practical, monolythic, guarantees termination return]]
    - [[#pipes--pipes-parse---modular-more-primitive-theoretically-driven][Pipes + Pipes Parse - modular, more primitive, theoretically driven]]
  - [[#json---aeson][JSON - aeson]]
- [[#reference][Reference]]
  - [[#functor-applicative-monad-proposal][<<<Functor-Applicative-Monad Proposal>>>]]
    - [[#-144][/*/]]
  - [[#haskell-98][Haskell-98]]
    - [[#old-instance-termination-rules][<<<Old instance termination rules>>>]]
- [[#liturgy][Liturgy]]

* Definitions
:PROPERTIES:
:ID:       68eb5f9c-7d07-4a32-9440-eb24e1399a7a
:END:

** <<<Abstraction>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       7875b659-d137-41df-b146-6fb73f090a4e
:DRILL_LAST_INTERVAL: 9.1096
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:15]
:END:

abs away from, off (in absentia)
tractus draw, haul, drag

Purified generalization of process.

Forgeting the details. Simplified approach.

/*/ creates a new semantic level in which one can be absolutely precise.

It is great did to name an abstraction (Denotational semantics).

*** /*/
<<<Abstractions>>>
<<<Abstracting>>>
<<<Abstract>>>

** <<<Algebra>>> :drill:
SCHT: <2019-09-16 Mon>
:PROPERTIES:
:ID:       ef37e5f5-d52b-49eb-837e-1195558b6e79
:DRILL_LAST_INTERVAL: 52.5213
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:15]
:END:

al-jabr - assemble parts.
A system of algebra based on given axioms.

---

1) Abstract algebra - the study of number systems and operations within them.
2) Algebra - vector space over a field with a multiplication.

*** /*/
<<<Algebras>>>

*** <<<Algebraic>>> :drill:
:PROPERTIES:
:ID:       c97061e0-d726-44d0-bd18-fd1288c46a52
:END:

Composite from simple parts.
Also: Algebraic data type.

*** <<<Algebraic structure>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       dcbe48e5-d7dd-400d-9963-d4e00d474b84
:DRILL_LAST_INTERVAL: 9.3103
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:07]
:END:

Algebraic structure on a set A (called carrier set or underlying set) is a collection of finitary operations on A.
The set A with this structure is also called an algebra.

Algebraic structures include groups, rings, fields, and lattices. More complex structures can be defined by introducing multiple operations, different underlying sets, or by altering the defining axioms. Examples of more complex algebraic structures include vector spaces, modules, and algebras. 

"Group-like structures":
|                   | Closure | Associativity | Identity | Invertability | Commutativity |
|-------------------+---------+---------------+----------+---------------+---------------|
| Semigroupoid      |         | \check             |          |               |               |
| Small Category    |         | \check             | \check        |               |               |
| Groupoid          |         | \check             | \check        | \check             |               |
| Magma             | \check       |               |          |               |               |
| Quasigroup        | \check       |               |          | \check             |               |
| Loop              | \check       |               | \check        | \check             |               |
| Semigroup         | \check       | \check             |          |               |               |
| Inverse Semigroup | \check       | \check             |          | \check             |               |
| Monoid            | \check       | \check             | \check        |               |               |
| Group             | \check       | \check             | \check        | \check             |               |
| Abelian group     | \check       | \check             | \check        | \check             | \check             |
| Ring              | \check       | \check             | \check        | \check             | under +       |

**** /*/
<<<Algebraic structures>>>

** <<<Alpha equivalence>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       83ea3e34-0c72-4976-abaa-875767736cea
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:44]
:END:

Alpha equivalence - if processes in expressions are literally the same, but names of parameters accordingly different (then they are synonyms).

** <<<Ambigram>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       bc8fb3d5-d6bf-46b3-bf5b-5955e8f05a67
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:27]
:END:

ambi both
γράμμα /grámma/ written character

Object from different points of view has the same meaning.

While this word has two contradictory diametrically opposite meanings, one was chosen.

But it has... Both.

/TODO: For merit of differentiating the meaning about different meaning referring to Tensor as object with many meanings./

** Ancient Greek and Latin prefixes :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       773bbd3b-bf0f-41c2-a61b-9bb36381bd54
:DRILL_LAST_INTERVAL: 8.7892
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:01]
:END:

| Meaning                 | Greek prefix      | Latin prefix         |
|-------------------------+-------------------+----------------------|
| above, excess           | hyper-            | super-, ultra-       |
| across, beyond, through | dia-              | trans-               |
| after                   |                   | post-                |
| again, back             |                   | re-                  |
| against                 | anti-             | contra-, (in-, ob-)  |
| all                     | pan               | omni-                |
| around                  | peri-             | circum-              |
| away or from            | apo-, ap-         | ab- (or de-)         |
| bad, difficult, wrong   | dys-              | mal-                 |
| before                  | pro-              | ante-, pre-          |
| between, among          |                   | inter-               |
| both                    | amphi-            | ambi-                |
| completely or very      |                   | de-, ob-             |
| down                    |                   | de-, ob-             |
| four                    | tetra-            | quad-                |
| good                    | eu-               | ben-, bene-          |
| half, partially         | hemi-             | semi-                |
| in, into                | en-               | il-, im-, in-, ir-   |
| in front of             | pro-              | pro-                 |
| inside                  | endo-             | intra-               |
| large                   | macro-            | (macro-, from Greek) |
| many                    | poly-             | multi-               |
| not*                    | a-, an-           | de-, dis-, in-, ob-  |
| on                      | epi-              |                      |
| one                     | mono-             | uni-                 |
| out of                  | ek-               | ex-, e-              |
| outside                 | ecto-, exo-       | extra-, extro-       |
| over                    | epi-              | ob- (sometimes)      |
| self                    | auto-, aut-,auth- | ego-                 |
| small                   | micro-            |                      |
| three                   | tri-              | tri-                 |
| through                 | dia-              | trans-               |
| to or toward            | epi-              | ad-, a-, ac-, as-    |
| two                     | di-               | bi-                  |
| under, insufficient     | hypo-             | sub-                 |
| with                    | sym-, syn-        | co-. com-, con-      |
| within, inside          | endo-             | intra-               |
| without                 | a-, an-           | dis- (sometimes)     |

*** /*/
<<<Greek prefix>>>
<<<Latin prefix>>>

** <<<Application>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       2ecbb029-b5d4-447b-81f6-ff9242231aee
:DRILL_LAST_INTERVAL: 21.4987
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:44]
:END:

For FP see Bind. And then beta reduction happen.

** <<<Application memory>>> :drill:
:PROPERTIES:
:ID:       49209cb4-a094-4b16-8803-884efd701706
:END:

| Storage of                        | Block name    |
|-----------------------------------+---------------|
| All not currently processing data | <<<Heap>>>   |
| Function call, local variables    | <<<Stack>>>  |
| Static and global variables       | Static/Global |
| Instructions                      | Binary code   |

When even Main invoked - it work in Stack, and called Stack frame. Stack frame size for function calculated when it is compiled.
When stacked Stack frames exceed the Stack size - stack overflow happens.

** <<<Argument>>> :drill:
:PROPERTIES:
:ID:       56fadaf0-586a-4e26-a216-c39fcca004ea
:END:

/arguere/ to make clear, to shine
argument evidence, proof

A statement that results in system consequences.

*** <<<Argument of a function>>> :drill:
:PROPERTIES:
:ID:       42c01d98-580d-45c6-b602-119eb92b6b42
:END:

A value binded to the function parameter. Value/topic that the fuction would process/deal with.

Also see <<<Argument>>>.

**** /*/
<<<Function argument>>>

** <<<As-pattern>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       a2d762f7-549b-4aa1-ba3e-183c2e757a35
:DRILL_LAST_INTERVAL: 8.7892
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:01]
:END:

#+begin_src haskell
f list@(x, xs) = ...
#+end_src

** <<<Binary>>> :drill:
SCHT: <2019-07-31 Wed>
:PROPERTIES:
:ID:       f6ddbc05-f514-49e1-8906-28e67eb0866c
:DRILL_LAST_INTERVAL: 31.0268
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:51]
:END:

Two of something.

** <<<Binary tree>>> :drill:
:PROPERTIES:
:ID:       8efc93b6-3518-40e7-9143-eb695b267bd4
:END:

#+begin_src haskell
data BinaryTree a
  = [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)
#+end_src

** <<<Bind>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       2e4ac590-3b8a-4c70-9229-a83d30f6b149
:DRILL_LAST_INTERVAL: 23.0375
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:07]
:END:

Establishing Eq between two objects.
Parameter of the function = argument that applied to the function
Variables = values.

*** /*/
<<<Binds>>>
<<<Binding>>>

** <<<Bottom value>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       6a1419f1-74f8-4cab-9f50-6dd93c2b47bd
:DRILL_LAST_INTERVAL: 24.0814
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:22]
:END:

#+begin_src haskell
-- _ fits *.
#+end_src

Is a non-value placeholder for enything.

*** /*/
<<<Bottom>>>
<<<Bottom values>>>

** <<<Bound>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       31ef00a3-6d1e-4ee4-a0da-eac26238aace
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:50]
:END:

Haskell /*/ type class means to have lowest value & highest value, so a bounded range of values.

*** /*/
<<<Bounded>>>

** <<<Cartesian product>>> :drill:
:PROPERTIES:
:ID:       1c2c6ec3-701a-4803-a73a-7564b4ffb298
:END:

$$ \mathcal{A} \times \mathcal{B} \equiv \sum^{\forall}{\overrightarrow{(a,b)}} \ | \ \forall a \in \mathcal{A}, \forall b \in \mathcal{B} $$.

Any function, functor is a subset of Cartesian product.

$$ \sum{(elem \in (\mathcal{A} \times \mathcal{B}))}  = cardinality^{A \times B} $$

*** /*/
<<<Cardinalities>>>

** <<<Case>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       14309b50-3648-47ba-a4b1-eb5aa4bd7a3c
:DRILL_LAST_INTERVAL: 20.7426
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.75
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:49]
:END:

#+begin_src haskell
case x of
    | pattern1  -> ex1
    | pattern2  -> ex2
    | pattern3  -> ex3
    | otherwise -> exDefault
#+end_src

Syntatic sugar with guards allows usage of expressions:
#+begin_src haskell
case () of _
             | expr1     -> ex1
             | expr2     -> ex2
             | expr3     -> ex3
             | otherwise -> exDefault
#+end_src

** <<<Category theory>>> :drill:
SCHT: <2019-08-04 Sun>
:PROPERTIES:
:ID:       a026cdb8-26e0-494e-b51c-b49d0210d61b
:DRILL_LAST_INTERVAL: 10.3873
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:20]
:END:

Category ($$ \mathcal{C} $$) consists of the basis:

Primitives:
  1. Objects - $$ a^{\mathcal{C}} $$. A node. Object of some type. Often sets, than it is Set category.
  2. Morphisms - $$ \overrightarrow{(a,b)}^{\mathcal{C}} $$ (AKA mappings).
  3. Morphism composition - binary operation: $$ \overrightarrow{(a, b)}^{\mathcal{C}} \circ \overrightarrow{(b, c)}^{\mathcal{C}} \equiv \overrightarrow{(a, c)}^{\mathcal{C}} \ | \ \forall a, b, c \in \mathcal{C} $$. AKA principle of compositionality for morphisms.

Properties (or axioms):
  1. Associativity of morphisms: $$ \overrightarrow{h} \circ (\overrightarrow{g} \circ \overrightarrow{f}) \equiv (\overrightarrow{h} \circ \overrightarrow{g}) \circ \overrightarrow{f} \ \ | \ \ \overrightarrow{f}_{a \to b}, \overrightarrow{g}_{b \to c}, \overrightarrow{h}_{c \to d} $$.
  2. Every object has exactly one (two-sided) identity morphism: $$ \overrightarrow{1}_x \circ \overrightarrow{f}_{a \to x} \equiv \overrightarrow{f}_{a \to x}, \ \ \overrightarrow{g}_{x \to b} \circ \overrightarrow{1_x} \equiv \overrightarrow{g}_{x \to b } \ \ | \ \ \forall x \ \exists \overrightarrow{1}_{x}, \forall \overrightarrow{f}_{a \to x},  \forall \overrightarrow{g}_{x \to b} $$.
  3. Principle of compositionality.

From these axioms, can be proven that there is exactly one identity morphism for every object.

Object and morphism is complete abstractions for anything.
In majority of cases under object is a state and morphism is a change.

*** /*/
<<<Category>>>
<<<Categories>>>

*** <<<Abelian category>>> :drill:
SCHT: <2019-08-04 Thu>
:PROPERTIES:
:ID:       dfd74db1-0c16-430d-83b7-8dcc2fb16d34
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:16]
:END:

Is which:
  * has a zero object,
  * has all binary biproducts,
  * has all kernel's and cokernels,
  * (it has all pullbacks and pushouts)
  * all monomorphism's and epimorphism's are normal.
Abelian category is very stable; for example they are regular and they satisfy the snake lemma.
The class of Abelian categories is closed under several categorical constructions.

There is notion of Abelian monoid (AKS Commutative monoid) and Abelian group (Commutative group).

*** <<<Composition>>> :drill:
:PROPERTIES:
:ID:       b3bc17d9-83e4-4862-a391-27e0b30e011e
:END:

Axiom of Category.

**** /*/
<<<Composable>>>
<<<Compositions>>>

*** <<<Endofunctor category>>> :drill:
:PROPERTIES:
:ID:       1a5d0ae1-6c37-4e53-860b-beddb4c00074
:END:

From the name, in this Category:
  * objects of $$ End $$ are Endofunctors $$ E^{\mathcal{C \to C}} $$
  * morphisms are natural transformations between endofunctors

*** <<<Functor>>> :drill:
:PROPERTIES:
:ID:       8cb2d494-936a-4031-b1c1-7ee18caecf31
:END:

Functor is a map between categories. Translating objects and morphisms (as input can take morphism or object). They can preserve structure, or not.

Functor properties (axioms):
  * $$ F^{\mathcal{C \to D}}(a) \quad | \quad \forall a^{\mathcal{D}} $$ - every source object is mapped to object in target category
  * $$ \overrightarrow{(F^{\mathcal{C \to D}}(a),F^{\mathcal{C \to D}}(b))}^{\mathcal{D}} \ \ | \ \ \forall \overrightarrow{(a, b)}^{\mathcal{C}} $$ - every source morphism is mapped to target category morphism between corresponding objects
  * $$ F^{\mathcal{C \to D}}(\overrightarrow{g}^{\mathcal{C}} \circ \overrightarrow{f}^{\mathcal{C}}) = F^{\mathcal{C \to D}}(\overrightarrow{g}^{\mathcal{C}}) \circ F^{\mathcal{C \to D}}(\overrightarrow{f}^{\mathcal{C}}) \quad | \quad \forall y=\overrightarrow{f}^{\mathcal{C}}(x), \forall \overrightarrow{g}^{\mathcal{C}}(y) $$ - composition of morphisms translates directly

These axioms guarantee that composition of functors can be fused into one functor with composition of morphisms. This process called fusion.

In Haskell this axioms have form:
#+begin_src haskell
fmap id = id
fmap (f . g) = fmap f . fmap g
#+end_src

**** /*/
<<<Power set functor>>>
<<<fmap>>>
<<<Functors>>>

**** <<<Power set functor>>> :drill:
SCHT: <2019-08-17 Sat>
:PROPERTIES:
:ID:       1169dfd1-4e31-4789-a777-288fc9208094
:DRILL_LAST_INTERVAL: 23.1978
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:14]
:END:

/*/ - functor from set $$ S $$ to its power set $$ \mathcal{P}(S) $$.

Functor type class in Haskell corresponds to mathematical power set functor and allows to do function application inside type structure layers (denoted $$ f $$ or $$ m $$). IO is also such structure.
Power set is unique to the set, power set functor is unique to the category (data type).

#+begin_src haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src

Functor instance must be of kind =( * -> * )=, so instance for higher-kinded data type must be applied until this kind.

Composed functors lift functions through layers of structure.

Power set functor can be used to filter-out error cases (Nothing & Left cases) in Maybe, Either and related types.

***** <<<Power set functor laws>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       653e04a0-f7b1-4c48-b0c1-e6c83bc6db7c
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

Type instance of functor should abide this laws:

****** /*/
<<<Functor laws>>>

****** <<<Power set functor identity law>>> :drill:
:PROPERTIES:
:ID:       46aa6606-2ac1-477e-9632-e79143f4fe3b
:END:

#+begin_src haskell
fmap id == id
#+end_src

****** <<<Power set functor composition law>>> :drill:
:PROPERTIES:
:ID:       a25f03e6-0423-41b5-92a1-26d84bd6243e
:END:

#+begin_src haskell
fmap (f.g) == fmap f . fmap g
#+end_src
In words, it is if several functions are composed and then fmap is applied on them - it should be the same as if functions was fmapped and then composed.

***** <<<Lift>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       d6a94338-9bce-4513-8a51-66aefcc483fb
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:48]
:END:

#+begin_src haskell
fmap :: (a -> b) -> (f a -> f b)
#+end_src
Functor takes function =a -> b= and returns a function =f a -> f b= this is called lifting a function.
Lift does a function application through the data structure.

****** /*/
<<<Lifting>>>

***** <<<Power set functor is a free monad>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       85146d1c-7cb7-4c9b-a998-791b33f1a518
:DRILL_LAST_INTERVAL: 10.764
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:52]
:END:

Since:
  * $$ \forall e \in S : \exists \{e\} \, \in \, {\mathcal{P}(S)} \ \vDash \ \forall e \in S : \exists (e \to \{e\}) \equiv unit $$
  * $$ \forall \mathcal{P}(S) : \mathcal{P}(S) \in \mathcal{P}(S) \ \vDash \ \forall \mathcal{P}(S) : \exists (\mathcal{P}(\mathcal{P}(S)) \to \mathcal{P}(S)) \equiv join $$

**** <<<Forgetful functor>>> :drill:
:PROPERTIES:
:ID:       f175e7f3-f5bc-4c5c-b351-9df5080720b1
:END:

Functor that forgets part or all of what defines structure in domain category.
$$ F^{\mathbf {Grp} \to \mathbf {Set}} $$ that translates groups into their underlying sets.
Constant functor is another example.

***** /*/
<<<Forgetful>>>

**** <<<Identity functor>>> :drill:
:PROPERTIES:
:ID:       9dbbb6a7-e9ae-4c29-8468-aa20fc143b84
:END:

Maps all category to itself. All objects and morphisms to themselves.

Denotation:
$$ 1^{\mathcal{C \to C}} $$

**** <<<Endofunctor>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       96d8e579-c7b5-45a0-afbe-c4fca13c4637
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:21]
:END:

Is a functor which source (domain) and target (codomain) are the same category.

$$ F^{\mathcal{C \to C}}, E^{\mathcal{C \to C}} $$

***** /*/
<<<Endofunctors>>>

**** <<<Applicative functor>>> :drill:
:PROPERTIES:
:ID:       423ac24e-497b-4ab1-b1c5-99ed84ec6546
:END:

/*/ - Computer science term. Category theory name - lax monoidal functor. And in category $$ Set $$, and so in category $$ Hask $$ all applicatives and monads are strong (have tensorial strength).

/*/ - sequences functorial computations (plain functors can't).

#+begin_src haskell
(<*>) :: f (a -> b) -> f a -> f b
#+end_src

Requires Functor to exist.
Requires Monoidal structure.

Has monoidal structure rules, separated from what happens inside structure.

Data type can have several applicative implementations.

Standard definition:
#+begin_src haskell
class Functor f => Applicative f where
  (<*>) :: f (a -> b) -> f a -> f b
  pure :: a -> f a
#+end_src

The old function:
#+begin_src haskell
ap :: Monad m => m (a -> b) -> m a -> m b
#+end_src

=Control.Monad ap= is old implementation of =<*>=.

***** /*/
<<<Applicative>>>
<<<Applicatives>>>
<<<Applicative functors>>>

***** <<<Applicative laws>>> :drill:
:PROPERTIES:
:ID:       e2527c05-e4d8-49e6-8648-02d49ab27c3a
:END:

****** <<<Applicative identity law>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       2e87e916-1501-4310-9887-e0bcf7b9e1ca
:DRILL_LAST_INTERVAL: 3.995
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:57]
:END:

#+begin_src haskell
pure id <*> v = v
#+end_src

****** <<<Applicative composition law>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       74ed933d-bb1e-4169-919a-b3c491973011
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

Function composition works regularly.
#+begin_src haskell
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
#+end_src

****** <<<Applicative homomorphism law>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       fe44ce3c-3912-48bd-8e60-367cc3ac3b20
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:05]
:END:

Applying the function doesn't change the structure around values.
#+begin_src haskell
pure f <*> pure x = pure (f x)
#+end_src

****** <<<Applicative interchange law>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       f3e40391-0f29-4689-852c-6fc7c3f57dfd
:DRILL_LAST_INTERVAL: 9.1096
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:02]
:END:

On condition that internal order of evaluation is preserved - order of operands is not relevant.
#+begin_src haskell
u <*> pure y = pure ($ y) <*> u
#+end_src

***** <<<Applicative function>>>

****** <<<liftA*>>>

******* <<<liftA>>> :drill:
:PROPERTIES:
:ID:       8d9bbfb6-95d0-46c5-85bc-05c357721882
:END:

Essentially a fmap.
#+begin_src haskell
:type liftA
liftA :: Applicative f => (a -> b) -> f a -> f b
#+end_src

Lifts function into applicative function.

******* <<<liftA2>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       68d78ba7-589e-4eb0-90fc-c6d286fd327e
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:48]
:END:

Lifts binary function across two Applicative functors.
#+begin_src haskell
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
#+end_src

#+begin_src haskell
liftA2 f x y == pure f <*> x <*> y
#+end_src

******* <<<liftA2 (<*>)>>> :drill:
:PROPERTIES:
:ID:       ac1da978-3adc-447a-a20d-3f15f8cfd940
:END:

liftA2 (<*>) is pretty useful. It can lift binary operation through the two layers:
It is two-layer Applicative.
#+begin_src haskell
liftA2 :: Applicative f => (    a       ->  b  ->  c ) -> f      a        ->  f    b   ->  f    c
<*> :: Applicative f =>    (f  (a -> b) -> f a -> f b)
liftA2 (<*>) :: (Applicative f1, Applicative f2) =>      f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
#+end_src

******* <<<liftA2 (liftA2 (<*>))>>> :drill:
:PROPERTIES:
:ID:       276bd112-3c4c-4c31-9650-28bce44786f9
:END:

liftA2 (<*>) 3-layer version.

******* <<<liftA3>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       8371488b-da13-401b-9648-c286f2af0c99
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:56]
:END:

liftA2 3-parameter version.

#+begin_src haskell
liftA3 f x y z == pure f <*> x <*> y <*> z
#+end_src

****** Conditional applicative computations :drill:
:PROPERTIES:
:ID:       4c9c0341-bcaf-4965-9316-f657015323ef
:END:

#+begin_src haskell
when :: Applicative f => Bool -> f () -> f ()
#+end_src

Only when =True= - perform an applicative computation.

#+begin_src haskell
unless :: Applicative f => Bool -> f () -> f ()
#+end_src

Only when =False= - perform an applicative computation.

***** <<<Special applicatives>>> :drill:
:PROPERTIES:
:ID:       c67fa1eb-a529-43a8-b88b-926325e124ce
:END:

****** <<<Identity applicative>>> :drill:
:PROPERTIES:
:ID:       72602f6e-4290-4db5-bd26-f6abe614384d
:END:

#+begin_src haskell
-- Applicative f =>
-- f ~ Identity
type Id = Identity
instance Applicative Id
  where
    pure :: a -> Id a
    (<*>) :: Id (a -> b) -> Id a -> Id b

mkId = Identity
xs = [1, 2, 3]

const <$> mkId xs <*> mkId xs'
-- [1,2,3]
#+end_src

****** <<<Constant applicative>>> :drill:
:PROPERTIES:
:ID:       9389eea3-10e3-410b-a6ef-a56d9ab7163e
:END:

It holds only to one value. The function does not exist and `b` is phantom.
#+begin_src haskell
-- Applicative f =>
-- f ~ Constant e
type C = Constant
instance Applicative C
  where
    pure :: a -> C e a
    (<*>) :: C e (a -> b) -> C e a -> C e b

pure 1
-- 1
pure 1 :: Constant String Int
-- Constant {getConstant = ""}
#+end_src

****** <<<Maybe applicative>>> :drill:
:PROPERTIES:
:ID:       5929b239-fa46-40c6-9896-a2dabe40f619
:END:

"There also can be no function at all."

If function might not exist - embed `f` in Maybe structure, and use Maybe applicative.
#+begin_src haskell
-- f ~ Maybe
type M = Maybe
pure :: a -> M a
(<*>) :: M (a -> b) -> M a -> M b
#+end_src

****** <<<Either applicative>>> :drill:
:PROPERTIES:
:ID:       f85602e3-3339-4ab7-ac38-5025b8aa6828
:END:

`pure` is `Right`.
Defaults to `Left`.
And if there is two Left's - to Left of the first argument.

****** <<<Validation applicative>>> :drill:
:PROPERTIES:
:ID:       84ed0f96-b39b-4132-aafa-c6e58cb280ab
:END:

The Validation data type isomorphic to Either, but has accumulative Applicative on the error side.
For this Applicative there is no corresponding Bind or Monad instance. Validation is an example of, "An applicative functor that is not a monad."
Because monad needs to process the result of computation - it needs to be able to process Left error statements, which is hard. Either monad on Left case just drops computation and returns this first Left. 

***** <<<Monad>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       b1faf835-213f-4336-86a9-8e331dd60986
:DRILL_LAST_INTERVAL: 9.1096
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:51]
:END:

μόνος /monos/ sole
μονάδα /monáda/ unit

/*/ - monoid in endofunctor category with $$ \overrightarrow{\eta} $$ (unit) and $$ \overrightarrow{\mu} $$ (join) natural transformations.

If $$ \mathcal{C} $$ is a category, a monad on $$ \mathcal{C} $$ consists of:
  * an endofunctor $$ E^{\mathcal{C \to C}} $$
  * two natural transformations:
    * $$ \overrightarrow{\eta}^{1^{\mathcal{C}} \to E} = {unit}^{Identity \to E}(x) = f^{ x \to E(x)}(x) $$
    * $$ \overrightarrow{\mu}^{(E \circ E) \to E} = {join}^{(E \circ E) \to (Identity \circ E)}(x) = | y = E(x) | = f^{E (y) \to y}(y) $$

Where:
  * $$ 1^{\mathcal{C}} $$ denotes the $$ \mathcal{C} $$ identity functor,
  * $$ (E \circ E) $$ - endofunctor $$ \mathcal{C \to C} $$.

Definition with $$ \{E^{\mathcal{C \to C}}, \, \overrightarrow{\eta}, \, \overrightarrow{\mu}\} $$ (in Hask: ($$ \{e \, :: \, f \, a \, \to \, f \, b, \ pure, \ join\} $$)) - is classic categorical, in Haskell minimal complete definition is $$ \{fmap, \, pure, \, (>>=)\} $$.

If there is a structure $$ S $$, and a way of taking object $$ x $$ into $$ S $$ and a way of collapsing $$ S \circ S $$ - there probably a monad.

Mostly monads used for sequencing actions (computations) (that looks like imperative programming), with ability to dependend on previous chains. Note if monad is commutative - it does not order actions.

Monad can shorten/terminate sequence of computations. It is implemented inside Monad instance. For example Maybe monad on Nothing drops chain of computation and returns Nothing.

Monadic internals are Haskell data types, and as such - they can be consumed any number of times.

Same Monad and Applicative instances must be the same:
#+begin_src haskell
import Control.Monad (ap)
return == pure
ap == (<*>) -- + Monad requirement
#+end_src

| Mathematics                                  | Haskell                                   | Math meaning                                                     |
|----------------------------------------------+-------------------------------------------+------------------------------------------------------------------|
| $$ E $$                                      | = <$> ∷ Functor f ⇒ (a → b) → f a → f b = | power set functor (thou in CAT it can be any suiting endofunctor) |
| $$ \overrightarrow{\eta}_{ID \to E} $$       | = pure ∷ Applicative f ⇒ a → f a =        | unit (natural transformation for functors $$ ID \to P $$)        |
| $$ \overrightarrow{\mu}_{E \circ E \to E} $$ | = join ∷ Monad f ⇒ f (f a) → f a =        | join (natural transformation for functors $$ P \circ P \to P $$) |

****** /*/
<<<Monads>>>
<<<Monadic>>>

****** <<<Monad laws>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       7829bf03-a14b-411b-8460-7a8781227b60
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.75
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

pure (return) should only put argument into structure.

******* <<<Monad left identity law>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       2a41dd66-e0bf-4741-932f-9d28ae3a95c7
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:05]
:END:

#+begin_src haskell
pure x >>= f == f x
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f =>    f a  -> (a -> f b) -> f b
                  pure x >>=     f      == f x
#+end_src
Shows that >>= must get Argument internal to structure and apply it to the second argument.

******* <<<Monad right identity law>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       c009e530-319b-4127-8ca3-c05faf4f86cd
:DRILL_LAST_INTERVAL: 3.855
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:END:

#+begin_src haskell
f >>= pure == f
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f => f a  -> (a -> f b) -> f b
                  f   >>=    pure    == f
#+end_src
AKA it is a tacit description of a monad bind as endofunctor.

******* <<<Monad associativity law>>> :drill:
:PROPERTIES:
:ID:       24c71ee3-c7b5-46ca-a9fa-6dff090cf836
:END:

#+begin_src haskell
(m >>= f) >>= g == m >>= (\ x -> f x >>= g)
#+end_src

****** <<<Monad type class>>> :drill:
:PROPERTIES:
:ID:       3d4d8b32-1508-41b1-83a8-c0a910d8e1e8
:END:

#+begin_src haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
#+end_src

******* <<<MonadPlus type class>>> :drill:
SCHT: <2019-08-02 Fri>
:PROPERTIES:
:ID:       379a53d8-b1a9-4e0d-a1c6-fe201b9e9fd4
:DRILL_LAST_INTERVAL: 10.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:58]
:END:

Is a monoid over monad, with additional rules.
The precise set of rules (properties) not agreed upon. Class instances obey /monoid/ & /left zero/ rules, some additionally obey /left catch/ and others /left distribution/.

Overall there /*/ currently reforms (MonadPlus reform proposal) in several smaller nad strictly defined type classes.

Subclass of an Alternative.

******** /*/
<<<Monadplus>>>

****** Functor -> Applicative -> Monad progression :drill:
:PROPERTIES:
:ID:       21916c6b-42f9-46be-a4bb-60200aa5cb8d
:END:

#+begin_src haskell
<$> :: Functor     f =>   (a -> b)   -> f a -> f b
<*> :: Applicative f => f (a -> b)   -> f a -> f b
=<< :: Monad       f =>   (a -> f b) -> f a -> f b
#+end_src
=pure= & =join= are Natural transformations for the =fmap=.

****** <<<Monad function>>> :drill:
:PROPERTIES:
:ID:       e15d6b3b-61de-489d-8a06-9986b24926d6
:END:

******* <<<Return function>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       bb5891cb-a918-476b-a27a-4d342bdc30a2
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:55]
:END:

#+begin_src haskell
return == pure
#+end_src
Nonstrict.

******* <<<Join function>>> :drill:
:PROPERTIES:
:ID:       fda130b8-e8ae-4c3d-948a-94129d562a63
:END:

#+begin_src haskell
join :: Monad m => m (m a) -> m a
#+end_src
Flattens two layers of structure into one.
Join is a generalization of `concat`.

The way to express ordering in lambda calculus is to nest.

******** /*/
<<<join>>>

******** join . fmap == (=<<)

#+begin_src haskell
-- b = f b
fmap        :: Monad f => (a -> f b) -> f a -> f (f b)
join        :: Monad f =>                      f (f a) -> f a
join . fmap :: Monad f => (a -> f b) -> f a            -> f b
flip    >>= :: Monad f => (a -> f b) -> f a            -> f b
#+end_src

******* <<<Bind function>>> :drill:
:PROPERTIES:
:ID:       b288ba16-30a9-4550-b037-f77d4c96e95a
:END:

#+begin_src haskell
>>=         :: Monad f => f a -> (a -> f b) -> f b
join . fmap :: Monad f => (a -> f b) -> f a -> f b
#+end_src
Nonstrict.

The most ubiqutous way to >>= something is to use Lambda function:
#+begin_src haskell
getLine >>= \name -> putStrLn "age pls:"
#+end_src

Also very neet way is to bundle and handle Monad - is to bundle it with bind, and leave applied partially.
And use that partial bundle as a function - every evaluation of the function would trigger evaluation of internal Monad structure. Thumbs up. 
#+begin_src haskell
printOneOf ∷ Bool → IO ()
printOneOf False = putStr "1"
printOneOf  True = putStr "2"

quant ∷ (Bool → IO b) → IO b
quant = (>>=) (randomRIO (False, True))

recursePrintOneOf ∷ Monad m ⇒ (t → m a) → t → m b
recursePrintOneOf f x = (f x) >> (recursePrintOneOf f x)

main ∷ IO ()
main = recursePrintOneOf (quant) $ printOneOf
#+end_src

******** /*/
<<<Monadic bind>>>
<<<Monad bind>>>
<<<Binder>>>
<<<Binder function>>>

********* (>>=)

********* >>=

********* (=<<)

********* =<<

******* <<<Sequencing operator>>> (>>) == (*>): :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       f8d9b6e3-b18c-4996-a86d-08107f8eec1f
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

Discards any resulting value of the action and sequence next action.
#+begin_src haskell
(>>) :: m a -> m b -> m b
(*>) :: f a -> f b -> f b
#+end_src
Applicative has a similar operator.

******* Monadic versions of list functions :drill:
:PROPERTIES:
:ID:       0a38c76a-ae98-46dd-830a-62424aa6c8f7
:END:

#+begin_src haskell
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
#+end_src

Sequence gets the traversable of monadic computations and swaps it into monad computation of taverse. In the result the collection of monadic computations turns into one long monadic computation on traverse of data.

If some step of this long computation fails - monad fails.

#+begin_src haskell
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
#+end_src

=mapM= gets the AMB function, then takes traversable data. Then applies AMB function to traversable data, and returns converted monadic traversable data.

#+begin_src haskell
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
foldl ::  Foldable t           => (b -> a ->   b) -> b -> t a ->   b
#+end_src

/*/ is a monadic =foldl=.

=b= is initial comulative value, =m b= is a comulative bank.
Right folding achieved by reversing the input list.

#+begin_src haskell
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
filter ::                   (a ->   Bool) -> [a] ->   [a]
#+end_src

Take Boolean monadic computation, filter the list by it.

#+begin_src haskell
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWith  ::                  (a -> b ->   c) -> [a] -> [b] ->   [c]
#+end_src

Take monadic combine function and combine two lists with it.

#+begin_src haskell
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
sum  :: (Foldable t, Num a)       => t    a  ->   a
#+end_src

******* <<<liftM*>>>
:PROPERTIES:
:ID:       6a0f3747-8f90-496b-9c5d-b4794502b725
:END:

******** <<<liftM>>> :drill:
:PROPERTIES:
:ID:       10f01bcb-ef2b-45c5-b950-6f2cb56eb908
:END:

Essentially a fmap.

#+begin_src haskell
liftM :: Monad m => (a -> b) -> m a -> m b
#+end_src

Lifts a function into monadic equivalent.

******** <<<liftM2>>> :drill:
:PROPERTIES:
:ID:       5915fc63-5e3a-47fa-83ba-3904abeccb14
:END:

Monadic liftA2.
#+begin_src haskell
liftM2 :: Monad m => (a -> b -> c) -> m a -> m a -> m c
#+end_src

Lifts binary function into monadic equivalent.

****** <<<Comonad>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       f0f0fdd4-f056-4d4d-85ad-f449103b1d8c
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

Category $$ \mathcal{C} $$ comonad is a monad of opposite category $$ \mathcal{C}^{op} $$.

****** <<<Kleisli category>>> :drill:
SCHT: <2019-08-04 Sun>
:PROPERTIES:
:ID:       4039e73f-073c-4930-9753-1af3fde66050
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:23]
:END:

Category $$ \mathcal{C} $$, $$ 〈E, \overrightarrow{\eta}, \overrightarrow{\mu}〉 $$ monad over $$ \mathcal{C} $$.

Kleisli category $$ \mathcal{C}_{T} $$ of $$ \mathcal{C} $$:

$$ \mathrm{Obj}(\mathcal{C}_{T}) \ = \ \mathrm{Obj}(\mathcal{C}) $$
$$ \mathrm{Hom}_{\mathcal{C}_{T}}(x,y) \ = \ \mathrm{Hom}_{\mathcal{C}}(x,E(y)) $$

****** <<<Special monad>>>
:PROPERTIES:
:ID:       6b44c29f-6e27-4ff3-bd40-d7f6ad97121b
:END:

******* <<<Identity monad>>> :drill:
:PROPERTIES:
:ID:       dda1f03b-a476-48eb-894b-06d18733297b
:END:

Wraps data in the Identity constructor.

Useful: Creates monads from monad transformers.

Bind: Applies internal value to the bound function.

Code:
#+begin_src haskell
newtype Identity a = Identity { runIdentity :: a }

-- coerse is a function that directly moves data between type aliases
instance Functor Identity where
  fmap     = coerce

instance Applicative Identity where
  pure     = Identity
  (<*>)    = coerce

instance Monad Identity where
  m >>= k  = k (runIdentity m)
#+end_src

Example:
#+begin_src haskell
-- derive the State monad using the StateT monad transformer
type State s a = StateT s Identity a
#+end_src

******* <<<Maybe monad>>> :drill:
:PROPERTIES:
:ID:       dce21b9b-4b6a-4aea-8cbe-06a84f8c1c0f
:END:

Something that may not be or not return a result. Any lookups into the real world, database querries.

Bind: =Nothing= input gives =Nothing= output, =Just x= input uses =x= as input to the bound function.

When some computation results in Nothing -  drops the chain of computations and returns Nothing.

Zero: Nothing
Plus: result in first occurence of Just else Nothing.

Code:
#+begin_src haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
  return         = Just
  fail           = Nothing
  Nothing  >>= _ = Nothing
  (Just x) >>= f = f x

instance MonadPlus Maybe where
  mzero             = Nothing
  Nothing `mplus` x = x
  x `mplus` _       = x
#+end_src

Example:
Given 3 dictionaries:
 1. Full names to email addresses,
 2. Nicknames to email addresses,
 3. Email addresses to email preferences.

Create a function that finds a person's email preferences based on either a full name or a nickname.
#+begin_src haskell
data MailPref = HTML | Plain
data MailSystem = ...

getMailPrefs :: MailSystem -> String -> Maybe MailPref
getMailPrefs sys name =
  do let nameDB = fullNameDB sys
         nickDB = nickNameDB sys
         prefDB = prefsDB sys
  addr <- (lookup name nameDB) `mplus` (lookup name nickDB)
  lookup addr prefDB
#+end_src

******* <<<Either monad>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       6e6e76cd-71f0-4c01-8c1b-8cde9026a30a
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

When computation results in =Left -= drops other computations, returns the recieved =Left=.

******* <<<Error monad>>> :drill:
:PROPERTIES:
:ID:       860961d0-78d3-4fdd-9845-3e1a2b800cf7
:END:

Someting that can fail, throw exceptions.

Failure records failure description. Binding uses successful values as input to the bound function, and passes failure information on without executing the bound function.

Useful:
Composing functions that can fail. Handle exceptions, crate error handling structure.

Zero: empty error.
Plus: if first argument failed then execute second argument.

******* <<<List monad>>> :drill:
:PROPERTIES:
:ID:       1645e551-ef15-4415-9a40-8d4a7066ff0b
:END:

Computations which may return 0 or more possible results.

Bind: The bound function is applied to all possible values in the input list and the resulting lists are concatenated into list of all possible results.

Useful: Building computations from sequences of non-deterministic operations.

Zero: []
Plus: (++)

******** /*/
<<<[] monad>>>

******* <<<Reader monad>>> :drill:
:PROPERTIES:
:ID:       fff0059d-0484-41ee-b7c0-e91360c9ff62
:END:

Creates a read-only shared environment for computations.

The =pure= function ignores the environment, while >>= passes the inherited environment to both subcomputations.

#+begin_src haskell
type Reader r = ReaderT r Identity   -- equivalent to ((->) e), (e ->)
#+end_src

For =(e ->)=:
  * Functor is =(.)=
#+begin_src haskell
fmap :: (b -> c) -> (a -> b) -> a -> c
fmap = (.)
#+end_src
  * Applicative:
    * =pure= is =const=
#+begin_src haskell
pure :: a -> b -> a
pure x _ = x
#+end_src
    * =(<*>)= is:
#+begin_src haskell
(<*>) :: (a -> b -> c) -> (a -> b) -> a -> c
(<*>) f g = \a -> f a (g a)
#+end_src

  * Monad:
#+begin_src haskell
(>>=) :: (a -> b) -> (b -> a -> c) -> a -> c
(>>=) m k = Reader $ \r ->
                  runReader (k (runReader m r)) r

join :: (e -> e -> a) -> e -> a
join f x = f x x
#+end_src

#+begin_src haskell
runReader
  :: Reader r a  -- the Reader to run
  -> r  -- an initial environment
  -> a  -- extracted final value
#+end_src

Usage:
#+begin_src haskell
data Env = ...

createEnv :: IO Env
createEnv = ...

f :: Reader Env a
f = do
  a <- g
  pure a

g :: Reader Env a
g = do
  env <- ask  -- "Open the environment namespace into env"
  a <- h env  -- give env to h
  pure a

h :: Env -> a
...  -- use env and produce the result

main :: IO ()
main = do
  env <- createEnv
  a = runReader g env
  ...
#+end_src

In Haskell under normal circumstances impure functions should not directy call impure functions.
=h= is an impure function, and =createEnv= is impure function, so they should have intermediary.

******* <<<Writer monad>>> :drill:
:PROPERTIES:
:ID:       fe69112e-4524-4ff4-b100-ac229efe5849
:END:

Computations which accumulate monoid data to a shared Haskell storage.
So /*/ is parametrized by monoidal type.

Accumulator is maintained separately from the returned values.

Shared value modified through Writer monad methods.

/*/ frees creator and code from manually keeping the track of accumulation.

Bind: The bound function is applied to the input value, bound function allowed to =<>= to the accumulator.

#+begin_src haskell
type Writer r = WriterT r Identity
#+end_src

Example:
#+begin_src haskell
f :: Monoid b => a -> (a, b)
f a = if _condition_
         then runWriter $ g a
         else runWriter do
           a1 <- h a
           pure a1

g :: Monoid b => Writer b a
g a = do
  tell _value1_  -- accumulator <> _value1_
  pure a  -- observe that accumulator stored inside monad and only a main value needs to be returned

h :: Monoid b => Writer b a
h a = do
  tell _value2_  -- accumulator <> _value_
  pure a
#+end_src

#+begin_src haskell
runWriter :: Writer w a -> (a, w)  -- Unwrap a writer computation as a (result, accumulator) pair.
                                   -- The inverse of writer.
#+end_src

=WriterT=, =Writer= unnecessarily keeps the entire logs in the memory. Use =fast-logger= for logging.

******* <<<State monad>>>
:PROPERTIES:
:ID:       800e0e70-a69e-48e9-8592-426f5dd910cf
:END:

Computations that pass-over a state.

The bound function is applied to the input value to produce a state transition function which is applied to the input state.

Pure functional language cannot update values in place because it violates referential transparency.

#+begin_src haskell
type State s = StateT s Identity
#+end_src

Binding copies and transforms the state parameter through the sequence of the bound functions so that the same state storage is never used twice. Overall this gives the illusion of in-place update to the programmer and in the code, while in fact the autogenerated transition functions handle the state changes.

Example type: =State st a=

=State= describes functions that consume a state and produce a tuple of result and an updated state.

Monad manages the state with the next process:
#+DOWNLOADED: https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/State_Monad_Bind.svg/1162px-State_Monad_Bind.svg.png @ 2019-07-17 20:01:27
[[file:Book/1162px-State_Monad_Bind.svg_2019-07-17_20-01-27.png]]
Where:
  * f  - processsor making function
  * pA, pAB, pB - state processors
  * sN - states
  * vN - values
Bind with a processor making function from state procesor (pA) creates a new state processor (pAB).
The wrapping and unwrapping by State/runState is implicit.

***** <<<Alternative type class>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       b74a4135-6cc8-4944-9ba4-542b27c83dbe
:DRILL_LAST_INTERVAL: 10.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:50]
:END:

Monoid over applicative. Has left catch property.

Allows to run simolteniously several instances of a computation (or computations) and from them yeld one result by law from =(<|>) :: Type -> Type -> Type=.

Minimal complete definition:
#+begin_src haskell
empty :: f a    -- The identity element of <|>
(<|>) :: f a -> f a -> f a    -- Associative binary operation
#+end_src

****** /*/
<<<Alternative>>>

**** <<<Monoidal functor>>> :drill:
:PROPERTIES:
:ID:       8bafa7f0-72b2-4706-a623-69c5f09ab964
:END:

Functors between monoidal categories that preserves monoidal structure.

**** <<<Fusion>>> :drill:
:PROPERTIES:
:ID:       401d4ba1-4405-4ca7-a96c-c8fe8d22c3bf
:END:

#+begin_src haskell
fmap f . fmap g = fmap (f . g)
#+end_src

This functor axiom allows to greatly simplify computations, it is called /*/.

*** <<<Hask category>>>

Category of Haskell where objects are types and morphisms are functions.

It is a hypothetical category at the moment, since undefined and bottom values break the theory, is not Cartesian closed, it does not have sums, products, or initial object, () is not a terminal object, monad identities fail for almost all instances of the Monad class.

That is why Haskell developers think in subset of Haskell where types do not have bottom values. This only includes functions that terminate, and typically only finite values. The corresponding category has the expected initial and terminal objects, sums and products, and instances of Functor and Monad really are endofunctors and monads.

Hask contains subcategories, like Lst containing only list types.

Haskell and Category concepts:
  * Things that take a type and return another type are type constructors.
  * Things that take a function and return another function are higher-order functions.

**** /*/
<<<Hask>>>

*** <<<Magma>>> :drill:
:PROPERTIES:
:ID:       c40ac83b-c730-4de5-915d-04d76c88398c
:END:

Set with a binary operation which form a closure.

**** <<<Mag category>>>
The category of magmas, denoted $$ Mag $$, has as objects - sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).

***** /*/
<<<MAG>>>
<<<Magma category>>>
<<<Category of magmas>>>

**** <<<Semigroup>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       7e67196b-643c-4726-8a17-6207826764bb
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:38]
:END:

Magma with associative property.

Defined in Haskell as:
#+begin_src haskell
class Semigroup a where
(<>) :: a -> a -> a
#+end_src

***** /*/
<<<Semigroups>>>

***** <<<Monoid>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       6593c8fb-adda-488b-b86f-9544f62868eb
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:03]
:END:

Semigroup with Identity element.

Ideally fits as an accumulation class.

#+begin_src haskell
class Monoid m where
mempty :: m
mappend :: m -> m -> m
mappend = (<>)
mconcat :: [m] -> m
mconcat = foldr mappend mempty
#+end_src

/*/ can be simplified to category with a single object, remember that monoid operation is a composition of morphisms operation in category.
For example to represent the whole non-negative integers with the one object and morphism "$$ 1 $$" is absolutely enough, composition operation is "$$ + $$".

#+begin_src haskell
import Data.Monoid
do
  show (mempty :: Num a => Sum a)
  -- "Sum {getSum = 0}"
  show $ Sum 1
  -- "Sum {getSum = 1}"
  show $ (Sum 1) <> (Sum 1) <> (Sum 1)
  -- "Sum {getSum = 3}"
  -- ...
#+end_src

Also backwards - any single-object category is a monoid. Category has an identity requirement and associativity of composition requirement, which makes it a free monoid. 

****** /*/
<<<Monoidal>>>
<<<Monoids>>>

****** <<<Monoid laws>>> :drill:
:PROPERTIES:
:ID:       031cdf43-093d-4959-ac8b-f3e2ad35e7db
:END:

******* <<<Monoid left identity law>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       ab71d331-f6f3-4edc-b734-c05c2df9630a
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:54]
:END:

#+begin_src haskell
mempty <> x = x
#+end_src

******* <<<Monoid right identity law>>> :drill:
:PROPERTIES:
:ID:       d048e3ea-ef53-4e33-ae78-88a60a07bacb
:END:

#+begin_src haskell
x <> mempty = x
#+end_src

******* <<<Monoid associativity law>>> :drill:
:PROPERTIES:
:ID:       bd721cde-f8be-45a8-b098-6085d5254e2b
:END:

#+begin_src haskell
x <> mempty = x (y <> z) = (x <> y) <> z
mconcat = foldr (mempty <>)
#+end_src

Everything associative can be =mappend=.

****** <<<Commutative monoid>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       ece84bf0-fff2-4bda-968c-473c7d7c959e
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:03]
:END:

Commutative law:
$$ x \circ y = y \circ x $$
Very helpful at concurrent or distributed processing.

Enables a lot of abilities and concurrency in monoidal structures.

******* /*/
<<<Abelian monoid>>>

****** <<<Group>>> :drill:
:PROPERTIES:
:ID:       95a42c18-683b-4489-a2e9-e891e3fd9958
:END:

Monoid with inverse for every element (element operation with inverse gives identity)

******* /*/
<<<Groups>>>

******* <<<Commutative group>>>
Group operation obeys the axiom of commutativity.

******** /*/
<<<Abelian group>>>

******** <<<Ring>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       437c3602-cfc2-4cd1-bdba-be9e0db9c8f8
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:05]
:END:

Commutative group under + & monoid under \times, + \times connected by distributive property.

+ and \times are generalized binary operations of addition and multiplication. \times has no requirement for commutativity.

Example: set of same size square matricies of numbers with matrix operations form a ring.

********* /*/
<<<Rings>>>

*** <<<Morphism>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       8d0a8700-c48a-4195-8bd2-52a1b3866d76
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:03]
:END:

μορφή /morphe/ form
Map between two objects in a category.

General description: Arrow from one to enother that denotes something.

On a level of objects: morphism is some maybe structure-preserving map from one mathematical structure to another one of the same type.

Morphism is a generalization ($$ f(x*y) \equiv f(x) \diamond f(y) $$) of homomorphism ($$ f(x*y) \equiv f(x) * f(y) $$).
Under morphism almost always is meaning of homomorphism-like properties.

If morphism corresponds to function requirements - than it is a function. Morphism can be anything.

**** /*/
<<<Morphisms>>>
<<<Arrow>>>
<<<Arrows>>>

**** <<<Homomorphism>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       f2e565b1-80d9-4d83-96c7-ba3e17440b75
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

ὁμός /homos/ same (was chosen becouse of initial Anglish mistranslation to "similar")
μορφή /morphe/ form
similar form

Homomorphism - operation-preserving map between two algebraic structures of the same type (groups, rings, vector spaces...).

$$  f^{A \to B}_{homomorphism} = f(x \star y) = f(x) \diamond f(y) | (A_{set}, \star_{operation}), (B_{set}, \diamond_{operation}) $$.

The concept of homomorphism has been generalized under the name of morphism to many other structures that either do not have an underlying set, or are not algebraic.

Homomorphisms send identity morphisms to identity morphisms and inverses to inverses.

=*= homomorphism - map between =*= and preserves =*= operations
  case =*= of:
  * semigroup
  * monoid
  * groups
  * ring
  * linear map
  * module
  * algebra

***** /*/
<<<Homomorphic>>>

**** <<<Identity morphism>>> :drill:
:PROPERTIES:
:ID:       8581e216-8d9d-479f-a58d-bd04882b5131
:END:

Identity morphism - or simply identity: $$ x \in C : \; id_{x}=1_{x} : x \to x $$
Composed with other morphism gives same morphism.

Corresponds to Reflexivity and Automorphism.

***** <<<Identity>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       ed19af1f-09b7-43a0-82d2-ab30e198ae54
:DRILL_LAST_INTERVAL: 9.648
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:42]
:END:

Identity only possible with morphism. See Identity morphism.

There is also distinct Zero value.

****** <<<Two-sided identity of a predicate>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       6f4649d2-e99e-4424-b575-0c2121a7569c
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

$$ P(e,a)=P(a,e)=a \ | \ \exists e \in S, \forall a \in S $$
$$ P() $$ is commutative.

Predicate

****** <<<Left identity of a predicate>>> :drill:
:PROPERTIES:
:ID:       1f08ecdc-8177-4f95-98c6-0c8858c54bf0
:END:

$$ \exists e \in S, \forall a \in S : \; P(e,a)=a $$

Predicate

****** <<<Right identity of a predicate>>> :drill:
SCHT: <2019-08-05 Mon>
:PROPERTIES:
:ID:       3ed093c4-db04-4e82-91b4-b01398b39e84
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:16]
:END:

$$  P(a,e)=a \; | \; \exists e \in S, \forall a \in S $$

Predicate

***** <<<Identity function>>> :drill:
:PROPERTIES:
:ID:       c687793c-ad12-435b-8326-9c335ebbf9ea
:END:

Return itself.
(\ x.x)
#+begin_src haskell
id :: a -> a
#+end_src

**** <<<Monomorphism>>> :drill:
:PROPERTIES:
:ID:       18290d34-893c-42f0-bf4a-bb31f5e97711
:END:

μονο /mono/ only
μορφή /morphe/ form

Initial set of /f/ is fully uniquely mapped onto the image of /f/.
Left is mono (uniquely) mapped to the right, so left domain can be equal or less to the right codomain.
It is injective.
It always has a inverse morphism.

$$ f^{X \to Y}, \forall x \in X \, \exists y=f(x) \vDash f(x) = f_{mono}(x) $$ - from homomorphism context
$$ f_{mono} \circ g1 \equiv f_{mono} \circ g2 \vDash \; g1 \equiv g2 $$ - from general morphism context
Thus it is left canselable.

***** /*/
<<<Monomorphic>>>

**** <<<Epimorphism>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       3729d963-3775-4715-99d7-d14bc30750c0
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:43]
:END:

επι /epi/ on, over
μορφή /morphe/ form

Image fully uses codomain - epimorphism.
It is surjective.

$$ f^{X \to Y}, \forall y \in Y \, \exists f(x) \vDash f(x)=f_{epi}(x) $$ - from homomorphism context
$$ g_1 \circ f_{epi} \equiv g_2 \circ f_{epi} \vDash \; g_1 = g_2 $$ - from general morphism context
Thus epimorphism is right canselable.

Left is epi to the right. So left is bigger or equal then the right. And right is a projection of the left.

***** /*/
<<<Epimorphic>>>

**** <<<Isomorphism>>> :drill:
:PROPERTIES:
:ID:       4a0635c3-9512-443a-8497-3c259032de55
:END:

ἴσος /isos/ equal
μορφή /morphe/ form

Not equal, but equal for current intents and purposes.
Morphism that has inverse.
Almost equal, but not quite: =(Integer, Bool)= & =(Bool, Integer)= - but can be transformed losslessly into one another.

Bijective homomorphism is also isomorphism.

$$ f^{-1, b \to a} \circ f^{a \to b} \equiv id^a, \; f^{a \to b} \circ f^{-1, b \to a} \equiv id^b $$

2 reasons for non-isomorphism:
  * function at least ones collapses a values of domain into one value in codomain
  * image (of a function in codomain) does not fill-in codomain. Then isomorphism can exists for image but not whole codomain.

Categories are isomorphic if there $$ R ∘ L = ID

***** /*/
<<<Isomorphic>>>

**** <<<Endomorphism>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       2fd058e4-4b8a-451e-9760-0275b2741331
:DRILL_LAST_INTERVAL: 9.1096
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:03]
:END:

ενδο /endo/ internal
μορφή /morphe/ form

Morphism whose domain equals the codomain.
Epimorphism is a Monoid, because of category composition.

***** <<<Automorphism>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       fc880a3b-0339-4a6f-bffc-5d6c4c4eb1ae
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:05]
:END:

\alpha\upsilon\tau\omicron /auto/ self
μορφή /form/ form

Endomorphism that is Isomorphism.

Corresponds to Identity and Reflexivity.

****** /*/
<<<Automorphic>>>

***** /*/
<<<Endomorphic>>>

**** <<<Catamorphism>>> :drill:
:PROPERTIES:
:ID:       3af3d5fd-449a-45e7-ac99-0cca150f0523
:END:

κατά /kata/ downward
μορφή /morphe/ form

Denotes the unique homomorphism from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.

***** /*/
<<<Catamorphic>>>

**** <<<Kernel>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       44aee181-f629-4047-abf5-f2ae438f2063
:DRILL_LAST_INTERVAL: 24.12
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 13:08]
:END:

Kernel of a homomorphism is a number that measures the degree homomorphism fails to meet injectivity (AKA be monomorphic).
It is a number of domain elements that fail injectivity:
  * elements not included into morphism
  * elements that collapse into one element in codomain
thou Kernel $$ [ x | x \leftarrow 0 || x \ge 2 ] $$.

Denotation:
$$ \operatorname{ker}T = \{ \mathbf{v} \in V:T(\mathbf{v}) = \mathbf{0}_{W} \} $$.

***** <<<Kernel homomorphism>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       e77c8ade-6668-48e3-aeae-3bf1209e31d8
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:05]
:END:

Morphism of elements from the kernel. Map of elements that make main morphism not monomorphic (injective).

**** <<<Anamorphism>>> :drill:
:PROPERTIES:
:ID:       731c7b76-f46b-478f-87c0-4c24cb3f8c5c
:END:

Morphism from a coalgebra to the final coalgebra for that endofunctor.
Is a function that generates a sequence by repeated application of the function to its previous result.

*** <<<Object>>>
Mathematical structure. Morphisms preserve structure.

**** /*/
<<<Structure>>>
<<<Structures>>>
<<<Objects>>>

**** <<<Terminal object>>> :drill:
:PROPERTIES:
:ID:       8d7de2b2-7609-481a-837e-9887e779446f
:END:

Terminal object - is an object i: $$ \exists ! (x \to i) \ | \ \exists i \in \mathcal{C} , \; \forall x \in \mathcal{C} $$.

**** <<<Initial object>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       8d962644-6fcd-4152-b82a-fabb9ed38f6b
:DRILL_LAST_INTERVAL: 8.7892
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 12:55]
:END:

Initial object - is an object i: $$ \exists ! (i \to x) \ | \ \exists i \in \mathcal{C}, \ \forall x \in \mathcal{C} $$.

*** <<<Set category>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       c6c7f178-7b69-4154-83ed-34de9b102193
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:07]
:END:

Category in which objects are sets.

*** <<<Natural transformation>>> :drill:
:PROPERTIES:
:ID:       8591d1eb-0f0f-4f0e-b46b-05a4262646da
:END:

/*/ ($$ \overrightarrow{\eta}^{\mathcal{D}} $$) is transforming : $$ \overrightarrow{\eta}^{\mathcal{D}} \circ F^{\mathcal{C \to D}} = G^{\mathcal{C \to D}} $$. Right there was seen that /*/ allows higher-language of Category theory, talking about the composition and transformation of complex theory entities.

Roughly /*/ is:
#+begin_src haskell
trans :: F a -> G a
#+end_src

It is a process of transforming $$ F^{\mathcal{C \to D}} $$ into $$ G^{\mathcal{C \to D}} $$ using existing morphisms in target category $$ \mathcal{D} $$.

Since it uses morphisms - it is structure-preserving transformation of one functor into another. And since it uses only existing morphisms - it exists only when transformation is possible with existing morphisms.

Existence of /*/ between two functors means they are somehow related.

Can be observed to be a "morphism of functors", especially in functor category.
/*/ by $$ \overrightarrow{\eta}^{\mathcal{D}}_{y^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \circ F^{\mathcal{C \to D}}(\overrightarrow{(x,y)}^{\mathcal{C}}) = G^{\mathcal{C \to D}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \circ \overrightarrow{\eta}^{\mathcal{D}}_{x^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) $$, often written short $$ \overrightarrow{\eta}_{b} \circ F(\overrightarrow{f}) = G({\overrightarrow{f}) \circ \overrightarrow{\eta}_{a} $$.
Notice that the $$ \overrightarrow{\eta}^{\mathcal{D}}_{x^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) $$ depends on objects&morphisms of $$ \mathcal{C} $$.

In words, /*/ depends on $$ F $$ and $$ G $$ functors, ability of $$ D $$ morphisms to do a homotopy of $$ F $$ to $$ G $$, and /*/:
  * for every object in $$ \mathcal{C} $$ picks natural transformation component in $$ \mathcal{D} $$.
  * for every morphism in $$ \mathcal{C} $$ picks the commuting diagram in $$ \mathcal{D} $$, called <<<naturality square>>>. 

Also see: Natural transformation in Haskell

**** /*/
<<<Natural transformations>>>

**** <<<Natural transformation component>>> :drill:
:PROPERTIES:
:ID:       d71f0216-0581-481b-a941-7974ec27ee2c
:END:

$$ \overrightarrow{\eta}^{\mathcal{D}}(x) = F^{\mathcal{D}}(x) \to G^{\mathcal{D}}(x) \ | \  x \in \mathcal{C} $$

***** /*/
<<<Component of natural transformation>>>

**** <<<Natural transformation in Haskell>>>

/*/ is a family of morphisms parametrized by type (parametric polymorphism functions) between endofunctors (Functor, Applicative, Monad).

/*/ in Hask is $$ F \ a \to G \ a $$ - repackages data into another container, never modifies the object content, it only if - can delete it. If other - that can not be called a /*/.

*** <<<Hom set>>>
:PROPERTIES:
:ID:       ee713d7a-4b83-4e75-8338-5a3b69da24a9
:END:

Collection of all morphisms $$ hom^{\mathcal{C}}(a,b) \ | \ \forall ( a \to b ) \in \mathcal{C} $$.

*** <<<Category dual>>>

Category duality behaves like a logical inverse.

Inverse $$ \mathcal{C} $$ = $$ \mathcal{C}^{op} $$ - invert the direction of morphisms.

(Morphisms include all their compositions)

Any statement in the terms of $$ \mathcal{C} $$ the logical inverse is true in $$ \mathcal {C}^{op} $$.

Properties:
  * Opposite preserves products: $$ (\mathcal{C} \times \mathcal{D})^{op} \cong \mathcal{C}^{op} \times \mathcal{D}^{op} $$

  * Opposite preserves functors: $$ (F^{\mathcal{C} \to \mathcal{D}})^{op} \cong F^{\mathcal{C}^{op} \to \mathcal{D}^{op}} $$

  * Opposite preserves slices: $$ (\mathcal{F} \downarrow \mathcal{G})^{op} \cong (\mathcal{G}^{op} \downarrow \mathcal{F}^{op}) $$

****** /*/
<<<Opposite category>>>
<<<Opposite categories>>>
<<<Category duality>>>
<<<Duality>>>
<<<Dual category>>>

** <<<Closure>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       c20b75e8-cd85-4f41-84c2-660ffdb963dd
:DRILL_LAST_INTERVAL: 25.88
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:09]
:END:

$$ f(x) = f^{\mathcal{X \to X}} \ | \ \forall x \in \mathcal{X} $$, $$ \mathcal{X} $$ is closed under $$ f $$, it is a trivial case when operation is legitimate for all values of the domain.

Operation on members of the domain always produces a members of the domain. The domain is closed under the operation.

In the case when there is a domain values for which operation is not legitimate/not exists:

$$ f(x) = f^{\mathcal{V \to X}} \ | \ \mathcal{V \in X}, \forall x \in \mathcal{V} $$, $$ \mathcal{X} $$ is closed under $$ f $$.

*** /*/
<<<Closed>>>

** <<<Coalgebra>>> :drill:
:PROPERTIES:
:ID:       a48247a2-f844-4c4e-9f40-e8cac61bb209
:END:

Structures that are dual (in the category-theoretic sense of reversing arrows) to unital associative algebras.
Every coalgebra, by vector space duality, reversing arrows - gives rise to an algebra. In finite dimensions, this duality goes in both directions. In infinite - it should be determined.

** <<<Concatenate>>> :drill:
:PROPERTIES:
:ID:       fd27911c-bf33-4510-91ff-afa1d4e7d2e1
:END:

Link together sequences.

** <<<Conjunction>>> :drill:
SCHT: <2019-07-26 Fri>
:PROPERTIES:
:ID:       3f47a5a4-aa8a-43a5-a834-b16f02ee343d
:DRILL_LAST_INTERVAL: 25.9732
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:24]
:END:

Logical AND

Multiplies cardinalities.

Haskell kind:
#+begin_src haskell
 * *
#+end_src

** <<<Constructor>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       73f88452-54ff-4192-83fc-0681f0407e9a
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 12:39]
:END:

1. Type constructor
2. Data constructor

Also see: Constant

** <<<Context>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       c7212fc4-2c44-4cc0-b57a-76e9ba194ac3
:DRILL_LAST_INTERVAL: 10.7143
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:54]
:END:

Constraint placed on the types under polymorphic variables.
Written before the main type signature and denoted:
#+begin_src haskell
TypeClass a =>
#+end_src

*** /*/
<<<Contexts>>>

** <<<Contravariant>>> :drill:
:PROPERTIES:
:ID:       d1f3dc34-f7b9-4284-b417-16b26860248a
:END:

The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis inverse-proportional for the description of a Tensors in this basisis.

Denotation:
Components for contravariant basis denoted in the upper indices:
$$ V^{i} = x $$

The inverse of a covariant transformation is a contravariant transformation. Whenever a vector should be invariant under a change of basis, that is to say it should represent the same geometrical or physical object having the same magnitude and direction as before, its components must transform according to the contravariant rule.

*** /*/
<<<Contravariant cofunctor>>>
<<<Contravariant functor>>> - More inline term is Contravariant cofunctor

** <<<Covariant>>> :drill:
:PROPERTIES:
:ID:       90eb2e6f-8695-446f-a7e8-ccac7f47dbee
:END:

The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis proportional for a descriptions of Tensors in this basisis.

Denotation:
Components for covariant basis denoted in the upper indices:
$$ V_{i} = x $$

*** /*/
<<<Covariant functor>>>
<<<Covariant cofunctor>>>

** <<<Data type>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       1da15965-03f0-4cf9-a582-3df5c4deb27e
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:25]
:END:

Set of values.
For type to have sence the values share some sence, properties.

*** /*/
<<<Type>>>
<<<Types>>>
<<<Data types>>>

*** <<<Actual type>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       1325dd6d-8944-4226-a703-e5e7ecb90838
:DRILL_LAST_INTERVAL: 22.2548
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:46]
:END:

Data type recieved by ->inferring->compiling->execution.

*** <<<Algebraic data type>>> :drill:
:PROPERTIES:
:ID:       3c1de247-a95a-4cb3-ba2d-476bd69f263a
:END:

Composite type formed by combining other types.

**** /*/
<<<AlgDT>>>

*** <<<Cardinality>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       22428179-0fdb-4723-94dc-596dd41f61c0
:DRILL_LAST_INTERVAL: 25.88
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:12]
:END:

Number of possible implementations for a given type signature.

Disjunction, sum - adds cardinalities.
Conjunction, product - multiplies cardinalities.

*** <<<Data constant>>> :drill:
:PROPERTIES:
:ID:       c6fd80d7-4f2b-4c0e-a924-db0616cd126d
:END:

/*/ - constant value; nullary data constructor.

*** <<<Data constructor>>> :drill:
:PROPERTIES:
:ID:       dc94bd99-113e-4025-82e8-39cd6843091b
:END:

One instance that inhabit data type.

*** <<<data declaration>>> :drill:
:PROPERTIES:
:ID:       4c0b5dd7-d8e2-4394-9a38-e99bd7961130
:END:

Data type declaration is the most general and versatile form to create a new data type.
Form:
#+begin_src haskell
data [context =>] type typeVars1..n
  = con1  c1t1..i
  | ...
  | conm  cmt1..q
  [deriving]
#+end_src

*** <<<Dependent type>>> :drill:
:PROPERTIES:
:ID:       f40f1feb-3a1d-4987-b585-6d8d6080d307
:END:

When type and values have relation between them. Type has restrictions for values, value of a type variable has a result on the type.

**** /*/
<<<Dependent types>>>

*** <<<Gen type>>> :drill:
SCHT: <2019-08-08 Thu>
:PROPERTIES:
:ID:       a4d8e374-a99a-4d9a-b159-13b004c2b3ed
:DRILL_LAST_INTERVAL: 26.774
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

Generator. Gen type is to generate pseudo-random values for parent type. Produces a list of values that gets infinitely cycled.

*** <<<Higher-kinded data type>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       f923ff3e-43bb-4e4a-8c55-e4f2354e3810
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:06]
:END:

Any combination of * and ->

Type that take more types as arguments.

**** /*/
<<<Higher-kinded data types>>>

*** <<<newtype declaration>>> :drill:
SCHT: <2019-08-04 Sun>
:PROPERTIES:
:ID:       f9bbca43-6672-48e8-8d1c-af323786efc2
:DRILL_LAST_INTERVAL: 23.1978
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:45]
:END:

Creates a new type from old type using a new constructor.
#+begin_src haskell
newtype FirstName = FirstName String
#+end_src

Data will have exactly the same representation at runtime, as the type that is wrapped.

#+begin_src haskell
newtype Book = Book (Int, Int)
#+end_src
#+begin_src text
      (,)
      / \
Integer Integer
#+end_src

*** <<<Principal type>>> :drill:
SCHT: <2019-08-14 Wed>
:PROPERTIES:
:ID:       55ec2cac-10dc-4a09-a795-4e99c7e5aaed
:DRILL_LAST_INTERVAL: 27.7458
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:36]
:END:

The most generic data type that still typechecks.

*** <<<Product data type>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       dcca9aba-08e0-4616-8bec-b803bf67f066
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

Algebraic data type formed by logical conjunction (AND ' ').

*** <<<Proxy type>>> :drill:
:PROPERTIES:
:ID:       a895477f-99de-4a09-bc9d-dc2c86e0a0af
:END:

Proxy type holds no data, but has a phantom parameter of arbitrary type (or even kind). Able to provide type information, even though has no value of that type (or it can be may too costly to create one).
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- a has kind `Type`
let proxy2 = (ProxyValue :: Proxy List) -- a has kind `Type -> Type`
#+end_src

*** <<<Static typing>>> :drill:
:PROPERTIES:
:ID:       3100b260-2b5c-40a7-bc27-2dc6e0f8f3c5
:END:

Static typechecking occurs at compile level.

*** <<<Structural type>>> :drill:
:PROPERTIES:
:ID:       9fbc8692-d766-4b0b-bb07-76cb11b9aea8
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:24]
:END:

Mathematical type. They form into structural type system.

**** /*/
<<<Structural>>>

*** <<<Structural type system>>> :drill:
:PROPERTIES:
:ID:       37dc5166-6ad1-468d-a3c2-d4144ac5bb83
:END:

Strict global hierarchy and relationships of types and their properties.
Haskell type system is /*/.
In most languages typing is name-based, not structural.

**** /*/
<<<Structural typing>>>

*** <<<Sum data type>>> :drill:
:PROPERTIES:
:ID:       debb1f7b-bdbf-4984-8d92-ee34b63dd5dc
:END:

Algebraic data type formed by logical disjunction (OR '|').

*** <<<Tuple>>> :drill:
:PROPERTIES:
:ID:       fd6d5368-51bc-4577-a4e3-97b62b7a4442
:END:

Data type that stores multiple values withing a single value.
Tuples by arity:
  * empty, unit          - 0
  * pair, <<<two-tuples>>>     - 2
  * <<<thriple>>>, three-tuple - 3

*** <<<Type alias>>> :drill:
SCHT: <2019-09-11 Wed>
:PROPERTIES:
:ID:       35a84a4d-afa8-44b1-aaf4-8fa258f5220c
:DRILL_LAST_INTERVAL: 48.4944
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:58]
:END:

Create new type constructor, and use all data structure of the base type.

*** <<<Type class>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       41fe6fb3-8069-40d4-ac21-1e2995e652be
:DRILL_LAST_INTERVAL: 29.8462
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:15]
:END:

Type system construct that adds a support of ad hoc polymorphism.

Type classes make a nice way for defining behaviour over many objects at once.

**** /*/
<<<Type classes>>>
<<<Typeclass>>>
<<<Typeclasses>>>

**** <<<Arbitrary type class>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       1bda8aab-a08c-4d7b-bd08-0b1a6f559a33
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:55]
:END:

Type class of QuickCheck.Arbitrary (that is reexported by QuickCheck) for creating a generator/distribution of values.
Useful function is arbitrary - that autogenerates values.

***** <<<Arbitrary function>>> :drill:
:PROPERTIES:
:ID:       31fe10b3-340e-489a-ab65-a4532a005d0a
:END:

Depends on type and generates values of that type.

**** <<<CoArbitrary type class>>> :drill:
:PROPERTIES:
:ID:       a8ad8f53-2ad9-414d-8c6b-8df9d0cac80e
:END:

Pseudogenerates a function basing on resulting type.
#+begin_src haskell
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
#+end_src

***** /*/
<<<CoArbitrary>>>

**** <<<Type class inheritance>>> :drill:
:PROPERTIES:
:ID:       d41bdd5c-5a64-4ab8-8201-8c9ae3437a61
:END:

Type class has a superclass.

**** <<<Derived instance>>> :drill:
SCHT: <2019-08-10 Sat>
:PROPERTIES:
:ID:       7294eaf7-4ff8-41c8-a6a9-c9060b5edfb9
:DRILL_LAST_INTERVAL: 28.9659
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:54]
:END:

Type class instances sometimes can be automatically derived from the parent types.

Type classes such as Eq, Enum, Ord, Show can have instances generated based on definition of data type.

***** /*/
<<<Derived>>>
<<<Deriving>>>

*** <<<Type constant>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       06ae5a19-fd5f-485c-b7da-c3027c76d523
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

/*/ - Nullary type constructor.

*** <<<Type constructor>>> :drill:
:PROPERTIES:
:ID:       9b49b7ac-d596-45c5-a551-cf2f9b3d6cb3
:END:

Name of data type.


*** <<<type declaration>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       9ab3591b-b3b1-464c-856b-0e3ed4834b33
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:55]
:END:

Synonim for existing type. Uses the same data constructor.
#+begin_src haskell
type FirstName = String
#+end_src
Used to distinct one entities from other entities, while they have the same type.
Also main type functions can operate on a new type.

*** <<<Typed hole>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       54480f81-42f0-4545-bfa6-93e56eba36ae
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:24]
:END:

In GHC if to use placeholder =_= or =_name=, GHC on evaluation of the hole would supply derived type information and information to help fill the gap.

**** /*/
<<<Typed holes>>>

*** <<<Type inference>>> :drill:
:PROPERTIES:
:ID:       6e24ecce-be5d-4fcc-b167-649f710d1be8
:END:

Automatic data type detection of expression.

**** /*/
<<<Inferring>>>
<<<Infer>>>
<<<Infers>>>
<<<Inferred>>>

*** <<<Type class instance>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       2408c5a2-39ba-4732-a4b2-347e87c268d6
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:45]
:END:

Unique type class->type pairing implementation of functions.

*** <<<Type rank>>> :drill:
:PROPERTIES:
:ID:       512cf517-eacf-4d39-9d7c-8ec840d9a384
:END:

Weak ordering of types.

The rank of polymorphic type shows at what level of nesting =forall= quantifier appears.
Count-in only quantifiers that appear to the left of arrows.
#+begin_src haskell
f1 :: forall a b. a -> b -> a    ==    fi :: a -> b -> c
g1 :: forall a b. (Ord a, Eq b) => a -> b -> a    ==    g1 :: (Ord a, Eq b) => a -> b -> a
#+end_src
f1, g1 - rank-1 types. Haskell itself implicitly adds universal quantification.

#+begin_src haskell
f2 :: (forall a. a->a) -> Int -> Int
g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int
#+end_src
f2, g2 - rank-2 types. Quantificator is on the left side of a \to. Quantificator shows that type on the left can be overloaded.

#+begin_src haskell
f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool
#+end_src
f3 - rannk3-type. Has rank-2 types on the left of a \to.

#+begin_src haskell
f :: Int -> (forall a. a -> a)
g :: Int -> Ord a => a -> a
#+end_src
f, g are rank 1. Quantifier appears to the right of an arrow, not to the left. These types are not Haskell-98. They are supported in RankNTypes.

Type inference in Rank-2 is possible, but not higher.

**** /*/
<<<Type ranks>>>
<<<Rank type>>>
<<<Rank types>>
<<<Rank-1 type>>>
<<<Rank-1 types>>>
<<<Rank-2 type>>>
<<<Rank-2 types>>>
<<<Rank-3 type>>>
<<<Rank-3 types>>>

*** <<<Type variable>>> :drill:
:PROPERTIES:
:ID:       6f31712e-d46b-4474-bd68-6b3bc2c90309
:END:

Refer to an unspecified type in Haskell type signature.

*** <<<Unlifted type>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       071c758f-9a93-4769-a7f0-aaa02652e57f
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:END:

Type that directly exist on the hardware. The type abstraction can be completely removed.
With unlifted types Haskel type system directly manages data in the hardware.

**** /*/
<<<Unlifted types>>>

*** <<<Data structure>>> :drill:
:PROPERTIES:
:ID:       34418701-bc96-4c96-ab01-c59ec2ee5741
:END:

**** <<<Cons cell>>> :drill:
:PROPERTIES:
:ID:       db0f5189-b0a4-4554-af3d-dae7145516c5
:END:

Cell that values may inhabit.

**** <<<Construct>>> :drill:
:PROPERTIES:
:ID:       09d6089a-5e26-4a2a-b805-23941be3e63e
:END:

#+begin_src haskell
(:) :: a -> [a] -> [a]
#+end_src

***** /*/
<<<Cons>>>

**** <<<Leaf>>> :drill:
:PROPERTIES:
:ID:       8ca6b84c-9c42-4f2c-948e-39a94246ad14
:END:

 _

**** <<<Node>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       44946197-24dd-48fd-810c-6af851f6a0cf
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:11]
:END:

#+begin_src text
 *
/ \
#+end_src

*** <<<Linear type>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       eda588af-3ef5-43a8-8f06-6a6f2f556036
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

Type system and algebra that also track the multiplicity of data.
There are 3 general linear type groups:
 * 0 - exists only at type level and is not allowed to be used at value level. Aka `s` in ST-Trick.
 * 1 - data that is not duplicated
 * 1< - all other data, that can be duplicated multiple times.

**** /*/
<<<Linear types>>>

*** <<<NonEmpty list data type>>> :drill:
:PROPERTIES:
:ID:       809c682b-457e-47df-bdfd-92302d3c42da
:END:

Data.List.NonEmpty
Has a Semigroup instance but can't have a Monoid instance. It never can be an empty list.

#+begin_src haskell
data NonEmpty a = a :| [a]
  deriving (Eq, Ord, Show)
#+end_src

:| - an infix data costructor that takes two (type) arguments. In other words :| returns a product type of left and right

*** <<<Session type>>> :drill:
:PROPERTIES:
:ID:       4554aa14-760c-41f0-a9fc-69cc3f7fa66a
:END:

/*/ - allows to check that behaviour conforms to the protocol.

So far very complex not very productive (& well-established) topic.
** <<<Declaration>>> :drill:
SCHT: <2019-07-25 Thu>
:PROPERTIES:
:ID:       461111ea-4124-427f-bfc6-f83212a07951
:DRILL_LAST_INTERVAL: 25.0
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:48]
:END:

Binding the name to expression.

** <<<Differential operator>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       1ffad9d0-5207-422f-b979-8118bbcba152
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

Denotation.
$$ \frac{d}{dx}, \, D, \, D_{x}, \, \partial_{x}. $$
Last one is partial.

$$ e^{t{\frac{d}{dx}}} $$ - Shift operator.

*** /*/
<<<Differential>>>

** <<<Disjunction>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       beba897a-84ca-42c9-a094-ba48487c587b
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:45]
:END:

OR

** <<<Dispatch>>> :drill:
:PROPERTIES:
:ID:       aba69f2c-bd70-46eb-9cd3-a215fdd37737
:END:

Send, transmission, reference.

** <<<Distributive axiom>>> :drill:
:PROPERTIES:
:ID:       6ea04559-091b-4151-b190-e97a88bb317a
:END:

Set S and two binary operators + \times:

  * $$ x \times (y + z) = (x \times y) + (x \times z) $$ - \times is left-distributive over +
  * $$ (y + z) \times x = (y \times x) + (z \times x) $$ - \times is right-distributive over +
  * left-&right-distributive - \times is distributive over +

*** /*/
<<<Distributive rule>>>
<<<Distributive property>>>
<<<Distributive law>>>
<<<Distributive>>>

** <<<Dynamic scope>>> :drill:
:PROPERTIES:
:ID:       477d92da-63ca-4929-b54c-aa16f6d2c71e
:END:

The name resolution depends upon the program state when the name is encountered, which is determined by the execution context or calling context.

** <<<Effect>>> :drill:
:PROPERTIES:
:ID:       3168c887-3120-40d8-ba68-2d25bae7f37f
:END:

Observable action.

** <<<Evaluation>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       1b2053a3-24c8-47fe-a3a0-3974c6a3472a
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:07]
:END:

For FP see Bind.

** <<<Expected type>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       925824e3-ed7f-4e2f-ab3a-dd4700b0291c
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 12:55]
:END:

Data type inferred from the text of the code.

** <<<Expression>>> :drill:
:PROPERTIES:
:ID:       6ff3b474-8f28-4eb9-975a-312d37521cc6
:END:

Finite combination of a symbols that is well-formed according to rules that depend on the context.

*** /*/
<<<Expressions>>>

*** <<<Closed-form expression>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       4fe26c88-61dc-4a5c-b31e-aa91d5a9afd0
:DRILL_LAST_INTERVAL: 9.43
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

Closed-form expression - a mathematical expression that can be evaluated in a finite number of operations. It may contain constants, variables, certain "well-known" operations (e.g., + − × ÷), and functions (e.g., nth root, exponent, logarithm, trigonometric functions, and inverse hyperbolic functions), but usually no limit.

*** <<<RHS>>> :drill:
:PROPERTIES:
:ID:       8638f0a1-1228-4196-b7f3-0c5db5c13028
:END:

Right-hand side of the expression.

*** <<<LHS>>> :drill:
:PROPERTIES:
:ID:       060e0611-e893-46f5-b133-c020738fdf96
:END:

Left-hand side of the expression.

*** <<<Redex>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       3d5326a4-74a7-433d-860a-2590072bb61d
:DRILL_LAST_INTERVAL: 28.7036
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:09]
:END:

Reducible expression.

** <<<First-class>>> :drill:
:PROPERTIES:
:ID:       b451a91d-1eb3-4c05-882f-23ea9a643a82
:END:

1. Can be used as value.
2. Passed as an argument.
From 1&2 -> can include itself.

** <<<First-order logic>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       fbfe3772-5c3a-41c4-9d53-6b2bc571236e
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 2.75
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:END:

Collection of formal systems used in mathematics, philosophy, linguistics, and computer science. First-order logic uses quantifier, variables over non-logical objects and allows the use of sentences that contain variables.

*** /*/
<<<Predicate logic>>>
<<<First-order predicate calculus>>>

** <<<Free variable>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       e6e68077-da2a-41d1-aed4-c033f7a97abe
:DRILL_LAST_INTERVAL: 29.8462
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:06]
:END:

Variable in the fuction that is not bound by the head.
Until there are /* -/ function stays partially applied.

** <<<Function>>> :drill:
:PROPERTIES:
:ID:       e86b0dde-ef8f-447e-a966-7553784aab54
:END:

A varying quantity depends on another quantity.

$$ x \in X, y \in Y : \; f^{X \to Y} = \overset{\rightharpoonup}{G}(x,y) $$

Directionality and property of invariability emerge from one another.
#+begin_src haskell
-- domain func codomain
   *      ->   *
#+end_src

$$ y(x) = (zx^{2} + bx + 3 | b = 5) $$
^ ^     ^^    ^    ^
| |     ||     \_Var \__Constants
| |     | \__Bound__variable
| |     \_Free variable
|  \_Parameter
 \__Name__of__the__function

Lambda abstraction is a function.
Function is a mathematical operation.

Function = Total function = Pure function. Function theoretically posible to momoized.
Partial function.
Inverse function - often partially exists (partial function).

*** /*/
<<<Functions>>>

*** <<<Arity>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       fa4caa07-eea5-4082-aaed-92abb820e768
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

Number of parameters of the function.
  * nullary - f()
  * unary   - f(x)
  * binary  - f(x,y)
  * ternary - f(x,y,z)
  * n-ary   - f(x,y,z..)

*** <<<Bijection>>> :drill:
:PROPERTIES:
:ID:       8366200a-a8ed-4c7b-baec-eb957d9f3d64
:END:

Function complete one-to-one pairing of elements of domain and codomain (image).
It means function both surjective (so image == codomain) and injective (every domain element has unique correspondence to the image element).

For bijection inverse always exists.

Bijective operation holds the equivalence of domain and codomain.

Denotation:
#+begin_src text
⤖
>->>
f : X ⤖ Y
#+end_src
LaTeX needed to combine symbols:
$$ \newcommand*{\twoheadrghtarrowtail}{\mathrel{\rightarrowtail\kern-1.9ex\twoheadrightarrow}} f : X \twoheadrghtarrowtail Y $$

**** /*/
<<<Bijective>>>
<<<Bijective function>>>

*** <<<Combinator>>> :drill:
:PROPERTIES:
:ID:       bf7ce908-9d5d-4a00-ab02-e7b33edd2c76
:END:

Function without free variables.
Higher-order function that uses only function application and other combinators.

#+begin_src haskell
\a -> a
\ a b -> a b
\f g x -> f (g x)
\f g x y -> f (g x y)
#+end_src

Not combinators:
#+begin_src haskell
\ xs -> sum xs
#+end_src
Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.

*** <<<Function application>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       630790f7-377f-463e-8058-792502dbcc88
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:09]
:END:

Function application is applying the function parameter to an argument from its domain to obtain the resulting value from its range.

**** /*/
<<<Applied>>>
<<<Apply>>>

*** <<<Function body>>> :drill:
:PROPERTIES:
:ID:       8c0947a8-56ae-49de-b3a8-ab87beab0bd6
:END:

Expression that haracterizes the process.

*** <<<Function composition>>> :drill:
:PROPERTIES:
:ID:       e609101f-4f65-4f58-b997-2fe44c52c6d9
:END:

#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
#+end_src

In Haskell inline composition requires:
#+begin_src haskell
h.g.f $ i
#+end_src

**** /*/
<<<Composition>>>
<<<Compose>>>
<<<Composed>>>

*** <<<Function head>>> :drill:
:PROPERTIES:
:ID:       6eb9d501-0dda-4a9e-b3e1-e35fb84d31b8
:END:

Is a part with Name of the function and it's paramenter.
AKA: f(x)

*** <<<Function range>>> :drill:
:PROPERTIES:
:ID:       15fbd0e9-f327-4065-872e-23713f79ec12
:END:

The range of a function refers to either the codomain or the image of the function, depending upon usage. Modern usage almost always uses range to mean image.
So, see Function image.

*** <<<Higher-order function>>> :drill:
:PROPERTIES:
:ID:       61a40480-45d2-4632-9948-986eecd8b7cb
:END:

Function arity > 1.

----

Has function as a parameter.
Evaluates to function.

**** /*/
<<<HOF>>>

**** <<<Fold>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       9513b166-74df-4a9f-b7da-d03f84ca2cfc
:DRILL_LAST_INTERVAL: 9.43
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:07]
:END:

Higher-order function returns accumulated result from recursive data structure applying a function.

*** <<<Injection>>> :drill:
:PROPERTIES:
:ID:       c1f2a44b-8b24-47b8-8e23-304ad4fc536a
:END:

Function one-to-one injects from domain into codomain.

Keeps distinct pairing of elements of domain and image.
Every element in image coresponds to one element in domain.

$$ \forall a,b \in X, \; f(a)=f(b) \Rightarrow a=b $$

$$ \exists (inverse \ function) \ | \ \forall (injective \ function) $$

Denotion:
#+begin_src text
↣
>->
f : X ↣ Y
#+end_src
$f : X \rightarrowtail Y$

Corresponds to Monomorphism.

**** /*/
<<<Injective>>>
<<<Injective function>>>
<<<Injectivity>>>

*** <<<Partial function>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       d8d7edc3-b943-4afa-8832-ddb2ef2a386d
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:41]
:END:

One that does not cover all domain.
Unsafe and causes trouble.

*** <<<Purity>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       5c84fbd6-2c97-464f-9431-965dd8c91aef
:DRILL_LAST_INTERVAL: 10.764
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:59]
:END:

Referentially transparent function.

**** /*/
<<<Pure>>>
<<<Pure function>>>

*** <<<Sectioning>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       c8cadab6-16e6-4d0e-9b79-6e3b56dcbd8e
:DRILL_LAST_INTERVAL: 26.9152
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:25]
:END:

Writing function in a parentheses. Allows to pass around partially applied functions.

*** <<<Surjection>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       56270a1d-ef0e-4986-a1ff-04606b37ccb7
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:10]
:END:

Function uses codomain fully.

$$ \forall y \in Y, \exists x \in X $$

Denotation:
#+begin_src text
↠
->>
f : X ↠ Y
#+end_src
$$ f : X \twoheadrightarrow Y $$

Corresponds to Epimorphism.

**** /*/
<<<Surjective>>>
<<<Surjective function>>>

*** <<<Unsafe>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       b48b82e3-f86c-4360-a568-727c2500d06c
:DRILL_LAST_INTERVAL: 9.43
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:25]
:END:

Function that does not cover some edge case.

*** <<<Variadic>>> :drill:
SCHT: <2019-08-02 Fri>
:PROPERTIES:
:ID:       b6592f9f-3718-4f2f-9423-06b590e6b84d
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:02]
:END:

Variadic function has a indefinite arity. Assepts a variable number of arguments.

*** <<<Domain>>> :drill:
:PROPERTIES:
:ID:       61416c64-6cbf-4af4-9428-ad6f79e76701
:END:

Source set of a function in $$ X \to Y $$.

*** <<<Codomain>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       f8603032-30f1-4074-80b5-0f6f49428241
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:47]
:END:

Codomain - target set of a function in $X \to Y$.

*** <<<Open formula>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       dc5f353b-84dc-4bce-85e2-eaa56f18401f
:DRILL_LAST_INTERVAL: 9.43
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:59]
:END:

Function with arity.

*** <<<Recursion>>> :drill:
:PROPERTIES:
:ID:       2e2d87ae-d918-47fc-b810-f95366fe4039
:END:

Repeated function application allow computing results that may require indefinite amount of work.

**** /*/
<<<Recursive>>>

**** <<<Base case>>> :drill:
SCHT: <2019-07-29 Mon>
:PROPERTIES:
:ID:       be130896-9bec-4276-9a7b-41cfb9f3b6dd
:DRILL_LAST_INTERVAL: 28.8036
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:17]
:END:

A part of a recursive function that trivially produces result.

**** <<<Tail recursion>>> :drill:
:PROPERTIES:
:ID:       62dd2851-710e-4035-9890-6af1c17e6305
:END:

Tail calls are recursive invocantions of itself.

** <<<Fundamental theorem of algebra>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       c44040e1-2dcf-4f25-9dee-05fd95337dc2
:DRILL_LAST_INTERVAL: 9.648
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.333
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:08]
:END:

Any non-constant single-variable polynomial with complex coefficients has at least one complex root.
Also derives that the field of complex numbers is algebraically closed.

** <<<Guerrilla patch>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       500e9e31-5960-4275-a8e3-3190b3b63f8f
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:59]
:END:

/*/ changing code/applying patch sneakily - and possibility incompatibility with other at runtime.
Monkey patch is derivative term.

** <<<Homotopy>>> :drill:
:PROPERTIES:
:ID:       4b3fc811-290c-4462-aaa6-208134e9e591
:END:

ὁμός homós same

One can be "continuously deformed" into the other.

For example - functions, functors.
Natural transformation is a homotopy of functors.

*** /*/
<<<Homotopies>>>
<<<Homotopic>>>

** <<<Idiom>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       bc244256-751d-4205-857e-368a45580884
:DRILL_LAST_INTERVAL: 22.2548
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:11]
:END:

/*/ - something having a meaning that can not be derived from the conjoined meanings.
Meaning can be special for language speakers or human with particular knowledge.

/*/ can also mean Applicative functor.

*** /*/
<<<Idiomatic>>>

** <<<Iff>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       50d0c8a8-4e41-4ddd-92fa-8135124c1809
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:57]
:END:

If and only if, exectly when, just.
Denotation:
$$ \iff $$

** <<<Impredicative>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       0f1f3bcf-df47-44de-8320-03ed8f18dc38
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

Self-referencing definition.

---

/Antonym - Predicative./

** <<<Infix>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       6de70cc8-f8a0-461f-ae1a-0a8ead07799b
:DRILL_LAST_INTERVAL: 30.7556
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:10]
:END:

Form of wrinting of operaton application in-between variables.

** <<<Inhabit>>> :drill:
:PROPERTIES:
:ID:       3d5a5fec-312b-47a2-bcb7-8d87f6a2baf3
:END:

What values inhabit data type

** <<<Interface>>> :drill:
:PROPERTIES:
:ID:       2ef38e57-e693-490c-af8e-f92b3c31e6b3
:END:

Point of mutual meeting. Code behind interface determines how data is consumed.

** <<<IO>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       40e4a54b-c1c7-41fc-ac84-d3f167eb320f
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

Type for values whose evaluations has a posibility to cause side effects or return unpredictable result.
Haskell standard uses monad for constructing and transforming IO actions.
IO actions can be evaluated multiple times.

IO data type has unpure imperative actions inside. Haskell is pure Lambda calculus, and unpure IO integrates in the Haskell purely (type system abstracts IO unpurity inside IO data type).

IO collects effects sequences one after another:
#+begin_src haskell
:{
twoBinds :: IO ()
twoBinds =
  putStrLn "First:" >>
  getLine >>=
  \a ->
  putStrLn "Second:" >>
  getLine >>=
  \b ->
  putStrLn ("\nFirst: "
    ++ a ++ ".\nSecond "
    ++ b ++ ".")
main = twoBinds
:}
#+end_src

** <<<Kind>>> :drill:
:PROPERTIES:
:ID:       56fd7e68-49b4-496f-bc0b-bcdd8ee3fa57
:END:

Kind -> Type -> Data

** <<<Lambda calculus>>> :drill:
:PROPERTIES:
:ID:       f484ba96-5cb1-45d2-9265-25130f62361c
:END:

Universal model of computation that can be used to simulate any Turing machine.
Based on function abstraction and application by substituting variables and binding values.

/*/ has lambda terms:
   * variable ($$ x $$)
   * application ($$ (ts) $$)
   * abstraction (lambda function) ($$ (\lambda x . t) $$)

*** /*/
<<<Lambda term>>>
<<<Lambda terms>>>

*** <<<Lambda abstraction>>> :drill:
:PROPERTIES:
:ID:       5baf8dda-dacf-447f-bcdf-26d3b3599a42
:END:

Lambda term that has a head and body and is applied to an argument.
$$ \lambda x.x+1 $$
#+begin_src haskell
\ x -> x + 1
^^
#+end_src

*** <<<Lambda cube>>> :drill:
:PROPERTIES:
:ID:       9ecad208-0bba-4d09-8906-5f5f76777182
:END:

λ-cube shows the dimentions of generalization from simply typed Lambda calculus to Calculus of constructions.

Each dimension of the cube corresponds to a new way of making objects depend on other objects:
  * (First-class polymorphism) - terms allowed to depend on types, corresponding to polymorphism.
  * (Higher-rank polymorphism) - types depending on terms, corresponding to dependent types.
  * (Type class) - types depending on types, corresponding to type operators.

**** /*/
<<<λ-cube>>>
<<<\lambda-cube>>>

*** <<<Lambda function>>> :drill:
:PROPERTIES:
:ID:       857ef4b3-f3e6-4065-aac4-fd3607ed5284
:END:

Function of Lambda calculus.
$$ \lambda x y.x^2 + y^3 $$
 ^^ ^    ^
 || |     \__variable
 ||  \__variable
 || (_____)
 ||     \___BODY
 ||
 | \__parameter
  \___parameter
(___)
   \____HEAD

**** <<<Lambda expression>>>
See Lambda function

**** <<<Anonymous function>>>
Lambda function without the name to bind to.

*** <<<\beta-reduction>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       09ff04bc-e52b-47e9-9a9e-a23bd437fb75
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:03]
:END:

Applying argument to parameter of a function.

**** /*/
<<<\beta reduction>>>
<<<Beta-reduction>>>
<<<Beta reduction>>>

**** <<<\beta-normal form>>> :drill:
SCHT: <2019-08-18 Sun>
:PROPERTIES:
:ID:       56b65c7e-f063-4614-b2c7-916ff446ab80
:DRILL_LAST_INTERVAL: 24.0088
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:14]
:END:

No beta reduction is possible.

***** /*/
<<<\beta normal from>>>
<<<Beta normal form>>>
<<<Beta-normal form>>>

*** <<<Calculus of constructions>>> :drill:
:PROPERTIES:
:ID:       6c93585b-5ba5-4a38-ae39-2f7dc718390b
:END:

Extends the Curry–Howard correspondence to the proofs in the full intuitionistic predicate calculus (includes proofs of quantified statements).
Type theory, typed programming language, and constructivism (phylosophy) foundation for mathematics.
Directly relates to Coq programming language.

**** /*/
<<<<<<CoC>>>>>>

*** <<<Curry–Howard correspondence>>> :drill:
:PROPERTIES:
:ID:       8b3e318d-242b-41ad-a16c-20d950177f5d
:END:

Computer programs are mathematical proofs.

**** /*/
<<<Curry–Howard isomorphism>>>

*** <<<Currying>>> :drill:
:PROPERTIES:
:ID:       4f8d7c52-f114-40ad-869e-e1ab4fdafc37
:END:

Translating the evaluation of a multiple argument function (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.

**** /*/
<<<Curry>>>

*** <<<Hindley–Milner type system>>> :drill:
SCHT: <2019-08-05 Mon>
:PROPERTIES:
:ID:       67b414eb-6659-455f-bbb5-cb507c643567
:DRILL_LAST_INTERVAL: 18.8265
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:55]
:END:

Classical type system for the Lambda calculus with Parametric polymorphism and Type inference.
Where types marked as polymorphic variables, and overall type inference is possible all over the code.
Also known as Damas–Milner or Damas–Hindley–Milner system.

*** <<<Reduction>>> :drill:
:PROPERTIES:
:ID:       11776f99-f2e5-46fd-a566-8e08060fd7f0
:END:

See Beta reduction

**** /*/
<<<Reducible>>>

*** <<<\beta-\eta normal form>>> :drill:
:PROPERTIES:
:ID:       0240a6dc-9667-4558-b138-3423930eafe6
:END:

No \beta-reduction and no \eta-reduction are possible in expression.

**** /*/
<<<beta-eta normal form>>>
<<<beta eta normal form>>>

*** <<<\eta-abstraction>>> :drill:
SCHT: <2019-08-02 Fri>
:PROPERTIES:
:ID:       c385db49-d92d-4b80-85b9-ecd8b786671e
:DRILL_LAST_INTERVAL: 10.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:54]
:END:

$$ (\lambda x.Mx) \xleftarrow[\eta]{} M $$

#+begin_src haskell
\ x -> g . f $ x
\ x -> g . f     --eta-abstraction
#+end_src

**** /*/
<<<\eta-reduction>>>
<<<\eta-conversion>>>
<<<\eta abstraction>>>
<<<\eta reduction>>>
<<<\eta conversion>>>
<<<eta-abstraction>>>
<<<eta-reduction>>>
<<<eta-conversion>>>
<<<eta abstraction>>>
<<<eta reduction>>>
<<<eta conversion>>>

** <<<Lense>>> :drill:
:PROPERTIES:
:ID:       b8d107f0-cbf4-42cb-acb5-5d987de3c7d1
:END:

Library to provide Haskell (functional language without mutation) the =get=-ters and =set=-ters of imperative language.

** <<<Level of code>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       c0196ee9-7ddc-4b66-b2bb-0d52f1051d75
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

There are mainly three levels of Haskell code.

*** /*/
<<<Code level>>>

*** <<<Term level>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       6bc4fbee-38e5-4612-ae28-8344a0f6028c
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:06]
:END:

Level of code that works with data types.

*** <<<Type level>>> :drill:
:PROPERTIES:
:ID:       2d900462-89be-4f77-be51-2d1867e82922
:END:

Level of code that does logical execution.

*** <<<Compile level>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       37ac8b2b-af11-4b67-976c-84bd00d5f1bc
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:07]
:END:

Level of code when code compiles/compiled.

**** /*/
<<<Compilation level>>>

*** <<<Runtime level>>> :drill:
:PROPERTIES:
:ID:       99d21c80-6b3d-4818-aef0-6c7796571883
:END:

Level of code when binary code executes in machine.

** <<<Lexical scope>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       989a2a14-8faf-4edb-a1cf-c3ae3a929425
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:21]
:END:

Scope bound by the structure of source code where the named entity is defined.

*** /*/
<<<Static scope>>>

** <<<Local scope>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       4dba73c1-5cb4-4612-b9dc-f7a05d463baa
:DRILL_LAST_INTERVAL: 29.8462
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:05]
:END:

Scope applies only in (current) area.

*** /*/
<<<Local>>>

** <<<Module>>> :drill:
:PROPERTIES:
:ID:       d96e515e-8f88-413f-a12c-50bdb5f0a096
:END:

Importable organization unit.

** <<<Modulus>>> :drill:
:PROPERTIES:
:ID:       740ee455-cd6f-4ee2-8ba1-46841e8b010a
:END:

Special numbers where arithmetic wraps around in modular arithmetic.

*** /*/
<<<Moduli>>> - plural.

** <<<Monkey patch>>> :drill:
SCHT: <2019-07-31 Wed>
:PROPERTIES:
:ID:       8b05451a-ed92-464d-884a-654d9b5dad6a
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:51]
:END:

/From Guerrilla patch./

/*/ is a way for program to modify supporting system software affecting only the running instance of the program.

** <<<Nothing>>> :drill:
:PROPERTIES:
:ID:       350c03dd-e563-4d42-b554-d38370619667
:END:

Any Haskell expression can't return nothing.

** <<<Operation>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       10f782ae-17e5-434e-8d2e-ee8ee3f9b530
:DRILL_LAST_INTERVAL: 28.6705
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:10]
:END:

Function. Word used in mathematics. Often a symbol, infix, binary.

*** <<<Binary operation>>> :drill:
:PROPERTIES:
:ID:       f7cf1edb-834b-4505-874b-c7e8acc6d547
:END:

$$ \forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S $$

**** /*/
<<<Binary operations>>>

** <<<Operator>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       ad158f22-64c6-44c6-b140-4fc5c2b065f7
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:00]
:END:

Function that denoted by symbol.

*** <<<Shift operator>>> :drill:
:PROPERTIES:
:ID:       48503777-55e0-4c6e-8675-f220bb2c11c8
:END:

Shift operator defined by Lagrange through Differential operator.
$$ T^{t} \, = \, e^{t{\frac{d}{dx}}} $$

**** /*/
Shift

** <<<Orphan type instance>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       9a4837d3-82e9-49f1-860d-e198013a60b5
:DRILL_LAST_INTERVAL: 10.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:06]
:END:

Type instance that appeared from inconsistent code base. Duplicate of instance, or instance present on type class or on the type level.

Solution for addressing orphan instances:
1. You defined the type but not the type class?
Put the instance in the same module as the type so that the type cannot be imported without its instances.
2. You defined the type class but not the type?
Put the instance in the same module as the type class definition so that the type class cannot be imported without its instances.
3. Neither the type nor the type class are yours?
Define your own newtype wrapping the original type and now you’ve got a type that “belongs” to you for which you can rightly define type class instances. There are means of making this less annoying which we’ll discuss later.

** <<<Parameter>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       737527a3-4fcf-4499-9d27-6fab664d9da0
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

παρά /para/ subsidiary
μέτρον /metron/ measure

Or Formal Parameter. Named varible of a function.

Argument is a supplied value to a function.

*** /*/
<<<Parameters>>>

** <<<Partial application>>> :drill:
:PROPERTIES:
:ID:       3ec44a13-f6e9-4ba4-b0af-1c12b8017775
:END:

Part of function parameters applied.

*** /*/
<<<Partially applied>>>

** <<<Pattern guard>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       4ab85a6a-7e60-47fb-996a-c4d5263c3f62
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:END:

Allows check a list of pattern matches against functions, and then proceed.

| (/pattern1/) <- (/funcCheck1/)
, (/pattern2/) <- (/funcCheck2/)
= /RHS/

#+begin_src haskell
lookup :: Eq a => a -> [(a, b)] -> Maybe b

addLookup env var1 var2
   | Just val1 <- lookup var1 env
   , Just val2 <- lookup var2 env
   = val1 + val2
{-...other equations...-}
#+end_src
Check both to succeed, match results into =val1=, =val2=, then proceed to the equation.

Default in Haskell 2010.

*** /*/
<<<Pattern guards>>>

** <<<Permutation>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       af01cb45-6b61-4b9f-bac6-390a2ec82a5c
:DRILL_LAST_INTERVAL: 10.1844
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.6
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:37]
:END:

Bijective function from domain to itself.

** <<<Phrase>>> :drill:
:PROPERTIES:
:ID:       a23fe978-1afc-4fc9-8dda-6bb49b9554a3
:END:

/*/ - composable expression.

** <<<Point-free>>> :drill:
SCHT: <2019-08-09 Fri>
:PROPERTIES:
:ID:       4a6fc5de-f277-4bb9-afd0-6dcb3698b317
:DRILL_LAST_INTERVAL: 24.8795
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-15 Mon 23:51]
:END:

Paradigm where function only describes the morphism itself.

Process of converting function to point-free.
If brackets /()/ can be changed to /$/ then $ equal to composition:
#+begin_src haskell
\ x -> g (f x)
\ x -> g $ f x
\ x -> g . f $ x
\ x -> g . f     --eta-abstraction

\ x1 x2 -> g (f x1 x2)
\ x1 x2 -> g $ f x1 x2
\ x1 x2 -> g . f x1 $ x2
\ x1    -> g . f x1
#+end_src

*** /*/
<<<Pointfree>>>
<<<Tacit>>>
<<<Tacit programming>>>

*** <<<Blackbird>>> :drill:
SCHT: <2019-09-11 Wed>
:PROPERTIES:
:ID:       76123e3b-3042-4112-beaf-7f281c13e58a
:DRILL_LAST_INTERVAL: 48.4944
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.4
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:57]
:END:

#+begin_src haskell
(.).(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
#+end_src

Composition of compositions =(.).(.)=. Allows to compose-in a binary function =f1(c) (.).(.) f2(a,b)=.
#+begin_src haskell
\f g x y -> f (g x y)
#+end_src

**** /*/
<<<.) .>>>
<<<(.).(.)>>>
<<<Composition of compositions>>>

*** <<<Swing>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       1d5d1b4c-2390-4ebd-b79c-23ed3deec10e
:DRILL_LAST_INTERVAL: 10.1844
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 2.499
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:53]
:END:

#+begin_src haskell
swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
swing = flip . (. flip id)
swing f = flip (f . runCont . return)
swing f c a = f ($ a) c
#+end_src

*** <<<Squish>>> :drill:
:PROPERTIES:
:ID:       4813e27d-4ac4-415f-95c5-323b605c1de6
:END:

#+begin_src haskell
f >>= a . b . c =<< g
#+end_src

** <<<Polymorphism>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       83a22f3c-9140-490c-9390-85319566a443
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:45]
:END:

πολύς /polús/ many

At once several forms.

Abstract over data types.

/Antonym - Monomorphism./

Types:

*** /*/
<<<Polymorphic>>>

*** <<<Levity polymorphism>>> :drill:
:PROPERTIES:
:ID:       cba719c7-40cf-4fbe-841f-b52909f552b7
:END:

Levity polymprphism is when polymorphism works with lifted and unlifted types.

*** <<<Parametric polymorphism>>> :drill:
:PROPERTIES:
:ID:       0f4d5c48-f692-4a1f-8368-b0dab65f6d2f
:END:

Abstracting over data types by parameter.

/In most languages named as 'Generics' (generic programming)./

Types:

**** <<<Rank-1 polymorphism>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       5fc7f989-ce41-4150-8301-3328b30fd206
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:04]
:END:

Parametric polymorphism in rank-1 types by type variables.

***** /*/
<<<Prenex>>>
<<<Prenex polymorpism>>>

**** <<<Let-bound polymorphism>>> :drill:
:PROPERTIES:
:ID:       f415a2f4-8f66-483d-9b75-70b3e5fe4b89
:END:

It is property chosen for Haskell type system.
Haskell is based on Hindley-Milner type system, it is let-bound.
It means that to have strict type inference - if `let` and `where` declarations a polymorphic - $\lambda$ declarations - should be not.
So:
#+begin_src haskell
foo :: (Int, Char)
foo = (\f -> (f 1, f 'a')) id
#+end_src
Is illegal in Haskell.

Lambda-bound function (i.e., one passed as argument to another function) cannot be instantiated in two different ways, if there is a let-bound polymorphism.

**** <<<Constrained polymorphism>>> :drill:
:PROPERTIES:
:ID:       ad855e03-3fc1-4875-b28c-82b85987eccb
:END:

Constrained Parametric polymorphism.

***** <<<Ad hoc polymorphism>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       d98c11bf-35fd-46ae-803f-28df28c37a54
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:47]
:END:

Artificial constrained polymorphism dependent on incoming data type.
Achieved by creating a type class functions.
It is interface dispatch mechanism by data types.

/Commonly known as overloading./

******* /*/
<<<Constraint>>>
<<<Constraints>>>

**** <<<Impredicative polymorphism>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       4d1d48af-a46a-4632-88f2-fff7643f0d7e
:DRILL_LAST_INTERVAL: 10.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:45]
:END:

The most powerful form of Parametric polymorphism.
First see Impredicative.

Impredicative polymorphism allows type τ entities with polymorphic types that can contain type τ itself.
$$ T = \forall X. X \to X : \; T \in X \vDash T \in T $$
This approach has Russell's paradox (and its form - Girard's paradox).

***** /*/
<<<First-class polymorphism>>>

**** <<<Higher-rank polymorphism>>> :drill:
:PROPERTIES:
:ID:       80de6f6a-d231-4296-9f73-4caa384e65b9
:END:

Means that polymorphic types can apper within other types (types of function).
There is a cases where higher-rank polymorphism than the a Ad hoc - is needed. For example where ad hoc polymorphism is used in constraints of several different implementations of functions, and you want to build a function on top - and use the abstract interface over these functions.
#+begin_src haskell
-- ad-hoc polymorphism
f1 :: forall a. MyType Class a => a -> String    ==    f1 :: MyType Class a => a  -> String
f1 = -- ...

-- higher-rank polymorphism
f2 :: Int -> (forall a. MyType Class a => a -> String) -> Int
f2 = -- ...
#+end_src
By moving `forall` inside the function - we can achive higher-rank polymorphism.

From: https://news.ycombinator.com/item?id=8130861
#+begin_src text
Higher-rank polymorphism is formalized using System F, and there are a few implementations of (incomplete, but decidable) type inference for it - see e.g. Daan Leijen's research page [1] about it, or my experimental implementation [2] of one of his papers. Higher-rank types also have some limited support in OCaml and Haskell.
#+end_src

Useful example aslo a ST-Trick monad.

***** /*/
<<<Rank-n polymorphism>>>

*** <<<Subtype polymorphism>>> :drill:
:PROPERTIES:
:ID:       9e587f6d-08ed-406c-9bf0-3af96cb8eb49
:END:

Allows to declare usage of a Type and all of its Subtypes.
T - Type
S - Subtype of Type
<: - subtype of
$$ S <: T = S \le T $$

Subtyping is:
If it can be done to T, and there is subtype S - then it also can be done to S.
$$ S <:T : \; f^{T \to X} \Rightarrow f^{S \to X} $$

*** <<<Row polymorphism>>> :drill:
:PROPERTIES:
:ID:       18e7413e-72cc-4ab6-8c9e-1591f4b00606
:END:

# NOTE: 2019-03-11: Currently WIP in https://github.com/ghc-proposals/ghc-proposals/pull/180 
Is a lot like Subtype polymorphism, but alings itself on allowence (with | r) of subtypes and types with requested properties.
#+begin_src haskell
printX :: { x :: Int | r } -> String
printX rec = show rec.x

printY :: { y :: Int | r } -> String
printY rec = show rec.y

-- type is inferred as `{x :: Int, y :: Int | r } -> String`
printBoth rec = printX rec ++ printY rec
#+end_src

*** <<<Kind polymorphism>>> :drill:
:PROPERTIES:
:ID:       4658489e-5516-44d3-b9ab-06f9077657f5
:END:

Achieved using a phantom type argument in the data type declaration.
#+begin_src haskell
;;         * -> *
data Proxy a = ProxyValue
#+end_src
Then, by default the data type can be inhabited and fully work being partially defined.
But multiple instances of kind polymorphic type can be distinguished by their particular type.

Example is the Proxy type:
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- * :: Proxy Int
let proxy2 = (ProxyValue :: Proxy a)   -- * -> * :: Proxy a
#+end_src

*** <<<Linearity polymorphism>>> :drill:
:PROPERTIES:
:ID:       4a8f87d0-99ee-40e7-8a02-92b97540f9b4
:END:

Leverages linear types.
For exampe - if fold over a dynamic array:
  1) In basic Haskell - array would be copied at every step.
  2) Use low-level unsafe functions.
  3) With Linear type function we guarantee that the array would be used only at one place at a time.

So, if we use a function (* -o * -o -o *) in foldr - the fold will use the initial value only once.

** <<<Pragma>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       92784b03-a83b-4599-9cd0-f2210dd5e177
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:51]
:END:

Pragma - instruction to the compiler that specifies how a compiler should process the code.
Pragma in Haskell have form:
#+begin_src haskell
{-# PRAGMA options #-}
#+end_src

*** <<<LANGUAGE pragma>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       6f16cf30-77b4-4e31-af0a-11dd24ae48bf
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:09]
:END:

Controls what variations of the language are permitted.
It has a set of allowed options: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html, which can be supplied.

**** <<<LANGUAGE option>>>

***** Useful by default :drill:
:PROPERTIES:
:ID:       29c25dae-3a88-4fe1-acf3-4ebe568da284
:END:

#+begin_src haskell
import EmptyCase
import FlexibleContexts
import FlexibleInstances
import InstanceSigs
import MultiParamTypeClasses
#+end_src

***** <<<AllowAmbiguousTypes>>> :drill:
:PROPERTIES:
:ID:       e5aaa672-dec3-4621-8429-9b5cdcaac069
:END:

Allow type signatures which appear that they would result in an unusable binding.
However GHC will still check and complain about a functions that can never be called.

***** <<<ApplicativeDo>>> :drill:
:PROPERTIES:
:ID:       cb3b5b66-06a8-4187-9606-631faefa7814
:END:

Enables an alternative in-depth reduction that translates the do-notation to the operators =<$>=, =<*>=, =join= as far as possible.

For GHC to pickup the patterns, the final statement must match one of these patterns exactly:

#+begin_src haskell
  pure E
  pure $ E
  return E
  return $ E
#+end_src

When the statements of do expression have dependencies between them, and ApplicativeDo cannot infer an Applicative type - GHC uses a heuristic $$ O(n^2) $$ algorithm to try to use <*> as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is aslo $$ O(n^3) $$ algorithm that finds the optimal solution: =-foptimal-applicative-do=.

Requires =ap = <*>=, =return = pure=, which is true for the most monadic types.
  * Allows use of do-notation with types that are an instance of Applicative and Functor
  * In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.

The only way it shows up at the source level is that you can have a =do= expression with only Applicative or Functor constaint.

It is possible to see the actual translation by using =-ddump-ds=.

***** <<<ConstrainedClassMethods>>> :drill:
:PROPERTIES:
:ID:       301a3741-f96c-45a7-bb14-7e342167b62d
:END:

Enable the definition of further constraints on individual class methods.

***** <<<CPP>>> :drill:
:PROPERTIES:
:ID:       4209a57c-e331-4c03-9386-b08d2cfd33d7
:END:

Enable [[https://en.wikipedia.org/wiki/C_preprocessor][C preprocessor]].

***** <<<DeriveFunctor>>> :drill:
SCHT: <2019-08-05 Mon>
:PROPERTIES:
:ID:       34a6dad7-515c-4b3c-afeb-da268b77c4e0
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:14]
:END:

Automatic deriving of instances for the Functor type class.
For type power set functor is unique, its derivation inplementation can be autochecked.

***** <<<ExplicitForAll>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       cde4229a-165c-4dfa-a3b5-22375f7924a6
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:25]
:END:

Allow explicit forall quantificator in places where it is implicit by Haskell.

***** <<<FlexibleContexts>>> :drill:
:PROPERTIES:
:ID:       ab8dc15c-452a-4dd7-94fe-1e1c38fd0c1e
:END:

Ability to use complex constraints in class declaration contexts.
The only restriction on the context in a class declaration is that the class hierarchy must be acyclic.
#+begin_src haskell
class C a where
  op :: D b => a -> b -> b

class C a => D a where ...
#+end_src
$$ C :> D $$, so in C we can talk about D.

Synergizes with ConstraintKinds.

***** <<<FlexibleInstances>>> :drill:
SCHT: <2019-08-04 Sun>
:PROPERTIES:
:ID:       c59f794d-5687-4b96-9fd0-7df4b650ed2a
:DRILL_LAST_INTERVAL: 19.8606
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-15 Mon 23:51]
:END:

Allow type class instances types contain nested types.
#+begin_src haskell
instance C (Maybe Int) where ...
#+end_src
Implies TypeSynonymInstances.

***** <<<GeneralizedNewtypeDeriving>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       96a23172-9aa7-4290-adfe-a18169dd4362
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:05]
:END:

Enable GHC’s =newtype= cunning generalised deriving mechanism.
#+begin_src haskell
newtype Dollars = Dollars Int
  deriving (Eq, Ord, Show, Read, Enum, Num, Real, Bounded, Integral)
#+end_src
(In old Haskell-98 only Eq, Ord, Enum could been inherited.)

***** <<<ImplicitParams>>> :drill:
SCHT: <2019-07-29 Mon>
:PROPERTIES:
:ID:       3ca7e2f5-0e70-474f-bb31-08186739efb1
:DRILL_LAST_INTERVAL: 10.7516
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-18 Thu 21:56]
:END:

Allow definition of functions expecting implicit parameters. In the Haskell that has static scoping of variables allows the dynamic scoping, such as in classic Lisp or ELisp.
Sure thing this one can be puzzling as hell inside Haskell.

***** <<<LambdaCase>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       938047ce-f015-45e9-b5f8-b8e39fb456a7
:DRILL_LAST_INTERVAL: 8.9861
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:45]
:END:

Enables expressions of the form:
#+begin_src haskell
\case { p1 -> e1; ...; pN -> eN }

-- OR

\case
  p1 -> e1
  ...
  pN -> eN
#+end_src

***** <<<MultiParamTypeClasses>>> :drill:
:PROPERTIES:
:ID:       5e34ea4e-cb1b-4359-968c-440f068b50ad
:END:

Implies: ConstrainedClassMethods
Enable the definitions of typeclasses with more than one parameter.
#+begin_src haskell
class Collection c a where
#+end_src

***** <<<MultiWayIf>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       9b5af526-36f9-49e2-ae8c-ac9a5361b877
:DRILL_LAST_INTERVAL: 9.6346
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:05]
:END:

Enable multi-way-if syntax.
#+begin_src haskell
if | guard1 -> expr1
   | ...
   | guardN -> exprN
#+end_src

***** <<<OverloadedStrings>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       b09019e1-34d5-40f0-b866-504f3e1e4515
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:50]
:END:

Enable overloaded string literals (string literals become desugared via the IsString class).
Now string literal has type:
#+begin_src haskell
(IsString a) => a
#+end_src

The usual string syntax can be used, e.g., for ByteString, Text, and other variations of string like types.
Now they can be used in pattern matches as char->integer translations. To pattern match Eq must be derived.

To use class IsString - import it from GHC.Ext

***** <<<PartialTypeSignatures>>> :drill:
:PROPERTIES:
:ID:       4ac887da-6e23-4028-9924-3496787aa8d0
:END:

Partial type signature containins wildcards, placeholders (=_=, =_name=).
Allows programmer to which parts of a type to annotate and which to infer. Also applies to constraint part.

As untuped expression, partly typed can not polymorphicly recurse.

-Wno-partial-type-signatures supresses infer warnings.

***** <<<RankNTypes>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       54d784f9-d433-4ef8-a029-a6a6c6f61c18
:DRILL_LAST_INTERVAL: 10.764
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:07]
:END:

Enable types of arbitrary rank.
See Type rank.

Implies ExplicitForAll.

Allows =forall= quantifier:
  * Left side of \to
  * Right side of \to
  * as argument of a constructor
  * as type of a field
  * as type of an implicit parameter
  * used in pattern type signature of Lexically scoped type variables

It can synergyze with ScopedTypeVariables.

***** <<<ScopedTypeVariables>>> :drill:
:PROPERTIES:
:ID:       5311b6b7-32e9-4ba9-a3fa-43b37df5988f
:END:

By default type variables do not have a scope except inside type signatures where they are used.

When there are internall type signatures provided in the code block (=where=, =let=, etc.) they (main type description of a function and internal type descriptions) restrain one-another and become not trully polymorphic, which creates a bounding interdependency of types that GHC would complain about.

/*/ option provides the lexical scope inside the code block for type variables that have forall quantifier. Because they are now lexiacally scoped - those type variables are used across internal type signatures.

For details see: https://ocharles.org.uk/guest-posts/2014-12-20-scoped-type-variables.html

Implies ExplicitForAll.

***** <<<TupleSections>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       30ae7849-e739-4718-b031-5566e8f82a67
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:11]
:END:

Allow tuple section syntax:
#+begin_src haskell
(, True)
(, "I", , , "Love", , 1337)
#+end_src

***** <<<TypeApplications>>> :drill:
:PROPERTIES:
:ID:       d5912c99-9c72-44ad-8577-a02f7d31671f
:END:

Allow type application syntax:
#+begin_src haskell
read @Int 5

:type pure @[]
pure @[] :: a -> [a]

:type (<*>) @[]
(<*>) @[] :: [a -> b] -> [a] -> [b]

--

instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)

λ> ($ 0) <$> generate (arbitrary @(Int -> Int))
#+end_src

***** <<<TypeSynonymInstances>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       3989b294-f011-48c0-9998-be10bd75c541
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 12:39]
:END:

Now type synonim can have it's own type class instances.

***** <<<UndecidableInstances>>> :drill:
:PROPERTIES:
:ID:       71ac682f-292d-401a-bd61-0c28a707a950
:END:

Permit instances which may lead to type-checker non-termination.

GHC has Instance termination rules regardless of FlexibleInstances FlexibleContexts.

***** <<<ViewPatterns>>> :drill:
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       cbd923fc-d36c-4953-a8dc-ca370eda11f0
:DRILL_LAST_INTERVAL: 3.725
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.667
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:58]
:END:

#+begin_src haskell
size (view -> Unit) = 1
size (view -> Arrow t1 t2) = size t1 + size t2
#+end_src
(/expression/ \to /pattern/): what came to match - apply the /expression/, then do /pattern/-match.
Semantics:
  * variables of /expression/ and /pattern/ are shared
  * if /expression/ :: t1 -> t2 && /pattern/ :: t2, then (/expression/ \to /pattern/) :: t1.

/*/ are like pattern guards that can be nested inside of other patterns.
/*/ are a convenient way to pattern-match algebraic data type.

***** <<<DatatypeContexts>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       0ed5ea82-77f7-4b51-af7b-19a3f6426ec3
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:06]
:END:

Allow contexts in data types.
#+begin_src haskell
data Eq a => Set a = NilSet | ConsSet a (Set a)

-- NilSet :: Set a
-- ConsSet :: Eq a => a -> Set a -> Set a
#+end_src
Considered misfeature, deprecated, going to be removed.

**** How to make a GHC LANGUAGE extension
In `libraries/ghc-boot-th/GHC/LanguageExtensions/Type.hs` add new constructor to the `Extension` type
#+begin_src haskell
data Extension
  = Cpp
  | OverlappingInstances
  ...
  | Foo
#+end_src

`/main/DynFlags.hs` extend `xFlagsDeps`:
#+begin_src haskell
xFlagsDeps = [
  flagSpec "AllowAmbiguousTypes" LangExt.AllowAmbiguousTypes,
  ...
  flagSpec "Foo"                 LangExt.Foo
]
#+end_src
It is for basic case. For testing, parser see further: https://blog.shaynefletcher.org/2019/02/adding-ghc-language-extension.html

** <<<Predicative>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       aee54dbf-2387-403e-9589-f93bcb416963
:DRILL_LAST_INTERVAL: 22.2265
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.75
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:48]
:END:

Non-self-referencing definition.

---

/Antonym - Impredicative./

** <<<Principle of compositionality>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       d8df7582-1e97-4cf9-9d0d-146ede21ad1f
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:22]
:END:

The meaning of a complex expression is determined by the meanings of its constituent expressions and the rules used to combine them.

** <<<\Psi-combinator>>> :drill:
SCHT: <2019-08-16 Fri>
:PROPERTIES:
:ID:       dd833dc5-91f9-4bec-aa5a-e292dfb387d8
:DRILL_LAST_INTERVAL: 31.1271
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-16 Tue 00:05]
:END:

Transforms two of the same type into one of some type. By applying mediate transformation, and applying combination of them into result.
#+begin_src haskell
import Data.Function (on)
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
#+end_src

*** /*/
<<<Psi-combinator>>>
<<<On-combinator>>>

** <<<Quantifier>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       ac758691-4dc3-4e6c-9f18-59793263a845
:DRILL_LAST_INTERVAL: 30.7556
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:11]
:END:

Specifies the quantity of specimens.

Two most common quantifiers $$ \forall $$ (Forall) and $$ \exists $$ (Exists).
$$ \exists ! $$ - one and only one (exists only unique).

*** /*/
<<<Quantification>>>
<<<Quantifiers>>>
<<<Quantified>>>

*** <<<Forall quantifier>>> :drill:
:PROPERTIES:
:ID:       922b622a-38c4-4079-a1e0-61ff010f7a10
:END:

Permits to not infer the type, but to use any that fits. The variant depends on the LANGUAGE option used:
ScopedTypeVariables
RankNTypes
ExistentialQuantification

**** /*/
<<<Forall>>>

** <<<Referential transparency>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       b7cbd6cd-5739-431a-9eae-5922e60dff81
:DRILL_LAST_INTERVAL: 22.2548
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:45]
:END:

Returns the same output given the same values to evaluate.
So:
/*/ expression can be replaced with its corresponding resulting value without change for program's behavior.
/*/ functions are pure.

*** /*/
<<<Referentially transparent>>>

** <<<Relation>>> :drill:
SCHT: <2019-08-13 Tue>
:PROPERTIES:
:ID:       ab1fec36-4201-4970-a717-70d56aa09e1b
:DRILL_LAST_INTERVAL: 18.8265
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.75
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:16]
:END:

Relationship between two objects.
Is not directed and not limited.

*** /*/
<<<Relations>>>
<<<Relationship>>>

** <<<REPL>>> :drill:
:PROPERTIES:
:ID:       f77f5734-1b15-4192-be41-f0ee8ac15441
:END:

Interactive CLI. Read-eval-print loop.

** <<<Scope>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       a2989c15-2adc-403a-add7-35855e9de65c
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:47]
:END:

Area where binds are accessible.

** <<<Semantics>>> :drill:
:PROPERTIES:
:ID:       f47d8882-a0eb-4956-9b87-56ac0c20d069
:END:

Philosophical study of meaning.

*** <<<Operational semantics>>> :drill:
:PROPERTIES:
:ID:       df2cb6cf-0eb7-4756-945e-a08d7246245b
:END:

Properties, such as correctness, safety or security, are verified by constructing proofs from logical assertion s about execution and procedures.

Good to solve in-point localized tasks.
Process of abstraction.

*** <<<Denotational semantics>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       a21dabc0-cc1e-4225-b9f1-86a14e2b7a13
:DRILL_LAST_INTERVAL: 8.7892
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 22:27]
:END:

Construction of mathematical objects (called denotations), that describe the meanings. In Haskell often abstractions that are ment (denotations), implemented directly in the code, sometimes exist over the code - allowing to reason and implement.

/*/ are composable.

Good to achive more broad approach/meaning.

Also see Abstraction.

*** <<<Axiomatic semantics>>> :drill:
:PROPERTIES:
:ID:       18d65b73-cec0-49ed-868a-a97d73abe329
:END:

Describing effect of operation on assertions about the overall state.

Good for examining interconnections.
Empirical process.

** <<<Set>>> :drill:
SCHT: <2019-09-11 Wed>
:PROPERTIES:
:ID:       3065b5ef-e7af-41af-a46e-201ced7f3c28
:DRILL_LAST_INTERVAL: 48.4944
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 18:47]
:END:

Well-defined collection of distinct objects.

*** /*/
<<<Sets>>>

*** <<<Closed set>>> :drill:
:PROPERTIES:
:ID:       33bc1a45-7af7-4320-ac6a-2bc785b7afd9
:END:

Closed set - a set whose complement is an open set.
Closed set is a form of Closed-form expression. Set can be closed in under a set of operations.

*** <<<Power set>>> :drill:
:PROPERTIES:
:ID:       fdf831a3-e05a-4bec-8849-1900ad7d9ce3
:END:

For some $$ \mathit{set} \mathcal{S} $$, the power set ($$ \mathcal{P(S)} $$) is a set of all subsets of $$ \mathcal{S} $$, including $$ \{\} $$ & $$ \mathcal{S} $$ itself.
Denotation:
$$ \mathcal{P(S)} $$

*** <<<Hom-set>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       69d139d5-3a8d-4a07-a5b3-44778cc0ce61
:DRILL_LAST_INTERVAL: 10.3873
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:53]
:END:

Collection of all morphisms (and compositions of morphisms) from object to object. Collection of morphisms is not nesessary a set, but in practice - is.

Denotation:
$$ hom(X,Y) $$

$$ hom_{C}(x,y) = (\forall f^{x \to y}) = hom(x,y) = C(x,y) $$
Denotation was not standartized.

**** <<<Hom-functor>>> :drill:
SCHT: <2019-07-27 Sat>
:PROPERTIES:
:ID:       e2bb6ea3-2f94-47d8-b4ab-b09feb096d98
:DRILL_LAST_INTERVAL: 3.725
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 6
:DRILL_AVERAGE_QUALITY: 2.25
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:42]
:END:

$$ hom:\mathcal{C}^{op} \times \mathcal{C} \to Set $$, for locally small category $$ \mathcal{C} $$.
Functor from the product of $$ \mathcal{C} $$ with opposite category to the category of sets.

Denotation variants:
$$ H_A = \mathrm{Hom}(-, A) $$
$$ h_A = {\cal \mathcal{C}}(-, A) $$
$$ Hom(A,-): \ \mathcal{C} \to Set $$

Hom-bifunctor:
$$ Hom(-,-): \ \mathcal{C}^{op} \times \mathcal{C} \to Set $$

*** <<<Singleton>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       cd966fe0-f42d-4b75-b388-85649eacc84f
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:54]
:END:

Singleton - unit set - set with exactly one element.
Also 1-tuple.

** <<<Shadowing>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       45b1bebf-431f-45dd-8522-ea688968090f
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:47]
:END:

Global scope variable overriden by variable in local scope.

** <<<Shrinking>>> :drill:
:PROPERTIES:
:ID:       bebb2732-e73d-4d2b-92e1-090ffa883c77
:END:

Process of reducing coplexity in the test case - re-run with smaller values and make sure that the test still fails.

** <<<Smart constructor>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       e2aded58-a463-4762-97c4-7fc2238d386d
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:07]
:END:

Place extra constraints on the construction of values.

** <<<Spine>>> :drill:
SCHT: <2019-07-28 Sun>
:PROPERTIES:
:ID:       9f1c254b-a3dd-4ba5-bdec-7b43be39d49f
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 12:51]
:END:

Is a chain of memory cells, each points to the both value of element and to the next memory cell.
#+begin_src text
Array:

  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

Spine:
  :
 / \
_   :
   / \
  _   :
     / \
    _  []

#+end_src

** <<<Statement>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       0fbcd5d9-8c13-4486-aabe-47c831900548
:DRILL_LAST_INTERVAL: 11.1407
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 12:43]
:END:

Declarative expression that is true or false.

*** /*/
<<<Assertion>>>
<<<Assertions>>>

*** <<<Predicate>>> :drill:
:PROPERTIES:
:ID:       6f4b0532-ca5f-4ec6-b827-bceb4afb0d3f
:END:

Assertion function that includes variable and results in true or false statement.

Notation: $$ P(x) $$
Application of argument yealds true or false predicate.

** <<<Superclass>>> :drill:
:PROPERTIES:
:ID:       7585ab04-6e2e-4908-88c9-28cf2dc9a73e
:END:

Broader parent class.

** <<<Syntatic sugar>>> :drill:
SCHT: <2019-08-01 Thu>
:PROPERTIES:
:ID:       244e15a8-9ae5-4842-82b1-279387d088fd
:DRILL_LAST_INTERVAL: 30.7556
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:11]
:END:

Artificial way to make language easier to read and write.

** <<<System F>>> :drill:
:PROPERTIES:
:ID:       a33a26ee-f5e0-4a70-b01e-dbf9b41b8681
:END:

Formalizes the notion of parametric polymorphism in programming languages.
Differs from the simply typed Lambda calculus by the introduction of universal quantification over types.

*** /*/
<<<Girard–Reynolds polymorphic lambda calculus>>>
<<<Girard-Raynolds>>>

** <<<Tail call>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       0d5c9709-660d-47c7-b573-7dd06d9cb936
:DRILL_LAST_INTERVAL: 22.2265
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:15]
:END:

Final evaluation producing result of the function.

** <<<Tensor>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       e165b708-fdd2-4062-be87-b65487de4a0e
:DRILL_LAST_INTERVAL: 21.9724
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:19]
:END:

Object existing out of planes, thus it can translate objects from one plane into another.
They can be tried to be described with knowledge existing inside planes, but representation would always be partial.
Tensor of rank 1 is a vector.

Translatioin with tensor can be seen as functors.

*** /*/
<<<Tensors>>>
<<<Tensorial>>>

** <<<Testing>>> :drill:
:PROPERTIES:
:ID:       07ea5b8e-05ee-4824-b690-455ab4918d77
:END:

*** <<<Property testing>>>
Since property has a law, then family of that unit tests can be abstracted into the lambda function.
And tests cases come from generator.

**** <<<Function property>>>
Property corresponds to the according law.
In property testing you need to think additionally about generator and shrinking.

**** <<<Property testing types>>>
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
|                          | Exhaustive                           | Randomized                           | Unit test (Single sample) |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
| Whole set of values      | Exhaustive property test             | Randomised property test             |                           |
| Special subset of values | Exhaustive specialised property test | Randomised specialised property test |                           |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|

**** <<<Generator>>>
#+begin_src text
Seed
|
v
Gen A -> A
^
|
Size
#+end_src

Seed allows reproducibility.
There is anyway a need to have some seed.
Size allows setting upper bound on size of generated value. Think about infinity of list.

After failed test - shrinking tests value parts of contrexample, finds a part that still fails, and recurses shrinking.

***** /*/
<<<Generators>>>

***** Custom generator
When sertain theorem only works for a specific set of values - the according generator needs to be produced.

#+begin_src haskell
arbitrary :: Arbitrary a => Gen a
suchThat :: Gen a -> (a -> Bool) -> Gen a
elements :: [a] -> Gen a
#+end_src

**** <<<Reusing test code>>>
Often it is convinient to abstract testing of same function properties:

It can be done with (aka TestSuite combinator):
#+begin_src haskell
-- Definition
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
eqSpec :: forall a. Arbitrary a => Spec

-- Usage
{-# LANGUAGE TypeApplications #-}
spec :: Spec
spec = do
  eqSpec @Int
#+end_src

#+begin_src haskell
Eq Int
  (==) :: Int -> Int -> Bool
    is reflexive
    is symetric
    is transitive
    is equivalent to (\ a b -> not $ a /= b)
  (/=) :: Int -> Int -> Bool
    is antireflexive
    is equivalent to (\ a b -> not $ a == b)
#+end_src

***** <<<Test Commutative property>>>
Commutativity
#+begin_src haskell
:: Arbitrary a => (a -> a -> a) -> Property
#+end_src

***** <<<Test Symmetry property>>>
Symmetry
#+begin_src haskell
:: Arbitrary a => (a -> a -> Bool) -> Property
#+end_src

***** <<<Test Equivalence property>>>
Equivalence
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (a -> b) -> Property
#+end_src

***** <<<Test Inverse property>>>
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (b -> a) -> Property
#+end_src

**** <<<QuickCheck>>>
=Target= is a member of the Arbitrary type class.
=Target -> Bool= is something =Testable=. This properties can be complex.
Generator =arbitrary= gets the seed, and produces values of =Target=.
Function =quickCheck= runs the loop and tests that generated =Target= values always comply the property.

***** Manual automation with QuickCheck properties

#+begin_src haskell
import Test.QuickCheck
import Test.QuickCheck.Function
import Test.QuickCheck.Property.Common
import Test.QuickCheck.Property.Functor
import Test.QuickCheck.Property.Common.Internal

data Four' a b = Four' a a a b
  deriving (Eq, Show)

instance Functor (Four' a) where
  fmap f (Four' a b c d) = Four' a b c (f d)

instance (Arbitrary a, Arbitrary b) ⇒ Arbitrary (Four' a b) where
  arbitrary = do
    a1 ← arbitrary
    a2 ← arbitrary
    a3 ← arbitrary
    b ← arbitrary
    return (Four' a1 a2 a3 b)

-- Wrapper around `prop_FunctorId`
prop_AutoFunctorId ∷ Functor f ⇒ f a → Equal (f a)
prop_AutoFunctorId = prop_FunctorId T

type Prop_AutoFunctorId f a
  = f a
  → Equal (f a)

-- Wrapper around `prop_AutoFunctorCompose`
prop_AutoFunctorCompose ∷ Functor f ⇒ Fun a1 a2 → Fun a2 c → f a1 → Equal (f c)
prop_AutoFunctorCompose f1 f2 = prop_FunctorCompose (applyFun f1) (applyFun f2) T

type Prop_AutoFunctorCompose structureType origType midType resultType
  = Fun origType midType
  → Fun midType resultType
  → structureType origType
  → Equal (structureType resultType)

main = do
  quickCheck $ eq $ (prop_AutoFunctorId ∷ Prop_AutoFunctorId (Four' ())Integer)
  quickCheck $ eq $ (prop_AutoFunctorId ∷ Prop_AutoFunctorId (Four' ()) (Either Bool String))
  quickCheck $ eq $ (prop_AutoFunctorCompose ∷ Prop_AutoFunctorCompose (Four' ()) String Integer String)
  quickCheck $ eq $ (prop_AutoFunctorCompose ∷ Prop_AutoFunctorCompose (Four' ()) Integer String (Maybe Int))
#+end_src

*** Write tests algorithm

1. Pick the right language/stack to implement features.
2. How expensive breakage can be.
3. Pick the right tools to test this.

** <<<Thunk>>> :drill:
:PROPERTIES:
:ID:       bd66aa1b-4a01-445d-bca2-48dc193e5657
:END:

Value that is yet to be evaluated. Can be dragged around, until be lazily evaluated.

** <<<Uncurry>>> :drill:
:PROPERTIES:
:ID:       c24534d9-0a6b-4e76-9925-bc25496bbfdd
:END:

Replace number of functions with tuple of number of values

** <<<Undefined>>> :drill:
SCHT: <2019-09-03 Tue>
:PROPERTIES:
:ID:       c2bc65ee-1d9b-4633-9aa1-780fa07752a8
:DRILL_LAST_INTERVAL: 41.7947
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 13:54]
:END:

Placeholder value that helps to do typechecking.

** <<<Unit>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       8c2d205c-140f-4aa6-bcd4-8563433879d9
:DRILL_LAST_INTERVAL: 10.3376
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:46]
:END:

Value, type. Represents nothing. Empty tuple
#+begin_src haskell
()
#+end_src

** <<<Variable>>> :drill:
:PROPERTIES:
:ID:       1362e457-cca3-44c3-b5a4-24111d56d71c
:END:

A name for expression.

Haskell has immutable variables.
Except when you hack it with explicit funсtions.

*** /*/
<<<Variables>>>

** <<<Zero>>> :drill:
SCHT: <2019-07-30 Tue>
:PROPERTIES:
:ID:       403807c4-a2de-47ca-bdee-96b8b47994c2
:DRILL_LAST_INTERVAL: 28.7036
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-01 Mon 18:11]
:END:

/*/ is the value with which operation always yelds Zero value.
$$ zero, n \in C : \forall n, zero*n=zero $$

/*/ is distinct from Identity value.

** <<<Modular arithmetic>>> :drill:
:PROPERTIES:
:ID:       dcfa0301-d300-4efd-97b5-510b705012cc
:END:

System for integers where numbers wrap around the certain values (single - /modulus/, plural - /moduli/).

Example - 12-hour clock.

*** /*/
<<<Clock arithmetic>>>

** <<<Property>>> :drill:
:PROPERTIES:
:ID:       ead179a8-e4a5-46c1-a324-30e8e4dd15fd
:END:

Something has a property in the real world, and in theory its property corresponds to the law/laws, axioms.

In Haskell under property/law most often properties of algebraic structures.

There property testing wich does what it says.

*** /*/
<<<Properties>>>

*** <<<Associative law>>> :drill:
:PROPERTIES:
:ID:       0985ce00-f1cd-441b-9d49-7c02b51298bf
:END:

Joined with common purpose.

$$ P(a,P(b,c)) \equiv P(P(a,b),c) \ | \ \forall (a,b,c) \in S $$,

Etymology:
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".

**** /*/
<<<Associativity>>>
<<<Associative>>>

*** <<<Left associative>>> :drill:
SCHT: <2019-07-24 Wed>
:PROPERTIES:
:ID:       ccf220ac-e213-44ce-9d1b-ccd87f8b9a9a
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:02]
:END:

Same level expression parts in reality follow grouping from left to right.
$$ (\lambda x . x)(\lambda y . y)z \equiv ((\lambda x . x)(\lambda y . y))z $$

*** <<<Basis>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       c880a358-f545-4e2e-9c44-7c80ca038ac1
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 00:10]
:END:

$$ \beta\alpha\sigma\iota\varsigma $$ - stepping

The initial point, unreducible axioms and terms that spawn a theory.
AKA see Category theory, or Euclidian geometry basis.

*** <<<Commutativity>>> :drill:
:PROPERTIES:
:ID:       8d6b1e5e-a054-4757-b9a8-bb40c07d79fd
:END:

$$ \forall (a,b) \in S : \; P(a,b) \equiv P(b,a) $$

**** /*/
<<<Commutative>>>
<<<Commutative law>>>

*** <<<Idempotence>>> :drill:
:PROPERTIES:
:ID:       1c821458-dd2b-4112-aa32-416e27b161ba
:END:

First application gives a result. Then same operation can be applied multiple times without changing the result.
Example: Start and Stop buttons on machines.

**** /*/
<<<Idempotent>>>
<<<Idempotency>>>

** <<<Backpack>>> :drill:
:PROPERTIES:
:ID:       bb77bcce-6d34-408e-bbc8-ad16e843eeb1
:END:

On first compilation - /*/ analyzes the abstract signatures without loading side modules, doing the type check with assumption that modules provide right type signatures, and process does not emitt any binary code. Storing the intermediate code in a special form that allows flexibily connect modules provided. That allows later to compile project with particular instanciations of the modules, major work being done by internal Cabal Backpack support and Backpack system that modifies the intermediate code to fit the module.

** <<<Nullary>>> :drill:
:PROPERTIES:
:ID:       009d9f43-81a1-4e7e-a5be-ad706a704497
:END:

Taking no entries; having the arity of zero.
Having trivial domain.

** <<<Arbitrary>>> :drill:
:PROPERTIES:
:ID:       3fd8d537-ab00-4989-bbde-5a62a34c3bfa
:END:

/arbitrarius/ uncertain

* Give definitions

** <<<Commuting diagram>>>

** <<<Const functor>>>

** <<<Free object>>>
When this object/property autofollows from rules&axioms.

** <<<Thin category>>>

** <<<Identity type>>>

** <<<Constant type>>>

** <<<Gen>>>

** <<<ST-Trick monad>>>
ST is like a lexical scope, where all the variables/state disappear when the function returns
https://wiki.haskell.ohttps://www.schoolofhaskell.com/school/to-infinity-and-beyond/older-but-still-interesting/deamortized-strg/Monad/ST
https://dev.to/jvanbruegge/what-the-heck-is-polymorphism-nmh

*** /*/
<<<ST-Trick>>>

** <<<Lax monoidal functor>>>

** <<<Tensorial strength>>>

** <<<Strong monad>>>

** <<<Either>>>
Allows to separate and preserve information about happened, ex. error handling.

*** /*/
<<<Either data type>>>

** <<<Weak head normal form>>>

*** /*/
<<<WHNF>>>

** <<<Function image>>>

*** /*/
<<<Image>>>

** <<<Maybe>>>

** <<<Inverse>>>
1. Inverse function

2. In logic: $$ P \to Q \Rightarrow \neg P \to \neg Q $$, & same for category duality.

** <<<Inversion>>>
1. Is a permutation where two elements are out of order.

2. See Inverse

** <<<Inverse function>>>

    $$ f_{x \to y} \circ ({f_{x \to y}})^{-1} = {1}_{x} $$

/*/ $$ \iff $$ function is bijective.
Otherwise - partial inverse

** <<<Inverse morphism>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       97593115-a31b-4016-8de4-9356b4a89991
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

$$ f \circ g = 1^{x}, g \circ f = 1^{y} $$.

** <<<Invertible>>>
** <<<Invertibility>>>
** <<<Partial inverse>>>
/*/ when function is now bijective. When bijective see inverse function.

** <<<Define LANGUAGE pragma options>>>

*** <<<ExistentialQuantification>>>

*** <<<GADTs>>>

*** <<<GeneralizedNewTypeClasses>>>

*** <<<FuncitonalDependencies>>>

** <<<GHC debug keys>>>

*** <<<-ddump-ds>>>
Dump desugarer output.

**** /*/
<<<Desugar>>>
<<<GHC desugar>>>

** <<<GHC optimize keys>>>

*** <<<-foptimal-applicative-do>>>
$$ O(n^3) $$
Always finds optimal reduction into <*> for ApplicativeDo do notation.

** <<<GHC check keys>>>

*** <<<-Wno-partial-type-signatures>>>
Supresses PartialTypeSignatures wildcard infer warning.

** <<<Generalised algebraic data types>>>
LANGUAGE GADTs

*** /*/
<<<GADT>>>

** <<<Order theory>>>
Investigates in thepth the intuitive notion of order using binary relations.

*** <<<Domain theory>>>
Formalizes approximation and convergense.
Has close relation to Topology.

*** <<<Lattice>>>
Abstract structure that consists of partially ordered set, where every two elements have unique supremum and infinum. == /*/ algebraic structure satisfying certain axiomatic identities.
/*/ order-theory & algebraic.

*** <<<Order>>>

**** <<<Preorder>>>
R^{X \to X} : Reflexive & Transitive:
$$ aRa $$
$$ aRb, bRc \Rightarrow aRc $$

Generalization of equivalence relations partial orders.

/*/ Antisymmetric \Rightarrow Partial ordering.
/*/ Symmetric \Rightarrow Equivalence.

***** <<<Total preorder>>>

$$ \forall a,b : a \le b \lor b \le a $$ \Rightarrow Total Preorder.

**** <<<Partial order>>>
A binary relation must be reflexive, antisymmetric and transitive.

Partial - not every elempents between them need to be comparable.

Good example of /*/ is a genealogical descendancy. Only related people produce relation, not related do not.

***** /*/
<<<Partial orders>>>
<<<Partially ordered set>>>
<<<Partially ordered sets>>>
<<<Poset>>>
<<<Posets>>>

*** <<<Partial order>>>

*** <<<Total order>>>

** <<<Universal algebra>>>
Studies algebraic structures.

** <<<Relation>>>

*** <<<Reflexivity>>>
$$ R^{X \to X}, \forall x \in X : x R x $$
Order theory: $$ a \le a $$

/*/ - each element is comparable to itself.

Corresponds to Identity and Automorphism.

**** /*/
<<<Reflexive>>>
<<<Reflexive relation>>>

*** <<<Irreflexivity>>>
$$ R^{X \to X}, \forall x \in X : \nexists R(x, x) $$

**** /*/
<<<Anti-reflexive>>>
<<<Anti-reflexive relation>>>
<<<Irreflexive>>>
<<<Irreflexive relation>>>

*** <<<Transitivity>>>
$$ \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc $$

/*/ - the start of a chain of precedence relations must precede the end of the chain.

**** /*/
<<<Transitive>>>
<<<Transitive relation>>>

*** <<<Symmetry>>>
$$ \forall a,b \in X : (aRb \iff bRa) $$

**** /*/
<<<Symmetric>>>
<<<Symmetric relation>>>

*** <<<Equivalence>>>
| Reflexive                  | Symmetric                        | Transitive                                      |
|----------------------------+----------------------------------+-------------------------------------------------|
| $$ \forall x \in X, \exists R : x R x $$ | $$ \forall a,b \in X : (aRb \iff bRa) $$ | $$ \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc $$ |
| $$ a = a $$                | $$ a = b \iff b = a $$           | $$ a = b, b = c \Rightarrow a = c $$                      |

**** /*/
<<<Equivalent>>>
<<<Equivalent relation>>>

*** <<<Antisymmetry>>>
$$ \forall a, b \in X : aRb, bRa \Rightarrow a = b $$ ~ $$ aRb, a \ne b \Rightarrow \nexists bRa $$.
Antisymmetry does not say anything about $$ R(a,a) $$.

/*/ - no two different elements precede each other.

**** /*/
<<<Antisymmetric>>>
<<<Antisymmetric relation>>>

*** <<<Asymmetry>>>
$$ \forall a,b \in X (aRb \Rightarrow \neg (bRa)) $$
/*/ $$ \iff $$ Antisymmetric \land Irreflexive.
Asymmetry \ne "not symmetric"
Symmetric \land Asymmetric is only empty relation.

**** /*/
<<<Asymmetric>>>
<<<Asymmetric relation>>>

** <<<Cryptomorphism>>>
Equivalent, interconvertable with no loss of information.

*** /*/
<<<Crypromorphic>>>

** <<<Lexically scoped type variables>>>
Enable lexical scope for forall quantifier defined type variables

Implemented in ScopedTypeVariables

** <<<Abstract data type>>>
Several definitions here, reduce them.

Data type mathematical model, defined by its semantics from the user point of view, listing possible values, operations on the data of the type, and behaviour of these operations.

/*/ class of objects whose logical behaviour is defined by a set of values and set of operations (analogue to algebraic structure in mathematics).

A specification of a data type like a stack or queue where the specification does not contain any implementation details at all, only the operations for that data type. This can be thought of as the contract of the data type. 

*** /*/
<<<AbsDT>>>

** <<<ADT>>> :drill:
:PROPERTIES:
:ID:       9fdd9acf-b98d-469d-b34f-c4c007177135
:END:

1. Abstract data type
2. Algebraic data type

** <<<Concrete type>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       736674fb-45a3-4539-8774-7ccf419b5487
:DRILL_LAST_INTERVAL: 10.352
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:50]
:END:

Fully defined & non-polymorphic type.

** <<<Functional dependencies>>>

** <<<MonoLocalBinds>>>

** <<<KindSignatures>>>

** <<<ExplicitNamespaces>>>

** <<<Combinator pattern>>>

** <<<Symbolic expression>>> :drill:
:PROPERTIES:
:ID:       62a62e62-5b76-42d5-a971-9b9d3f72ec8f
:END:

Nested tree data structure.
Introduced used in Lisp. In Lisp code and data are a /*/.

/*/ in Lisp: Atom or expression of the form =(x . y)=, =x= and =y= are /*/.

Modern abbriviated notation of /*/: =(x y)=.

*** /*/
<<<S-expression>>>
<<<S-expressions>>>
<<<Sexpression>>>
<<<Sexpressions>>>
<<<Sexp>>>
<<<Sexps>>>
<<<Sexpr>>>
<<<Sexprs>>>


** <<<Polynomial>>> :drill:
:PROPERTIES:
:ID:       2d7eeed7-766f-4261-8976-dffc939794b0
:END:

Expression consisting of:
  * variables
  * coefficients
  * addition
  * substraction
  * multiplication (including positive integer variable exponentiation)

Polynomials forms a ring. Polynomial ring.

*** /*/
<<<Polynomials>>>

** <<<Data family>>>
:PROPERTIES:
:ID:       a1a5a51c-bd64-41dd-8162-2bf25b9dccc4
:END:

Indexed form of data and newtype definitions.

** <<<Type synonym family>>>
:PROPERTIES:
:ID:       db5fa6be-f1fc-4baa-b31b-0b7520fe2b2a
:END:

Indexed form of type synonyms.

** <<<Indexed type family>>>
:PROPERTIES:
:ID:       db9d2215-e851-4257-90bb-26a03647663b
:END:

/*/ additional stucture in language that allows ad-hoc overloading of data types. AKA are to types as type class to methods.

Variaties:
  * data family
  * type synonym families

Defined by pattern matching the partial functions between types.
Associates data types by type-level function defined by open-ended collection of valid instances of input types and corresponding output types.

Normal type classes define partial functions from types to a collection of named values by pattern matching on the input types, while type families define partial functions from types to types by pattern matching on the input types. In fact, in many uses of type families there is a single type class which logically contains both values and types associated with each instance. A type family declared inside a type class is called an associated type.

*** /*/
<<<Type family>>>

** <<<TypeFamilies>>>
SCHT: <2019-07-17 Wed>
:PROPERTIES:
:ID:       8bd84ba4-4ba0-4907-a19e-1312d2e4ab22
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:12]
:END:

Allow use and definition of indexed type families and data families.

/*/ are type-level programming.
/*/ are overload data types in the same way that type classes overload functions.
/*/ allow handling of dependent types. Before it Functional dependencies and GADTs were used to solve that.
/*/ useful for generic programming, creating highly parametrised interfaces for libraries, and creating interfaces with enhanced static iformation (much like dependent types).

Implies: MonoLocalBinds, KindSignatures, ExplicitNamespaces

Two types of /*/ are:


** <<<Error>>>
:PROPERTIES:
:ID:       0f11555b-90c5-4374-8bb9-6e195cd2df39
:END:

Mistake in the program that can be resolved only by fixing the program.

=error= is a sugar for =undefined=.

Distinct from Exception.

** <<<Exception>>>
:PROPERTIES:
:ID:       06ad9cca-a768-498c-906a-dab3ff922217
:END:

Expected but irregular situation.

Distinct from Error. Also see <<<Exception vs Error>>>

** <<<ConstraintKinds>>>
SCHT: <2019-07-21 Sun>
:PROPERTIES:
:ID:       39b1ef68-42be-4430-b7ca-c8a1fc511622
:DRILL_LAST_INTERVAL: 3.855
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:END:

Constraints are just handled as types of a particular kind (Constraint).
Any type of the kind Constraints can be used as a constraint.
  * Anything which is already allowed in code as a constraint without /*/. Saturated applications to type classes, implicit parameter and equality constraints.
  * Tuples, all of whose component types have kind Constraint.
  #+begin_src haskell
  type Some a = (Show a, Ord a, Arbitrary a) -- is of kind Constraint.
  #+end_src
  * Anything form of which is not yet known, but the user has declared for it to have kind Constraint (for which they need to import it from GHC.Exts):
  #+begin_src haskell
  Foo (f :: Type -> Constraint) = forall b. f b => b -> b -- is allowed
  -- as well as examples involving type families:
  type family Typ a b :: Constraint
  type instance Typ Int  b = Show b
  type instance Typ Bool b = Num b

  func :: Typ a b => a -> b -> b
  func = ...
  #+end_src

* Citations

"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))

* Good code :drill:
:PROPERTIES:
:ID:       0061ec53-dc1b-40a8-a00a-f07fd4213be2
:END:

** <<<Good: Type aliasing>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       db5d6252-f9b1-4c2e-ab00-a4a99d026c2a
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

Use data type aliases to deferentiate logic of values.

** <<<Good: Type wideness>>> :drill:
SCHT: <2019-07-22 Mon>
:PROPERTIES:
:ID:       f84197b4-6d5d-4f8f-bb4d-3c6a1460a37b
:DRILL_LAST_INTERVAL: 21.9724
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:14]
:END:

Wider the type the more it is polymorphic, means it has broader application and fits more types.

Concrete type fits only to itself.

The more constrained system has more usefulness.

Unconstrained means most flexible, but also most useless.

Parametric polymorphism is broader then constrained polymorphism

The widest type in current circumstances named principal type.

** <<<Good: Read Conventions of variables (page 176)>>> :drill:
:PROPERTIES:
:ID:       6dc2fbe3-f3de-4a52-97d5-dc001e59869c
:END:

** <<<Good: Print>>> :drill:
:PROPERTIES:
:ID:       1d0f6f0e-2d81-4c35-a9b3-a362557121f2
:END:

print :: Show a => a -> IO ()
print a = putStrLn (show a)

** <<<Good: Read code evaluation (488 on-ward)>>> :drill:
:PROPERTIES:
:ID:       e2222b7e-75c8-4c75-98b2-9d99167232c3
:END:

** <<<Good: Fold>>> :drill:
:PROPERTIES:
:ID:       e646277c-54f3-47c4-b721-b3721acc6a6f
:END:

foldr spine recursion intermediated by the folding
foldl spine folding is unconditional, then solding starts.

So foldr can terminate at any point, while foldl unconditionally recurses across the spine, even if it infinite.

** <<<Good: Computation model>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       a6b88a42-c287-47ae-9db0-f7c2aa0d0cd3
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:52]
:END:

Model the domain and types before thinking about how to write computations.

** <<<Good: Make bottoms only local>>> :drill:
:PROPERTIES:
:ID:       8d96eb06-0984-4325-a447-4e751ff820e0
:END:

** <<<Good: Newtype wrap is ideally transparent for compiler and does not change performance>>> :drill:
:PROPERTIES:
:ID:       0a8b1bec-1a25-42e0-b137-232fb01b25d7
:END:

** <<<Good: Instances of types/type classes must go with code you write>>> :drill:
:PROPERTIES:
:ID:       2bafb381-43ce-44b0-9abf-ffa1f3f0c6e1
:END:

** <<<Good: Functions can be abstracted as arguments>>> :drill:
:PROPERTIES:
:ID:       714c9ca5-052c-4c5b-b3c6-fcd7741250b0
:END:

** <<<Good: Infix operators can be bind to arguments>>> :drill:
:PROPERTIES:
:ID:       defb1467-4b50-451b-8fb3-ab12af4409af
:END:

** <<<Good: Arbitrary>>> :drill:
SCHT: <2019-07-25 Thu>
:PROPERTIES:
:ID:       7c3cb682-9b20-471b-9483-7a22c3ec468d
:DRILL_LAST_INTERVAL: 25.0
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:23]
:END:

Product types can be tested as a product of random generators.
Sum types require to implement generators with separate constructors, and picking one of them, use `oneof` or `frequency` to pick generators.

** <<<Good: Principle of Separation of concerns>>> :drill:
:PROPERTIES:
:ID:       a07f55f7-1a15-4aa9-b8c8-fb58149924d7
:END:

** <<<Good: Function composition>>> :drill:
:PROPERTIES:
:ID:       ade1516e-44f1-4a8e-bfe4-5b773d0f27d6
:END:

In Haskell inline composition requires:
#+begin_src haskell
  h.g.f $ i
#+end_src
Function application has a higher priority than composition. That is why parentheses over argument are needed.
This precedence allows idiomatically compose partially applied functions.

But it is a way better then:
#+begin_src haskell
  h (g (f i))
#+end_src

** <<<Good: Point-free>>> :drill:
:PROPERTIES:
:ID:       62f8356a-69a2-46e9-ab0f-1a9b5bdfe797
:END:

Use Tacit very carefully - it hides types and harder to change code where it is used.
Use just enough Tacit to communicate a bit better. Mostly only partial point-free communicates better.

*** <<<Good: Point-free is great in multi-dimentions>>> :drill:
SCHT: <2019-08-03 Sat>
:PROPERTIES:
:ID:       0eb49ad1-9992-4707-88c8-64ff7f8c3cbb
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-23 Tue 14:03]
:END:

BigData and OLAP analysis.

** <<<Good: Functor application>>> :drill:
SCHT: <2019-07-23 Tue>
:PROPERTIES:
:ID:       67dab545-6f12-4d3a-b8c7-acfc0f267d03
:DRILL_LAST_INTERVAL: 11.0911
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-12 Fri 23:44]
:END:

Function application on n levels beneath:
#+begin_src haskell
(fmap.fmap) function twoLevelStructure
#+end_src

How fmap.fmap typechecks:
#+begin_src haskell
(.)         :: (b -> c) -> (a -> b) -> a -> c
fmap        :: Functor f => (m -> n) -> f m -> f n
fmap        :: Functor g => (x -> y) -> g x -> g y

fmap . fmap :: (Functor f, Functor g)
              => ((g x -> g y) -> f . g x -> f . g y)
              -> ((  x ->   y) ->     g x  ->    g y)
              -> (   x ->   y) -> f . g x -> f . g y
fmap . fmap ::   (x    ->   y) -> f . g x -> f . g y
#+end_src

** <<<Good: Parameter order>>> :drill:
:PROPERTIES:
:ID:       05494702-c932-47ef-a91b-6ffd27a6b51f
:END:

In functions parameter order is important.
It is best to use first the most reusable parameters.
And as last one the one that can be the most variable, that is important to chain.

** <<<Good: Applicative monoid>>> :drill:
:PROPERTIES:
:ID:       e417b5f0-fc63-45e0-971a-68b2c6ae4d22
:END:

There can be more then one valid Monoid for a data type. &&
There can be more than one valid Applicative instance for a data type. ->
There can be differnt Applicatives with different Monoid implementations.

** <<<Good: Creative process>>> :drill:
:PROPERTIES:
:ID:       b5b69b79-144b-49f0-a997-ed7c056e182b
:END:

*** Pick phylosophy principles one to three the more - the harder the implementation

*** Draw the most blurred representation

*** Deduce abstractions and write remotely what they are

*** Model of computation

**** Model the domain

**** Model the types

**** Think how to write computations

*** Create

** <<<Good: About operators (<$) (**>) (<**) (>>)>>> :drill:
SCHT: <2019-08-15 Thu>
:PROPERTIES:
:ID:       25e19a69-21f7-435a-b2ff-f1a489e9a159
:DRILL_LAST_INTERVAL: 20.6501
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-07-25 Thu 23:02]
:END:

Where character is not present - discards the according value.

** <<<Good: About operators mapM_ sequence_>>> :drill:
:PROPERTIES:
:ID:       03ad3fac-221c-42de-8b63-e7ccf645f183
:END:

Trailing /_/ means ignoring the result.

** <<<Good: Guideliles>>> :drill:
:PROPERTIES:
:ID:       30bdcb7b-27f5-4d34-993d-d4a710d41969
:END:

*** Wiki.haskell

**** Documentation

***** Comments write in application terms, not technical.

***** Tell what code needs to do not how it does.

**** Haddoc

***** Put haddock comments to ever exposed data type and function.

***** Haddock header
#+begin_src haskell
{- |
Module      :  <File name or $Header$ to be replaced automatically>
Description :  <optional short text displayed on contents page>
Copyright   :  (c) <Authors or Affiliations>
License     :  <license>

Maintainer  :  <email>
Stability   :  unstable | experimental | provisional | stable | frozen
Portability :  portable | non-portable (<reason>)

<module description starting at first column>
-}
#+end_src

**** Code

***** Try to stay closer to portable (Haskell98) code

***** Try make lines no longer 80 chars

***** Last char in file should be newline

***** Symbolic infix identifiers is only library writer right

***** Every function does one thing.

** <<<Good: Use Typed holes to progress the code>>> :drill:
:PROPERTIES:
:ID:       27c029f7-9299-4d74-b2e3-5064b57dce4a
:END:

Typed holes help build code in complex situations.

** <<<Good: Haskell has infinite terms not not infinite types.>>> :drill:
:PROPERTIES:
:ID:       6299a8fe-2bb5-4d63-94a6-4aa8561027ad
:END:

That is why infinite types throw infinite type error.

** <<<Good: Use type sysnonims to differ the information>>> :drill:
SCHT: <2019-07-26 Fri>
:PROPERTIES:
:ID:       43181c5d-630a-4b5d-815c-272e26c8e42f
:DRILL_LAST_INTERVAL: 26.1438
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.75
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-30 Sun 15:22]
:END:

Even if there is types - define type synonims. They are free.
That distinction with synonims, would allow TypeSynonymInstances, which would allow to create a diffrent type class instances and behaviour for different information.

** <<<Good: Control.Monad.Error -> Control.Monad.Except>>> :drill:
:PROPERTIES:
:ID:       4ba41ec2-5115-4be9-9aa4-4892322db1e8
:END:

** <<<Good: Monad OR Applicative>>>

**** Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>='
If you wrote code and really needed only those - move that code to Applicative.
#+begin_src haskell
return -> pure
ap -> <*>
liftM -> liftA -> <$>
>> -> *>
#+end_src

**** Basic case when Applicative can be used
Can be rewriten in Applicative:
#+begin_src haskell
func = do
  a <- f
  b <- g
pure (a, b)
#+end_src

Can't be rewritten in Applicative:
#+begin_src haskell
somethingdoSomething' n = do
a <- f n
b <- g a
pure (a, b)
#+end_src
(f n) creates monadic structure, binds ot to /a/ wich is consumed then by g.

**** Applicative block vs Monad block
With Type Applicative every condition fails/succseeds independently. It needs a boilerplate data constructor/value pattern matching code to work. And code you can write only for so many cases and types, so boilerplate can not be so flexible as Monad that allows polymorphism.
With Type Monad computation can return value that dependent from the previous computation result. So abort or dependent processing can happen.

** <<<Good: Haskell Package Versioning Policy>>>
Version policy and dependency management.

#+DOWNLOADED: https://pvp.haskell.org/pvp-decision-tree.svg @ 2019-06-17 15:49:21
[[file:Good_code/pvp-decision-tree_2019-06-17_15-49-21.svg]]

*** /*/
<<<PVP>>>
<<<Good: PVP>>>

** <<<Good: Linear type>>> :drill:
:PROPERTIES:
:ID:       820c915d-e3fe-4ff5-acb3-9ef205f70639
:END:
Linear types are great to control/minimize resource usage.

** <<<Good: Exception vs Error>>> :drill:
:PROPERTIES:
:ID:       3d6d7f0f-252c-4cfb-b25c-18687fd762ca
:END:

Many languages and Haskell have it all mixup. Here is table showing what belongs to one or other in standard libraries:

|-----------+---------------------------------------------------------------------------------------------|
| Exception | Prelude.catch, Control.Exception.catch, Control.Exception.try, IOError, Control.Monad.Error |
| Error     | error, assert, Control.Exception.catch, Debug.Trace.trace                                   |

** <<<Good: Let vs. Where>>> :drill:
:PROPERTIES:
:ID:       4ded4b6f-3593-4203-88a6-ce1b6f5fa71e
:END:

=let ... in ...= is a separate expression. In contrast, =where= is bound to a surrounding syntactic construct (namespace).

* Bad code :drill:
:PROPERTIES:
:ID:       e60a3084-2f70-4363-8f47-6df2e610d4ad
:END:

** <<<Bad pragma>>>

*** Bad: Dangerous LANGUAGE pragma option

  - DatatypeContexts
  - OverlappingInstances
  - IncoherentInstances
  - ImpredicativeTypes
  - AllowAmbigiousTypes

Mine addition:
  - UndecidableInstances - often

* Useful functions to remember

** Prelude
#+begin_src haskell
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
#+end_src

*** Ord
compare

*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo

*** List operations
#+begin_src haskell
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
#+end_src

** Data.List
#+begin_src haskell
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
#+end_src

** Data.Char
#+begin_src haskell
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
#+end_src

** QuickCheck
#+begin_src haskell
quickCheck :: Testable prop => prop -> IO ()

quickCheck . verbose - run verbose mode
#+end_src

* Investigate
* Tools :drill:
:PROPERTIES:
:ID:       756dd451-6df6-4c86-8ff8-b431f2943685
:END:

** ghc-pkg

List installed packages:
#+begin_src fish
ghc-pkg list
#+end_src

** Search over the Haskell packages code: Codesearch from Aelve
https://codesearch.aelve.com/

** Integration of NixOS/Nix with Haskell IDE Engine (HIE) and Emacs (Spacemacs)
:PROPERTIES:
:ID:       cd7eefc7-9fed-4ea0-8273-17ef478265f2
:END:

*** 1. Install the Cachix: https://github.com/cachix/cachix

*** 2. Install HIE on NixOS: https://github.com/infinisil/all-hies/#cached-builds

**** 2.1. Cached builds

#+begin_src fish
cachix use all-hies
#+end_src

**** 2.2. NixOS installation:

#+begin_src nix
{ config, pkgs, ... }:

let

  all-hies = import (fetchTarball "https://github.com/infinisil/all-hies/tarball/master") {};

in {
  environment.systemPackages = with pkgs; [

    (all-hies.selection { selector = p: { inherit (p) ghc865 ghc864; }; })

  ];
}
#+end_src

Insert your GHC versions.

**** 2.3. Switch to new configuration:

#+begin_src fish
sudo -i nixos-rebuild switch
#+end_src

*** 3. Emacs (Spacemacs) configuration:

#+begin_src elisp

  dotspacemacs-configuration-layers
  '(

    auto-completion

    (lsp :variables
         default-nix-wrapper (lambda (args)
                               (append
                                (append (list "nix-shell" "-I" "." "--command" )
                                        (list (mapconcat 'identity args " "))
                                        )
                                (list (nix-current-sandbox))
                                )
                               )

         lsp-haskell-process-wrapper-function default-nix-wrapper
         )

    (haskell :variables
             haskell-enable-hindent t
             haskell-completion-backend 'lsp
             haskell-process-type 'cabal-new-repl
             )

  )


   dotspacemacs-additional-packages '(
                                      direnv
                                      nix-sandbox
                                      )

#+end_src

Where:

=auto-complettion= configures =YASnippet=.

=nix-sandbox= (https://github.com/travisbhartwell/nix-emacs) has a great helper functions. Using =nix-current-sandbox= function in =default-nix-wrapper= that used to properly configure =lsp-haskell-process-wrapper-function=.

Configuration of the =lsp-haskell-process-wrapper-function default-nix-wrapper= is a key for HIE to work in =nix-shell=

Inside =nix-shell= the =haskell-process-type 'cabal-new-repl= is required.

/Configuration was reassembled from: https://github.com/emacs-lsp/lsp-haskell/blob/8f2dbb6e827b1adce6360c56f795f29ecff1d7f6/lsp-haskell.el#L57 & its authors config: https://github.com/sevanspowell/dotfiles/blob/master/.spacemacs /

Refresh Emasc.

*** 4. Open the Haskell file from a project

Open system monitor, observe the process of environment establishing, packages loading & compiling.

*** 5. Be pleased writing code

[[file:images/Screenshot_20190727_134446.png]]

Now, the powers of the Haskell, Nix & Emacs combined. It's fully in your hands now. Be cautious - you can change the world.

*** 6. (optional) Debugging

1. If recieving sort-of:

#+begin_src text
readCreateProcess : cabal-helper-wrapper failure
#+end_src

HIE tries to run =cabal= operations like on the non-Nix system. So it is a problem with detection of =nix-shell= environment, running inside it.

2. If HIE keeps getting ready, failing & restarting - check that the projects =ghc --version= is declared in your =all-hie= NixOS configuration.

** Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

Breakpoints
#+begin_src text
:break 2
  :show breaks
  :delete 0
:continue
#+end_src

Step-by-step
#+begin_src text
:step main
#+end_src

List information at the breakpoint
#+begin_src text
:list
#+end_src

What been evaluated already
#+begin_src text
:sprint name
#+end_src

* Libs :drill:
:PROPERTIES:
:ID:       dfc5ca16-c4ee-4ef5-bee6-b44a4b29f51d
:END:

** Exceptions

*** Exceptions - optionally pure extensible exceptions that are compatible with the mtl
*** Safe-exceptions - safe, simple API equivalent to the underlying implementation in terms of power, encourages best practices minimizing the chances of getting the exception handling wrong. 
*** Enclosed-exceptions - capture exceptions from the enclosed computation, while reacting to asynchronous exceptions aimed at the calling thread.

** Memory management

*** membrain - type-safe memory units

** Parsers - megaparsec

** CLIs - optparse-applicative

** HTML - Lucid

** Web applications - Servant

** IO libraries

*** Conduit - practical, monolythic, guarantees termination return

*** Pipes + Pipes Parse - modular, more primitive, theoretically driven

** JSON - aeson

* Reference

** <<<Functor-Applicative-Monad Proposal>>> :drill:
:PROPERTIES:
:ID:       bfe7e9bf-1683-433d-949f-0c4240226074
:END:

Well known historical even in Haskell: https://github.com/quchen/articles/blob/master/applicative_monad.md.

Math justice was restored with a RETroactive CONtinuity. Invented in computer science term Applicative (lax monoidal functor) become a superclass of Monad.

& that is why:
  * =return = pure=
  * =ap = <*>=
  * =>> = *>=
  * =liftM = liftA = fmap=
  * =liftM* = liftA*=

Also, a side-kick - Alternative became a superclass of MonadPlus. Hense:
  * =mzero = empty=
  * =mplus = (<|>)=

*** /*/
<<<Applicative-Monad proposal>>>
<<<AMP>>>

** Haskell-98

*** <<<Old instance termination rules>>>

  1. \forall class constraint (C t1 .. tn):
    1.1 type variables have occurances \le head
    1.2 constructors+variables+repetitions < head
    1.3 \not type functions (type func application can expand to arbitrary size)
 2. \forall functional dependencies, ⟨tvs⟩_left \to ⟨tvs⟩_right, of the class, every type variable in S(⟨tvs⟩_right) must appear in S(⟨tvs⟩_left), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.
* Liturgy
λειτ       <- λαός  /Laos/       the people
    ουργός <- ἔργο  /ergon/      work
λειτουργία          /leitourgia/ giving back to the community

The life is beautiful.
For all humans that make the life have more uniqueness.

This study would not be possible without matematicians, Haskellers, scientists, creators, contributors. These people are the most fascinating in my life.

Special acollades for the guys at Serokell. They was the forse that got me inspired & gave resources to seriously learn Haskell and create this pocket guide.
