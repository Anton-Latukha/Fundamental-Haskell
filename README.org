#+startup: latexpreview
#+startup: entitiespretty
* Contents :TOC:
- [[#definitions][Definitions]]
  - [[#abelian-category][Abelian category]]
  - [[#abstraction][Abstraction]]
  - [[#actual-type][Actual type]]
  - [[#algebra][Algebra]]
  - [[#alpha-equivalence][Alpha equivalence]]
  - [[#ambigram][Ambigram]]
  - [[#anamorphism][Anamorphism]]
  - [[#application][Application]]
  - [[#application-memory][Application memory]]
    - [[#][/*/]]
      - [[#heap][Heap]]
      - [[#stack][Stack]]
  - [[#applicative][Applicative]]
    - [[#applicative-laws][Applicative laws]]
      - [[#applicative-identity-law][Applicative identity law]]
      - [[#applicative-composition-law][Applicative composition law]]
      - [[#applicative-homomorphism-law][Applicative homomorphism law]]
      - [[#applicative-interchange-law][Applicative interchange law]]
    - [[#special-applicatives][Special applicatives]]
      - [[#identity-applicative][Identity applicative]]
      - [[#constant-applicative][Constant applicative]]
      - [[#maybe-applicative][Maybe applicative]]
      - [[#either-applicative][Either applicative]]
      - [[#validation-applicative][Validation applicative]]
    - [[#applicative-functions][Applicative functions]]
      - [[#lifta][liftA*]]
        - [[#lifta-1][liftA]]
        - [[#lifta2][liftA2]]
        - [[#lifta2-][liftA2 (<*>)]]
        - [[#lifta2-lifta2-][liftA2 (liftA2 (<*>))]]
        - [[#lifta3][liftA3]]
  - [[#applicative-functor][Applicative functor]]
  - [[#arbitrary-function][Arbitrary function]]
  - [[#arbitrary-type-class][Arbitrary type class]]
  - [[#argument][Argument]]
  - [[#arity][Arity]]
  - [[#as-pattern][As-pattern]]
  - [[#assertion][Assertion]]
  - [[#associative-law][Associative law]]
  - [[#base-case][Base case]]
  - [[#basis][Basis]]
  - [[#beta-normal-form][Beta normal form]]
  - [[#beta-reduction][Beta reduction]]
  - [[#binary][Binary]]
  - [[#binary-operation][Binary operation]]
  - [[#binary-tree][Binary tree]]
  - [[#bind][Bind]]
  - [[#bottom-value][Bottom value]]
  - [[#calculus-of-constructions][Calculus of constructions]]
    - [[#-1][/*/]]
      - [[#coc][CoC]]
  - [[#cardinality][Cardinality]]
  - [[#cartesian-product][Cartesian product]]
  - [[#case][Case]]
  - [[#category][Category]]
    - [[#-2][/*/]]
      - [[#object][Object]]
      - [[#category-theory][Category theory]]
  - [[#closed-form-expression][Closed-form expression]]
  - [[#closed-set][Closed set]]
  - [[#closure][Closure]]
  - [[#coalgebra][Coalgebra]]
  - [[#coarbitrary][CoArbitrary]]
  - [[#codomain][Codomain]]
  - [[#combinator][Combinator]]
  - [[#commutative-law][Commutative law]]
    - [[#-3][/*/]]
      - [[#commutative][Commutative]]
  - [[#composition][Composition]]
  - [[#concatenate][Concatenate]]
  - [[#concrete-type][Concrete type]]
  - [[#conjunction][Conjunction]]
  - [[#cons-cell][Cons cell]]
  - [[#constant][Constant]]
  - [[#constraint][Constraint]]
  - [[#construct][Construct]]
    - [[#-4][/*/]]
      - [[#cons][Cons]]
  - [[#constructor][Constructor]]
  - [[#contravariant][Contravariant]]
    - [[#-5][/*/]]
      - [[#contravariant-cofunctor][Contravariant cofunctor]]
      - [[#contravariant-functor][Contravariant functor]]
  - [[#covariant][Covariant]]
  - [[#covariant-cofunctor][Covariant cofunctor]]
  - [[#covariant-functor][Covariant functor]]
  - [[#curryhoward-correspondence][Curry–Howard correspondence]]
    - [[#-6][/*/]]
      - [[#curryhoward-isomorphism][Curry–Howard isomorphism]]
  - [[#currying][Currying]]
  - [[#data-constant][Data constant]]
  - [[#data-constructor][Data constructor]]
  - [[#data-declaration][Data declaration]]
  - [[#data-declaration-1][data declaration]]
  - [[#data-type][Data type]]
    - [[#algebraic-data-type][Algebraic data type]]
      - [[#-7][/*/]]
        - [[#algdt][AlgDT]]
    - [[#higher-kinded-data-type][Higher-kinded data type]]
    - [[#product-data-type][Product data type]]
    - [[#sum-data-type][Sum data type]]
  - [[#declaration][Declaration]]
  - [[#dependent-type][Dependent type]]
  - [[#derived-instance][Derived instance]]
  - [[#differential-operator][Differential operator]]
    - [[#differential][Differential]]
  - [[#disjunction][Disjunction]]
  - [[#dispatch][Dispatch]]
  - [[#domain][Domain]]
  - [[#effect][Effect]]
  - [[#endofunctor][Endofunctor]]
  - [[#endofunctor-category][Endofunctor category]]
  - [[#evaluation][Evaluation]]
  - [[#expected-type][Expected type]]
  - [[#expression][Expression]]
  - [[#first-class][First-class]]
  - [[#fold][Fold]]
  - [[#free-variable][Free variable]]
  - [[#function][Function]]
    - [[#function-head][Function head]]
    - [[#function-body][Function body]]
    - [[#function-composition][Function composition]]
      - [[#-8][/*/]]
        - [[#composition-1][Composition]]
        - [[#compose][Compose]]
    - [[#function-application][Function application]]
    - [[#function-range][Function range]]
    - [[#injection][Injection]]
      - [[#-9][/*/]]
        - [[#injective][Injective]]
        - [[#injective-function][Injective function]]
    - [[#surjection][Surjection]]
      - [[#-10][/*/]]
        - [[#surjective][Surjective]]
        - [[#surjective-function][Surjective function]]
    - [[#bijection][Bijection]]
      - [[#-11][/*/]]
        - [[#bijective][Bijective]]
        - [[#bijective-function][Bijective function]]
  - [[#functor][Functor]]
    - [[#functor-laws][Functor laws]]
      - [[#functor-identity-law][Functor identity law]]
      - [[#functor-composition-law][Functor composition law]]
    - [[#lift][Lift]]
    - [[#forgetful-functor][Forgetful functor]]
    - [[#-12][/*/]]
      - [[#powerset-functor][Powerset functor]]
      - [[#fmap][fmap]]
  - [[#fundamental-theorem-of-algebra][Fundamental theorem of algebra]]
  - [[#gen-type][Gen type]]
  - [[#girardreynolds-polymorphic-lambda-calculus][Girard–Reynolds polymorphic lambda calculus]]
  - [[#guerrilla-patch][Guerrilla patch]]
  - [[#higher-order-function][Higher-order function]]
    - [[#-13][/*/]]
      - [[#hof][HOF]]
  - [[#hindleymilner-type-system][Hindley–Milner type system]]
  - [[#hom-set][Hom-set]]
    - [[#hom-functor][Hom-functor]]
  - [[#idempotence][Idempotence]]
  - [[#idiom][Idiom]]
    - [[#-14][/*/]]
      - [[#idiomatic][Idiomatic]]
  - [[#iff][Iff]]
  - [[#impredicative][Impredicative]]
  - [[#infix][Infix]]
  - [[#inhabit][Inhabit]]
  - [[#initial-object][Initial object]]
  - [[#interface][Interface]]
  - [[#io][IO]]
  - [[#kernel][Kernel]]
    - [[#kernel-homomorphism][Kernel homomorphism]]
  - [[#kind][Kind]]
  - [[#lambda-abstraction][Lambda abstraction]]
  - [[#lambda-calculus][Lambda calculus]]
    - [[#-15][/*/]]
      - [[#lambda-term][Lambda term]]
  - [[#lambda-cube][Lambda cube]]
  - [[#lambda-function][Lambda function]]
    - [[#lambda-expression][Lambda expression]]
    - [[#anonymous-function][Anonymous function]]
  - [[#leaf][Leaf]]
  - [[#left-associative][Left associative]]
  - [[#level-of-code][Level of code]]
    - [[#term-level][Term level]]
    - [[#type-level][Type level]]
    - [[#compile-level][Compile level]]
      - [[#compilation-level][Compilation level]]
    - [[#runtime-level][Runtime level]]
    - [[#-16][/*/]]
      - [[#code-level][Code level]]
  - [[#lexical-scope][Lexical scope]]
    - [[#-17][/*/]]
      - [[#static-scope][Static scope]]
  - [[#dynamic-scope][Dynamic scope]]
  - [[#linear-type][Linear type]]
  - [[#local-scope][Local scope]]
    - [[#-18][/*/]]
      - [[#local][Local]]
  - [[#magma][Magma]]
  - [[#module][Module]]
  - [[#modulus][Modulus]]
  - [[#monad][Monad]]
    - [[#functor---applicative---monad-progression][Functor -> Applicative -> Monad progression]]
    - [[#monad-type-class][Monad type class]]
    - [[#monad-functions][Monad functions]]
      - [[#return][Return]]
      - [[#bind-1][Bind]]
        - [[#-19][(>>=)]]
      - [[#join][Join]]
        - [[#joinfmap--][join.fmap == (=<<)]]
      - [[#sequencing-operator---][Sequencing operator (>>) == (*>):]]
    - [[#monad-or-applicative][Monad OR Applicative]]
      - [[#start-writing-monad-using-return-ap-liftm-liftm2--instead-of-do][Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>=']]
      - [[#basic-case-when-applicative-can-be-used][Basic case when Applicative can be used]]
      - [[#applicative-block-vs-monad-block][Applicative block vs Monad block]]
    - [[#maybe-monad][Maybe monad]]
    - [[#either-monad][Either monad]]
    - [[#monad-laws][Monad laws]]
      - [[#monad-left-identity-law][Monad left identity law]]
      - [[#monad-right-identity-law][Monad right identity law]]
      - [[#monad-associativity-law][Monad associativity law]]
    - [[#comonad][Comonad]]
  - [[#monkey-patch][Monkey patch]]
  - [[#monoid][Monoid]]
    - [[#monoid-laws][Monoid laws]]
      - [[#monoid-left-identity-law][Monoid left identity law]]
      - [[#monoid-right-identity-law][Monoid right identity law]]
      - [[#monoid-associativity-law][Monoid associativity law]]
    - [[#commutative-monoid][Commutative monoid]]
      - [[#-20][/*/]]
        - [[#abelian-monoid][Abelian monoid]]
  - [[#monoidal-functor][Monoidal functor]]
  - [[#morphism][Morphism]]
    - [[#homomorphism][Homomorphism]]
      - [[#-21][/*/]]
        - [[#homomorphic][Homomorphic]]
    - [[#identity-morphism][Identity morphism]]
      - [[#identity][Identity]]
        - [[#two-sided-identity-of-a-predicate][Two-sided identity of a predicate]]
        - [[#left-identity-of-a-predicate][Left identity of a predicate]]
        - [[#right-identity-of-a-predicate][Right identity of a predicate]]
      - [[#identity-function][Identity function]]
    - [[#monomorphism][Monomorphism]]
      - [[#-22][/*/]]
        - [[#monomorphic][Monomorphic]]
    - [[#epimorphism][Epimorphism]]
      - [[#-23][/*/]]
        - [[#epimorphic][Epimorphic]]
    - [[#isomorphism][Isomorphism]]
      - [[#-24][/*/]]
        - [[#isomorphic][Isomorphic]]
    - [[#endomorphism][Endomorphism]]
      - [[#automorphism][Automorphism]]
        - [[#-25][/*/]]
          - [[#automorphic][Automorphic]]
      - [[#-26][/*/]]
        - [[#endomorphic][Endomorphic]]
    - [[#catamorphism][Catamorphism]]
      - [[#-27][/*/]]
        - [[#catamorphic][Catamorphic]]
  - [[#natural-transformation][Natural transformation]]
  - [[#newtype-declaration][newtype declaration]]
  - [[#node][Node]]
  - [[#nonempty-list-data-type][NonEmpty list data type]]
  - [[#normal-form][Normal form]]
  - [[#nothing][Nothing]]
  - [[#open-formula][Open formula]]
  - [[#operation][Operation]]
  - [[#operator][Operator]]
  - [[#orphan-type-instance][Orphan type instance]]
  - [[#parameter][Parameter]]
  - [[#partial-application][Partial application]]
  - [[#partial-function][Partial function]]
  - [[#permutation][Permutation]]
  - [[#point-free][Point-free]]
    - [[#eta-abstraction][\eta-abstraction]]
      - [[#-28][/*/]]
        - [[#eta-reduction][\eta-reduction]]
        - [[#eta-conversion][\eta-conversion]]
        - [[#eta-abstraction-1][eta-abstraction]]
        - [[#eta-reduction-1][eta-reduction]]
        - [[#eta-conversion-1][eta-conversion]]
    - [[#blackbird][Blackbird]]
      - [[#-29][/*/]]
        - [[#-][.) .]]
        - [[#sectioning][Sectioning]]
        - [[#-30][(.).(.)]]
    - [[#swing][Swing]]
    - [[#squish][Squish]]
    - [[#-31][/*/]]
      - [[#pointfree][Pointfree]]
      - [[#tacit][Tacit]]
      - [[#tacit-programming][Tacit programming]]
  - [[#polymorphism][Polymorphism]]
    - [[#levity-polymorphism][Levity polymorphism]]
    - [[#parametric-polymorphism][Parametric polymorphism]]
      - [[#rank-1-polymorphism][Rank-1 polymorphism]]
        - [[#-32][/*/]]
          - [[#prenex][Prenex]]
          - [[#prenex-polymorpism][Prenex polymorpism]]
      - [[#let-bound-polymorphism][Let-bound polymorphism]]
      - [[#constrained-polymorphism][Constrained polymorphism]]
        - [[#ad-hoc-polymorphism][Ad hoc polymorphism]]
      - [[#impredicative-polymorphism][Impredicative polymorphism]]
        - [[#-33][/*/]]
          - [[#first-class-polymorphism][First-class polymorphism]]
      - [[#higher-rank-polymorphism][Higher-rank polymorphism]]
        - [[#-34][/*/]]
          - [[#rank-n-polymorphism][Rank-n polymorphism]]
    - [[#subtype-polymorphism][Subtype polymorphism]]
    - [[#row-polymorphism][Row polymorphism]]
    - [[#kind-polymorphism][Kind polymorphism]]
    - [[#linearity-polymorphism][Linearity polymorphism]]
  - [[#pragma][Pragma]]
    - [[#language-pragma][LANGUAGE pragma]]
      - [[#language-option][LANGUAGE option]]
        - [[#useful-by-default][Useful by default]]
        - [[#allowambiguoustypes][AllowAmbiguousTypes]]
        - [[#applicativedo][ApplicativeDo]]
        - [[#constrainedclassmethods][ConstrainedClassMethods]]
        - [[#constraintkinds][ConstraintKinds]]
        - [[#cpp][CPP]]
        - [[#derivefunctor][DeriveFunctor]]
        - [[#explicitforall][ExplicitForAll]]
        - [[#flexiblecontexts][FlexibleContexts]]
        - [[#flexibleinstances][FlexibleInstances]]
        - [[#generalizednewtypederiving][GeneralizedNewtypeDeriving]]
        - [[#implicitparams][ImplicitParams]]
        - [[#lambdacase][LambdaCase]]
        - [[#multiparamtypeclasses][MultiParamTypeClasses]]
        - [[#multiwayif][MultiWayIf]]
        - [[#overloadedstrings][OverloadedStrings]]
        - [[#partialtypesignatures][PartialTypeSignatures]]
        - [[#rankntypes][RankNTypes]]
        - [[#scopedtypevariables][ScopedTypeVariables]]
        - [[#tuplesections][TupleSections]]
        - [[#typeapplications][TypeApplications]]
        - [[#typefamilies][TypeFamilies]]
          - [[#data-families][Data families]]
          - [[#type-synonym-families][Type synonym families]]
        - [[#typesynonyminstances][TypeSynonymInstances]]
        - [[#undecidableinstances][UndecidableInstances]]
        - [[#viewpatterns][ViewPatterns]]
        - [[#datatypecontexts][DatatypeContexts]]
      - [[#how-to-make-a-ghc-language-extension][How to make a GHC LANGUAGE extension]]
    - [[#pragma-option][Pragma option]]
  - [[#predicate][Predicate]]
  - [[#predicative][Predicative]]
  - [[#principal-type][Principal type]]
  - [[#principle-of-compositionality][Principle of compositionality]]
  - [[#proxy-type][Proxy type]]
  - [[#psi-combinator][\Psi-combinator]]
    - [[#-35][/*/]]
      - [[#psi-combinator-1][Psi-combinator]]
      - [[#on-combinator][On-combinator]]
  - [[#purity][Purity]]
  - [[#quantifier][Quantifier]]
    - [[#forall-quantifier][Forall quantifier]]
      - [[#-36][/*/]]
        - [[#forall][Forall]]
  - [[#recursion][Recursion]]
  - [[#redex][Redex]]
  - [[#reduction][Reduction]]
  - [[#referential-transparency][Referential transparency]]
  - [[#relation][Relation]]
  - [[#repl][REPL]]
  - [[#scope][Scope]]
  - [[#sectioning-1][Sectioning]]
  - [[#semantics][Semantics]]
    - [[#operational-semantics][Operational semantics]]
    - [[#denotational-semantics][Denotational semantics]]
    - [[#axiomatic-semantics][Axiomatic semantics]]
  - [[#semigroup][Semigroup]]
  - [[#set][Set]]
  - [[#set-category][SET category]]
  - [[#shadowing][Shadowing]]
  - [[#shift-operator][Shift operator]]
    - [[#-37][/*/]]
      - [[#shift][Shift]]
  - [[#shrinking][Shrinking]]
  - [[#singleton][Singleton]]
  - [[#smart-constructor][Smart constructor]]
  - [[#spine][Spine]]
  - [[#statement][Statement]]
  - [[#static-typing][Static typing]]
  - [[#structural-type][Structural type]]
  - [[#structural-type-system][Structural type system]]
  - [[#superclass][Superclass]]
  - [[#syntatic-sugar][Syntatic sugar]]
  - [[#system-f][System F]]
  - [[#tail-call][Tail call]]
  - [[#tail-recursion][Tail recursion]]
  - [[#tensor][Tensor]]
  - [[#terminal-object][Terminal object]]
  - [[#testing][Testing]]
    - [[#property-testing][Property testing]]
      - [[#property][Property]]
      - [[#property-testing-types][Property testing types]]
      - [[#generator][Generator]]
        - [[#custom-generator][Custom generator]]
      - [[#reusing-test-code][Reusing test code]]
        - [[#commutative-property][Commutative property]]
        - [[#symmetry-property][Symmetry property]]
        - [[#equivalence-property][Equivalence property]]
        - [[#inverse-property][Inverse property]]
      - [[#quickcheck][QuickCheck]]
      - [[#manual-automation-with-quickcheck-properties][Manual automation with QuickCheck properties]]
    - [[#write-tests-algorithm][Write tests algorithm]]
  - [[#tuple][Tuple]]
  - [[#type][Type]]
  - [[#type-alias][Type alias]]
  - [[#type-class][Type class]]
  - [[#type-class-inheritance][Type class inheritance]]
  - [[#type-constant][Type constant]]
  - [[#type-constructor][Type constructor]]
  - [[#type-declaration][type declaration]]
  - [[#type-inference][Type inference]]
  - [[#type-instance][Type instance]]
  - [[#type-variable][Type variable]]
  - [[#uncurry][Uncurry]]
  - [[#undefined][Undefined]]
  - [[#unit][Unit]]
  - [[#unlifted-type][Unlifted type]]
  - [[#unsafe][Unsafe]]
  - [[#variable][Variable]]
  - [[#variadic][Variadic]]
  - [[#zero][Zero]]
  - [[#bound][Bound]]
    - [[#-38][/*/]]
      - [[#bounded][Bounded]]
  - [[#typed-hole][Typed hole]]
  - [[#first-order-logic][First-order logic]]
    - [[#-39][/*/]]
      - [[#predicate-logic][Predicate logic]]
      - [[#first-order-predicate-calculus][First-order predicate calculus]]
  - [[#context][Context]]
- [[#give-definitions][Give definitions]]
  - [[#kleisli-category][Kleisli category]]
  - [[#free-object][Free object]]
  - [[#thin-category][Thin category]]
  - [[#partial-order][Partial order]]
  - [[#total-order][Total order]]
  - [[#preorder][Preorder]]
  - [[#identity-type][Identity type]]
  - [[#constant-type][Constant type]]
  - [[#arbitrary][Arbitrary]]
  - [[#gen][Gen]]
  - [[#st-trick-monad][ST-Trick monad]]
  - [[#lax-monoidal-functor][Lax monoidal functor]]
  - [[#tensorial-strength][Tensorial strength]]
  - [[#strong-monad][Strong monad]]
  - [[#either][Either]]
    - [[#-40][/*/]]
      - [[#either-data-type][Either data type]]
  - [[#weak-head-normal-form][Weak head normal form]]
    - [[#-41][/*/]]
      - [[#whnf][WHNF]]
  - [[#function-image][Function image]]
    - [[#image][Image]]
  - [[#maybe][Maybe]]
  - [[#homomorphis][Homomorphis]]
  - [[#language-pragma-options][LANGUAGE pragma options]]
  - [[#pattern-guard][Pattern guard]]
  - [[#inverse][Inverse]]
  - [[#inversion][Inversion]]
  - [[#inverse-function][Inverse function]]
  - [[#partial-inverse][Partial inverse]]
  - [[#define-language-pragma-options][Define LANGUAGE pragma options]]
    - [[#existentialquantification][ExistentialQuantification]]
    - [[#gadts][GADTs]]
    - [[#generalizednewtypeclasses][GeneralizedNewTypeClasses]]
  - [[#type-rank][Type rank]]
  - [[#ghc-debug-keys][GHC debug keys]]
    - [[#-ddump-ds][-ddump-ds]]
      - [[#-42][/*/]]
        - [[#ghc-desugar][GHC desugar]]
  - [[#ghc-optimize-keys][GHC optimize keys]]
    - [[#-foptimal-applicative-do][-foptimal-applicative-do]]
  - [[#ghc-check-keys][GHC check keys]]
    - [[#-wno-partial-type-signatures][-Wno-partial-type-signatures]]
  - [[#rhs][RHS]]
  - [[#lhs][LHS]]
  - [[#generalised-algebraic-data-types][Generalised algebraic data types]]
    - [[#-43][/*/]]
      - [[#gadt][GADT]]
  - [[#order-theory][Order theory]]
    - [[#domain-theory][Domain theory]]
    - [[#lattice][Lattice]]
    - [[#ordering][Ordering]]
      - [[#preorder-1][Preorder]]
        - [[#total-preorder][Total preorder]]
      - [[#partial-ordering][Partial ordering]]
        - [[#-44][/*/]]
          - [[#partially-ordered-set][Partially ordered set]]
          - [[#poset][Poset]]
  - [[#universal-algebra][Universal algebra]]
  - [[#relation-1][Relation]]
    - [[#reflexivity][Reflexivity]]
      - [[#-45][/*/]]
        - [[#reflexive][Reflexive]]
        - [[#reflexive-relation][Reflexive relation]]
    - [[#irreflexivity][Irreflexivity]]
      - [[#-46][/*/]]
        - [[#anti-reflexive][Anti-reflexive]]
        - [[#anti-reflexive-relation][Anti-reflexive relation]]
        - [[#irreflexive][Irreflexive]]
        - [[#irreflexive-relation][Irreflexive relation]]
    - [[#transitivity][Transitivity]]
      - [[#-47][/*/]]
        - [[#transitive][Transitive]]
        - [[#transitive-relation][Transitive relation]]
    - [[#symmetry][Symmetry]]
      - [[#-48][/*/]]
        - [[#symmetric][Symmetric]]
        - [[#symmetric-relation][Symmetric relation]]
    - [[#equivalence][Equivalence]]
      - [[#-49][/*/]]
        - [[#equivalent][Equivalent]]
        - [[#equivalent-relation][Equivalent relation]]
    - [[#antisymmetry][Antisymmetry]]
      - [[#-50][/*/]]
        - [[#antisymmetric][Antisymmetric]]
        - [[#antisymmetric-relation][Antisymmetric relation]]
    - [[#asymmetry][Asymmetry]]
      - [[#-51][/*/]]
        - [[#asymmetric][Asymmetric]]
        - [[#asymmetric-relation][Asymmetric relation]]
  - [[#commutativity][Commutativity]]
  - [[#cryptomorphism][Cryptomorphism]]
    - [[#-52][/*/]]
      - [[#crypromorphic][Crypromorphic]]
  - [[#lexically-scoped-type-variables][Lexically scoped type variables]]
  - [[#type-family][Type family]]
  - [[#abstract-data-type][Abstract data type]]
    - [[#-53][/*/]]
      - [[#absdt][AbsDT]]
  - [[#adt][ADT]]
- [[#citations][Citations]]
- [[#good-code][Good code]]
  - [[#type-aliasing][Type aliasing]]
  - [[#type-wideness][Type wideness]]
  - [[#read-conventions-of-variables-page-176][Read Conventions of variables (page 176)]]
  - [[#print][Print]]
  - [[#read-code-evaluation-488-on-ward][Read code evaluation (488 on-ward)]]
  - [[#fold-1][Fold]]
  - [[#computation-model][Computation model]]
  - [[#make-bottoms-only-local][Make bottoms only local]]
  - [[#newtype-wrap-is-ideally-transparent-for-compiler-and-does-not-change-performance][Newtype wrap is ideally transparent for compiler and does not change performance]]
  - [[#instances-of-typestype-classes-must-go-with-code-you-write][Instances of types/type classes must go with code you write]]
  - [[#functions-can-be-abstracted-as-arguments][Functions can be abstracted as arguments]]
  - [[#infix-operators-can-be-bind-to-arguments][Infix operators can be bind to arguments]]
  - [[#arbitrary-1][Arbitrary]]
  - [[#principle-of-separation-of-concerns][Principle of Separation of concerns]]
  - [[#function-composition-1][Function composition]]
  - [[#functor-application][Functor application]]
  - [[#parameter-order][Parameter order]]
  - [[#applicative-monoid][Applicative monoid]]
  - [[#creative-process][Creative process]]
    - [[#pick-phylosophy-principles-one-to-three-the-more---the-harder-the-implementation][Pick phylosophy principles one to three the more - the harder the implementation]]
    - [[#draw-the-most-blurred-representation][Draw the most blurred representation]]
    - [[#deduce-abstractions-and-write-remotely-what-they-are][Deduce abstractions and write remotely what they are]]
    - [[#model-of-computation][Model of computation]]
      - [[#model-the-domain][Model the domain]]
      - [[#model-the-types][Model the types]]
      - [[#think-how-to-write-computations][Think how to write computations]]
    - [[#create][Create]]
  - [[#about-operators----][About operators (<$) (*>) (<*) (>>)]]
  - [[#about-operators-mapm_-sequence_][About operators mapM_ sequence_]]
  - [[#guideliles][Guideliles]]
    - [[#wikihaskell][Wiki.haskell]]
      - [[#documentation][Documentation]]
        - [[#comments-write-in-application-terms-not-technical][Comments write in application terms, not technical.]]
        - [[#tell-what-code-needs-to-do-not-how-it-does][Tell what code needs to do not how it does.]]
      - [[#haddoc][Haddoc]]
        - [[#put-haddock-comments-to-ever-exposed-data-type-and-function][Put haddock comments to ever exposed data type and function.]]
        - [[#haddock-header][Haddock header]]
      - [[#code][Code]]
        - [[#try-to-stay-closer-to-portable-haskell98-code][Try to stay closer to portable (Haskell98) code]]
        - [[#try-make-lines-no-longer-80-chars][Try make lines no longer 80 chars]]
        - [[#last-char-in-file-should-be-newline][Last char in file should be newline]]
        - [[#symbolic-infix-identifiers-is-only-library-writer-right][Symbolic infix identifiers is only library writer right]]
        - [[#every-function-does-one-thing][Every function does one thing.]]
  - [[#use-typed-holes-to-progress-the-code][Use Typed holes to progress the code]]
  - [[#haskell-has-infinite-terms-not-not-infinite-types][Haskell has infinite terms not not infinite types.]]
  - [[#use-type-sysnonims-to-differ-the-information][Use type sysnonims to differ the information]]
  - [[#controlmonaderror---controlmonadexcept][Control.Monad.Error -> Control.Monad.Except]]
  - [[#point-free-becomes-better-in-multi-dimentional-data][Point-free becomes better in multi-dimentional data]]
- [[#bad-code][Bad code]]
  - [[#pragma-1][Pragma]]
    - [[#dangerous-language-pragma-options][Dangerous LANGUAGE pragma options]]
- [[#useful-functions-to-remember][Useful functions to remember]]
  - [[#prelude][Prelude]]
    - [[#ord][Ord]]
    - [[#calc][Calc]]
    - [[#list-operations][List operations]]
  - [[#datalist][Data.List]]
  - [[#datachar][Data.Char]]
  - [[#quickcheck-1][QuickCheck]]
- [[#investigate][Investigate]]
  - [[#controlmonad][Control.Monad]]
- [[#debugger][Debugger]]
  - [[#commands][Commands]]
  - [[#breakpoints][Breakpoints]]
  - [[#step-by-step][Step-by-step]]
  - [[#what-been-evaluated-already][What been evaluated already]]
- [[#tools][Tools]]
  - [[#search-over-the-haskell-packages-code-codesearch-from-aelve][Search over the Haskell packages code: Codesearch from Aelve]]
- [[#libs][Libs]]
  - [[#parsers---megaparsec][Parsers - megaparsec]]
  - [[#clis---optparse-applicative][CLIs - optparse-applicative]]
  - [[#html---lucid][HTML - Lucid]]
  - [[#web-applications---servant][Web applications - Servant]]
  - [[#io-libraries][IO libraries]]
    - [[#conduit---practical-monolythic-guarantees-termination-return][Conduit - practical, monolythic, guarantees termination return]]
    - [[#pipes--pipes-parse---modular-more-primitive-theoretically-driven][Pipes + Pipes Parse - modular, more primitive, theoretically driven]]
- [[#misc][Misc]]
- [[#reference][Reference]]
  - [[#haskell-98][Haskell-98]]
    - [[#instance-termination-rules][Instance termination rules]]

* Definitions
:PROPERTIES:
:ID:       68eb5f9c-7d07-4a32-9440-eb24e1399a7a
:END:
** Abelian category :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       dfd74db1-0c16-430d-83b7-8dcc2fb16d34
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 1.667
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:24]
:END:
Is which:
  * has a zero object,
  * has all binary biproducts,
  * has all [[Kernel][kernel]]s and cokernels,
  * (it has all pullbacks and pushouts)
  * all [[Monomorphism][monomorphism]]s and [[Epimorphism][epimorphism]]s are normal.
Abelian [[Category][category]] are very stable; for example they are regular and they satisfy the snake lemma.
The class of Abelian categories is closed under several categorical constructions.
** Abstraction :drill:
:PROPERTIES:
:ID:       7875b659-d137-41df-b146-6fb73f090a4e
:END:
abs away from, off (in absentia)
tractus draw, haul, drag


Purified generalization of process.
It is great did to name an abstraction ([[Denotational semantics]]).
** Actual type :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       1325dd6d-8944-4226-a703-e5e7ecb90838
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:32]
:END:
[[Data type]] recieved by ->[[Type inference][inferring]]->compiling->execution.
** Algebra :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       ef37e5f5-d52b-49eb-837e-1195558b6e79
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 19:55]
:END:
al-jabr - assemble parts.
A system of algebra based on given axioms.

---

1) Abstract algebra - the study of number systems and operations within them.
2) Algebra - vector space over a field with a multiplication.
** Alpha equivalence :drill:
:PROPERTIES:
:ID:       83ea3e34-0c72-4976-abaa-875767736cea
:END:
Alpha equivalence - in [[Expression][expressions]] process is literally the same, but names of parameters accordingly different (then they are synonyms).
** Ambigram :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       bc8fb3d5-d6bf-46b3-bf5b-5955e8f05a67
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 15:22]
:END:
ambi both
γράμμα /grámma/ written character

Object which from different points of view has different projections. Thou from projections only partial understanding of object is drawn.

While this word has two contradictory diametrically opposite meanings, one was chosen.

But it has... Both.

/TODO: Probably better for the merit of difference about different meaning refer to [[Tensor]] as object with many meanings./
** Anamorphism :drill:
:PROPERTIES:
:ID:       731c7b76-f46b-478f-87c0-4c24cb3f8c5c
:END:
[[Morphism]] from a [[Coalgebra][coalgebra]] to the final coalgebra for that [[Endofunctor][endofunctor]].
Is a [[Function][function]] that generates a sequence by repeated [[Application][application]] of the function to its previous result.
** Application :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       2ecbb029-b5d4-447b-81f6-ff9242231aee
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 19:55]
:END:
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen.
** Application memory :drill:
:PROPERTIES:
:ID:       49209cb4-a094-4b16-8803-884efd701706
:END:
| Storage of                        | Block name    |
|-----------------------------------+---------------|
| All not currently processing data | Heap          |
| Function call, local variables    | Stack         |
| Static and global variables       | Static/Global |
| Instructions                      | Binary code   |

When even Main invoked - it work in Stack, and called Stack frame. Stack frame size for function calculated when it is compiled.
When stacked Stack frames exceed the Stack size - stack overflow happens.
*** /*/
**** Heap
See [[Application memory]].
**** Stack
See [[Application memory]].
** Applicative :drill:
:PROPERTIES:
:ID:       423ac24e-497b-4ab1-b1c5-99ed84ec6546
:END:
See [[Applicative functor]] for [[Category theory]] description.
Sequencing functorial computations.

#+begin_src haskell
(<*>) :: f (a -> b) -> f a -> f b
#+end_src

Requires [[Functor]] to exist.
Requires [[Monoid][Monoidal]] structure. And has structure rules, that are separate from what happens inside it.
Structure goes through Monoidal process.

[[Data type]]s can have several applicative implementations.
*** Applicative laws
**** Applicative identity law
#+begin_src haskell
pure id <*> v = v
#+end_src
**** Applicative composition law
Function composition works regularly.
#+begin_src haskell
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
#+end_src
**** Applicative homomorphism law
Applying the function doesn't change the structure around values.
#+begin_src haskell
pure f <*> pure x = pure (f x)
#+end_src
**** Applicative interchange law
On condition that internal order of evaluation is preserved - order of operands is not relevant.
#+begin_src haskell
u <*> pure y = pure ($ y) <*> u
#+end_src

*** Special applicatives
**** Identity applicative
#+begin_src haskell
-- Applicative f =>
-- f ~ Identity
type Id = Identity
instance Applicative Id
  where
    pure :: a -> Id a
    (<*>) :: Id (a -> b) -> Id a -> Id b

mkId = Identity
xs = [1, 2, 3]

const <$> mkId xs <*> mkId xs'
-- [1,2,3]
#+end_src
**** Constant applicative
It holds only to one value. The function does not exist and `b` is phantom.
#+begin_src haskell
-- Applicative f =>
-- f ~ Constant e
type C = Constant
instance Applicative C
  where
    pure :: a -> C e a
    (<*>) :: C e (a -> b) -> C e a -> C e b

pure 1
-- 1
pure 1 :: Constant String Int
-- Constant {getConstant = ""}
#+end_src

**** Maybe applicative
"There also can be no function at all."

If function might not exist - embed `f` in Maybe structure, and use Maybe applicative.
#+begin_src haskell
-- f ~ Maybe
type M = Maybe
pure :: a -> M a
(<*>) :: M (a -> b) -> M a -> M b
#+end_src
**** Either applicative
`pure` is `Right`.
Defaults to `Left`.
And if there is two Left's - to Left of the first argument.
**** Validation applicative
The Validation data type isomorphic to Either, but has accumulative Applicative on the error side.
For this Applicative there is no corresponding Bind or Monad instance. Validation is an example of, "An applicative functor that is not a monad."
Because monad needs to process the result of computation - it needs to be able to process Left error statements, which is hard. Either monad on Left case just drops computation and returns this first Left. 
*** Applicative functions
**** liftA*
***** liftA
Essentially a [[fmap]].
#+begin_src haskell
:type liftA
liftA :: Applicative f => (a -> b) -> f a -> f b
#+end_src
***** liftA2
Lifts [[Binary][binary]] [[Function][function]] across two [[Applicative]]s [[Functor][functor]]s.
#+begin_src haskell
:type liftA2
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
#+end_src
***** liftA2 (<*>)
liftA2 (<*>) is pretty useful. It can lift [[Binary][binary operation]] through the two layers:
It is two-layer Applicative.
#+begin_src haskell
liftA2 :: Applicative f => (    a       ->  b  ->  c ) -> f      a        ->  f    b   ->  f    c
<*> :: Applicative f =>    (f  (a -> b) -> f a -> f b)
liftA2 (<*>) :: (Applicative f1, Applicative f2) =>      f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
#+end_src
***** liftA2 (liftA2 (<*>))
[[liftA2 (<*>)]] 3-layer version.
***** liftA3
[[liftA2]] 3-parameter version.
** Applicative functor :drill:
:PROPERTIES:
:ID:       5a6a7b44-9124-4af8-aeb6-c7dbcbc9888c
:END:
Applicative functor - [[Lax monoidal functor]] with [[Tensorial strength]].
See [[Applicative]].
** Arbitrary function :drill:
:PROPERTIES:
:ID:       31fe10b3-340e-489a-ab65-a4532a005d0a
:END:
Depends on type and generates values of that type.
** Arbitrary type class :drill:
:PROPERTIES:
:ID:       1bda8aab-a08c-4d7b-bd08-0b1a6f559a33
:END:
[[Type class]] of [[QuickCheck]].Arbitrary (that is reexported by QuickCheck) for creating a generator/distribution of values.
Useful function is [[Arbitrary function][arbitrary]] - that autoassumes/generates values.
** Argument :drill:
:PROPERTIES:
:ID:       56fadaf0-586a-4e26-a216-c39fcca004ea
:END:
arguere to make clear, to shine
argument evidence, proof

Independed variable of a function. Topic that the fuction would deal with.
Is an input value to a [[Function][function]] [[Parameter][parameter]].
** Arity :drill:
:PROPERTIES:
:ID:       fa4caa07-eea5-4082-aaed-92abb820e768
:END:
Number of [[Parameter][parameters]] of the [[Function][function]].
  * nullary - f()
  * unary   - f(x)
  * binary  - f(x,y)
  * ternary - f(x,y,z)
  * n-ary   - f(x,y,z..)
** As-pattern :drill:
:PROPERTIES:
:ID:       a2d762f7-549b-4aa1-ba3e-183c2e757a35
:END:
#+begin_src haskell
f list@(x, xs) = ...
#+end_src
** Assertion :drill:
:PROPERTIES:
:ID:       ca03459f-58a7-4938-8de0-2408ee2a0225
:END:
Statement.
Утверждение.
** Associative law :drill:
:PROPERTIES:
:ID:       0985ce00-f1cd-441b-9d49-7c02b51298bf
:END:
Joined by a common purpose.
$$ \forall (a,b,c) \in S : \; P(a,P(b,c)) \equiv P(P(a,b),c) $$,
Etymology:
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".
** Base case :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       be130896-9bec-4276-9a7b-41cfb9f3b6dd
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:59]
:END:
A part of a [[Recursion][recursive]] [[Function][function]] that trivially produces result.
** Basis :drill:
:PROPERTIES:
:ID:       c880a358-f545-4e2e-9c44-7c80ca038ac1
:END:
$$ \beta\alpha\sigma\iota\varsigma $$ - stepping

The initial point, unreducible axioms and terms that spawn a theory.
AKA see [[Category theory]], or Euclidian geometry basis.
** Beta normal form :drill:
:PROPERTIES:
:ID:       56b65c7e-f063-4614-b2c7-916ff446ab80
:END:
No [[Beta reduction][beta reduction]] is possible.
** Beta reduction :drill:
:PROPERTIES:
:ID:       09ff04bc-e52b-47e9-9a9e-a23bd437fb75
:END:
Applying [[Function][function]] to an [[Argument][argument]].
** Binary :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       f6ddbc05-f514-49e1-8906-28e67eb0866c
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 22:18]
:END:
Two of something.
** Binary operation :drill:
:PROPERTIES:
:ID:       f7cf1edb-834b-4505-874b-c7e8acc6d547
:END:
$$ \forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S $$
** Binary tree :drill:
:PROPERTIES:
:ID:       8efc93b6-3518-40e7-9143-eb695b267bd4
:END:
#+begin_src haskell
data BinaryTree a
  = [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)
#+end_src
** Bind :drill:
:PROPERTIES:
:ID:       2e4ac590-3b8a-4c70-9229-a83d30f6b149
:END:
Eq between two objects.
Parameter of the function = argument that applied to the function
Variables = values.
** Bottom value :drill:
:PROPERTIES:
:ID:       6a1419f1-74f8-4cab-9f50-6dd93c2b47bd
:END:
#+begin_src haskell
-- _ fits *.
#+end_src

Is a non-value used to denote the program cannot return a values.
** Calculus of constructions :drill:
:PROPERTIES:
:ID:       6c93585b-5ba5-4a38-ae39-2f7dc718390b
:END:
Extends the [[Curry–Howard correspondence]] to the proofs in the full intuitionistic predicate calculus (includes proofs of quantified statements).
Type theory, typed programming language, and constructivism (phylosophy) foundation for mathematics.
Directly relates to Coq programming language.
*** /*/
**** CoC
See [[Calculus of constructions]].
** Cardinality :drill:
:PROPERTIES:
:ID:       22428179-0fdb-4723-94dc-596dd41f61c0
:END:

Number of possible implementations for a given type signature. So also number elements inhabiting type, as they are a number of variations.

Disjuction, sum - adds cardinalities.
Conjunction, product - multiplies cardinalities.
** Cartesian product :drill:
:PROPERTIES:
:ID:       1c2c6ec3-701a-4803-a73a-7564b4ffb298
:END:
$$ \forall a \in A, \forall b \in B : A \times B = \overset \rightharpoonup {(a,b)} $$.
Any [[Function][function]] is a subset of Cartesian product.

$$ \sum_{}_{}^{elem \in (A \times B)}  = cardinality^{A \times B} $$
[[Cardinality]].

** Case :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       14309b50-3648-47ba-a4b1-eb5aa4bd7a3c
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:59]
:END:
#+begin_src haskell
case x of
    | pattern1  -> ex1
    | pattern2  -> ex2
    | pattern3  -> ex3
    | otherwise -> exDefault
#+end_src

Syntatic sugar with guards allows usage of expressions:
#+begin_src haskell
case () of _
             | expr1     -> ex1
             | expr2     -> ex2
             | expr3     -> ex3
             | otherwise -> exDefault
#+end_src

** Category :drill:
:PROPERTIES:
:ID:       a026cdb8-26e0-494e-b51c-b49d0210d61b
:END:
Category (/C/) consists of the [[Basis]]:
  1. Objects - ob(/C/). A node. Object of some type. Often sets, than it is [[SET category]].
  2. [[Morphism]]s - C(a,b), [[Hom-set][hom(a,b)]]. Mappings, total functions.
  3. Binary operation "Composition of morphisms": $$ \forall a, b, c : \; C(a, b) \circ C(b, c) \equiv C(a, c) $$. In other words morpisms correspond to [[Principle of compositionality]].
  4. Axiom of [[Associative law][Associativity]]: $$ f_{a \to b}, g_{b \to c}, h_{c \to d} : \; h \circ (g \circ f) \equiv (h \circ g) \circ f $$.
  5. Axiom of two sided [[Identity]] of morphisms: $\forall x \, \exists  id_{x : x \to x},  \forall f_{a \to x},  \forall g_{x \to b} : \; id_x \circ f_{a \to x} \equiv f_{a \to x}, \; g_{x \to b} \circ id_x \equiv g_{x \to b}$ (both left and right identity)

From these axioms, one can prove that there is exactly one identity morphism for every object.
*** /*/
**** Object
See [[Category]]
**** Category theory
See [[Category]]
** Closed-form expression :drill:
:PROPERTIES:
:ID:       4fe26c88-61dc-4a5c-b31e-aa91d5a9afd0
:END:
Closed-form expression - a mathematical expression that can be evaluated in a finite number of operations. It may contain constants, variables, certain "well-known" operations (e.g., + − × ÷), and functions (e.g., nth root, exponent, logarithm, trigonometric functions, and inverse hyperbolic functions), but usually no limit.
** Closed set :drill:
:PROPERTIES:
:ID:       33bc1a45-7af7-4320-ac6a-2bc785b7afd9
:END:
Closed set - a set whose complement is an open set.
Closed set is a form of [[Closed-form expression]]. Set can be closed in under a set of operations.
** Closure :drill:
:PROPERTIES:
:ID:       c20b75e8-cd85-4f41-84c2-660ffdb963dd
:END:

$$ D \in X, \forall x \in D : f(x) = f^{D \to X} , X is closed under f $$
Operation /*/ - operation on members of the domain always produces a members of the domain - in this case we also say that the set is closed under the operation.
** Coalgebra :drill:
:PROPERTIES:
:ID:       a48247a2-f844-4c4e-9f40-e8cac61bb209
:END:
Structures that are dual (in the category-theoretic sense of reversing arrows) to unital associative [[Algebra][algebras]].
Every coalgebra, by vector space duality, reversing arrows - gives rise to an algebra. In finite dimensions, this duality goes in both directions. In infinite - it should be determined.
** CoArbitrary :drill:
:PROPERTIES:
:ID:       a8ad8f53-2ad9-414d-8c6b-8df9d0cac80e
:END:
Pseudogenerates a function basing on resulting type.
#+begin_src haskell
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
#+end_src
** Codomain :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       f8603032-30f1-4074-80b5-0f6f49428241
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 20:07]
:END:
Codomain - target set of a function in $X \to Y$.
** Combinator :drill:
:PROPERTIES:
:ID:       bf7ce908-9d5d-4a00-ab02-e7b33edd2c76
:END:
[[Function]] without free variables.
[[Higher-order function]] that use only [[Function application][function application]] and other combinators.
#+begin_src haskell
\f g x -> f (g x)
\f g x y -> f (g x y)
#+end_src
Not comibnators:
#+begin_src haskell
\xs -> sum xs
#+end_src
Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Commutative law :drill:
:PROPERTIES:
:ID:       8d6b1e5e-a054-4757-b9a8-bb40c07d79fd
:END:
$$ \forall (a,b) \in S : \; P(a,b) \equiv P(b,a) $$
*** /*/
**** Commutative
See Commutative law
** Composition :drill:
:PROPERTIES:
:ID:       b3bc17d9-83e4-4862-a391-27e0b30e011e
:END:
Axiom of [[Category]].
** Concatenate :drill:
:PROPERTIES:
:ID:       fd27911c-bf33-4510-91ff-afa1d4e7d2e1
:END:
Link together sequences.
** Concrete type :drill:
:PROPERTIES:
:ID:       736674fb-45a3-4539-8774-7ccf419b5487
:END:
** Conjunction :drill:
:PROPERTIES:
:ID:       3f47a5a4-aa8a-43a5-a834-b16f02ee343d
:END:
Logical AND

Haskell kind:
#+begin_src haskell
 * *
#+end_src
** Cons cell :drill:
:PROPERTIES:
:ID:       db0f5189-b0a4-4554-af3d-dae7145516c5
:END:
Cell that values may inhabit.
** Constant :drill:
:PROPERTIES:
:ID:       c6fd80d7-4f2b-4c0e-a924-db0616cd126d
:END:
Nullary constructor
** Constraint :drill:
:PROPERTIES:
:ID:       17acf135-bb3b-4036-84a5-b20ab01f15c9
:END:
See: [[Ad hoc polymorphism]]
** Construct :drill:
:PROPERTIES:
:ID:       09d6089a-5e26-4a2a-b805-23941be3e63e
:END:
#+begin_src haskell
(:) :: a -> [a] -> [a]
#+end_src
*** /*/
**** Cons
Short for [[Construct]].
** Constructor :drill:
:PROPERTIES:
:ID:       73f88452-54ff-4192-83fc-0681f0407e9a
:END:
1. [[Type constructor]]
2. [[Data constructor]]

Also see: [[Constant]]
** Contravariant :drill:
:PROPERTIES:
:ID:       d1f3dc34-f7b9-4284-b417-16b26860248a
:END:
The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis inverse-proportional for the description of a [[Tensor]]s in this basisis.

Denotation:
Components for contravariant basis denoted in the upper indices:
$$ V^{i} = x $$

The inverse of a covariant transformation is a contravariant transformation. Whenever a vector should be invariant under a change of basis, that is to say it should represent the same geometrical or physical object having the same magnitude and direction as before, its components must transform according to the contravariant rule.

*** /*/
**** Contravariant cofunctor
See [[Contravariant]].
**** Contravariant functor
More inline term is [[Contravariant cofunctor]]
** Covariant :drill:
:PROPERTIES:
:ID:       90eb2e6f-8695-446f-a7e8-ccac7f47dbee
:END:
The property of [[Basis]], in which if new basis is a linear combination of the prior basis, and the change of basis proportional for a descriptions of [[Tensor]]s in this basisis.

Denotation:
Components for covariant basis denoted in the upper indices:
$$ V_{i} = x $$
** Covariant cofunctor :drill:
:PROPERTIES:
:ID:       f53b176d-6377-4a9b-aa0b-40a4c7531cb4
:END:
See [[Covariant]].
** Covariant functor :drill:
:PROPERTIES:
:ID:       c9502e88-5005-4d6e-9615-bfacae3bde2d
:END:
More inline term is [[Covariant cofunctor]]
** Curry–Howard correspondence :drill:
:PROPERTIES:
:ID:       8b3e318d-242b-41ad-a16c-20d950177f5d
:END:
Computer programs are mathematical proofs.
*** /*/
**** Curry–Howard isomorphism
See [[Curry–Howard correspondence]].
** Currying :drill:
:PROPERTIES:
:ID:       4f8d7c52-f114-40ad-869e-e1ab4fdafc37
:END:
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Data constant :drill:
:PROPERTIES:
:ID:       7fd715db-5709-4238-9e49-8a9b9066a388
:END:
See: [[Constant]]
** Data constructor :drill:
:PROPERTIES:
:ID:       dc94bd99-113e-4025-82e8-39cd6843091b
:END:
One instance that [[Inhabit][inhabit]] [[Data type][data type]].

Constant value - nullary data constructor.
** Data declaration :drill:
:PROPERTIES:
:ID:       2c150e09-b6e0-4de9-8fca-497bdaf6c4cc
:END:
[[Data type]] definition.
** data declaration :drill:
:PROPERTIES:
:ID:       4c0b5dd7-d8e2-4394-9a38-e99bd7961130
:END:
[[Data type]] declaration is the most general and versatile form to create a new data type.
Form:
#+begin_src haskell
data [context =>] type typeVars1..n
  = con1  c1t1..i
  | ...
  | conm  cmt1..q
  [deriving]
#+end_src
** Data type :drill:
:PROPERTIES:
:ID:       1da15965-03f0-4cf9-a582-3df5c4deb27e
:END:
Data type, type.
*** Algebraic data type
Composite type formed by combining other types.
**** /*/
***** AlgDT
See [[Algebraic data type]]
*** Higher-kinded data type
Any combination of * and ->

Type that take more types as arguments.
*** Product data type
[[Algebraic data type]] formed by logical [[Conjunction][conjunction]] (AND ' ').
*** Sum data type
[[Algebraic data type]] formed by logical [[Disjunction][disjunction]] (OR '|').
** Declaration :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       461111ea-4124-427f-bfc6-f83212a07951
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 22:19]
:END:
[[Bind][binding]] name to [[Expression][expression]].
** Dependent type :drill:
:PROPERTIES:
:ID:       f40f1feb-3a1d-4987-b585-6d8d6080d307
:END:
Type and variable have rules regarding values.

A value of a variable has a role on the resulting Type.
Or Type has rule for values.
** Derived instance :drill:
:PROPERTIES:
:ID:       7294eaf7-4ff8-41c8-a6a9-c9060b5edfb9
:END:
Type classes such as Eq, Enum, Ord, Show can have instances generated based definition of data type.
** Differential operator :drill:
:PROPERTIES:
:ID:       1ffad9d0-5207-422f-b979-8118bbcba152
:END:
Denotation.
$$ {d \over dx}, D, \,D_{x}}, {\displaystyle \partial _{x}}. $$
Last one is partial.

$$ e^{t{\frac {d}{dx}} $$ - [[Shift]].
*** Differential
See [[Differential operator]]
** Disjunction :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       beba897a-84ca-42c9-a094-ba48487c587b
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 19:55]
:END:
OR
** Dispatch :drill:
:PROPERTIES:
:ID:       aba69f2c-bd70-46eb-9cd3-a215fdd37737
:END:
Send, transmission, reference.
** Domain :drill:
:PROPERTIES:
:ID:       61416c64-6cbf-4af4-9428-ad6f79e76701
:END:
Source set of a function in $$ X \to Y $$.
** Effect :drill:
:PROPERTIES:
:ID:       3168c887-3120-40d8-ba68-2d25bae7f37f
:END:
Observable action.
** Endofunctor :drill:
:PROPERTIES:
:ID:       96d8e579-c7b5-45a0-afbe-c4fca13c4637
:END:
Is a [[Functor][functor]] which [[Domain][domain]] and [[Codomain][codomain]] are the same [[Category][category]].
** Endofunctor category :drill:
:PROPERTIES:
:ID:       1a5d0ae1-6c37-4e53-860b-beddb4c00074
:END:
From the name, in this [[Category]] - the objects of $$ End(C) $$ are [[Endofunctor]]s $$ F: C \to C $$, and the [[Morphism]]s are [[Natural transformation]]s between endofunctors.
** Evaluation :drill:
:PROPERTIES:
:ID:       1b2053a3-24c8-47fe-a3a0-3974c6a3472a
:END:
For FP see [[Bind]].
** Expected type :drill:
:PROPERTIES:
:ID:       925824e3-ed7f-4e2f-ab3a-dd4700b0291c
:END:
[[Data type]] [[Type inference][inferred]] from the text of the code.
** Expression :drill:
:PROPERTIES:
:ID:       6ff3b474-8f28-4eb9-975a-312d37521cc6
:END:
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class :drill:
:PROPERTIES:
:ID:       b451a91d-1eb3-4c05-882f-23ea9a643a82
:END:
1. Can be used as value.
2. Passed as an [[Argument][argument]].
From 1&2 -> can include itself.
** Fold :drill:
:PROPERTIES:
:ID:       9513b166-74df-4a9f-b7da-d03f84ca2cfc
:END:
Higher-order function ruturns accumulated result from recursive data structure applying a function.
** Free variable :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       e6e68077-da2a-41d1-aed4-c033f7a97abe
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:38]
:END:
Variable in the fuction that is not bound by the head.
Until there are /* -/ function stays [[Partial application][partially applied]].
** Function :drill:
:PROPERTIES:
:ID:       e86b0dde-ef8f-447e-a966-7553784aab54
:END:
A varying quantity depends on another quantity.

$$ x \in X, y \in Y : \; f^{X \to Y} = \overset{\rightharpoonup}{G}(x,y) $$

Directionality and property of invariability emerge from one another.
#+begin_src haskell
-- domain func codomain
   *      ->   *
#+end_src

$$ y(x) = (zx^{2} + bx + 3 | b = 5) $$
^ ^     ^^    ^    ^
| |     ||     \_Var \__Constants
| |     | \__Bound__variable
| |     \_[[Free variable][Free variable]]
|  \_[[Parameter][Parameter]]
 \__Name__of__the__function

[[Lambda abstraction]] is a function.
Function is a mathematical [[Operation][operation]].

Function = Total function = Pure function. Function theoretically posible to momoized.
[[Partial function]].
Inverse function - often partially exists (partial function).
*** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
*** Function body
[[Expression]] that haracterizes the process.
*** Function composition
#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
#+end_src

In Haskell inline composition requires:
#+begin_src haskell
h.g.f $ i
#+end_src
**** /*/
***** Composition
***** Compose :drill:
:PROPERTIES:
:ID:       df869dc5-71e1-4457-a449-039c095a6cf2
:END:
*** Function application
Function application is applying the function to an argument from its domain to obtain the resulting value from its range.
*** Function range
The range of a function refers to either the codomain or the image of the function, depending upon usage. Modern usage almost always uses range to mean image.
So, see [[Function image]].
*** Injection
[[Function]] one-to-one injects from domain to codomain.
Keeps distinct pairing of elements of domain and image.
Every element in image coresponds to one element in domain.

$$ \forall a,b \in X, \; f(a)=f(b) \Rightarrow a=b $$

Denotion:
#+begin_src text
↣
>->
f : X ↣ Y
#+end_src
$f : X \rightarrowtail Y$

Corresponds to [[Monomorphism]].
**** /*/
***** Injective
See [[Injection]].
***** Injective function
See [[Injection]].
*** Surjection
[[Function]] uses codomain fully.

$$ \forall y \in Y, \exists x \in X $$

Denotation:
#+begin_src text
↠
->>
f : X ↠ Y
#+end_src
$$ f : X \twoheadrightarrow Y $$

Corresponds to [[Epimorphism]].
**** /*/
***** Surjective
See [[Surjection]].
***** Surjective function
See [[Surjection]].
*** Bijection
[[Function]] complete one-to-one pairing of elements of domain and codomain (image).
It means function both [[Surjection][surjective]] (so image == codomain) and [[Injection][injective]] (every domain element has unique correspondence to the image element).

For bijection inverse always exists.

Bijective operation holds the equivalence of domain and codomain.

Denotation:
#+begin_src text
⤖
>->>
f : X ⤖ Y
#+end_src
LaTeX needed to combine symbols:
$$ \newcommand{\twoheadrightarrowtail}[]{\mathrel{\rightarrowtail\kern-1.9ex\twoheadrightarrow}} \begin{document} f : X \twoheadrightarrowtail Y \end{document}} $$
**** /*/
***** Bijective
See [[Bijection]].
***** Bijective function
See [[Bijection]].
** Functor :drill:
:PROPERTIES:
:ID:       8cb2d494-936a-4031-b1c1-7ee18caecf31
:END:
Functor is a map between categories.

#+begin_src haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src
Functor in Haskell is a [[Type class][type class]] presents of which allows [[Function application][function application]] "over/through" type structure layers (denoted /f/ of /m/). [[IO]] is also such structure.

Haskell Functor [[Type class]] corresponds to mathematical Powerset functor.
Powerset functor is unique to the [[Category][category]] ([[Type][data type]]).
| Mathematics                | Math definition                  | Haskell                               |
|----------------------------+----------------------------------+---------------------------------------|
| $$ P(f): P(A) \to P(B) $$    | $$ (P(f))(S) = {f(a) : a \in S} $$ | <$> ∷ Functor f ⇒ (a → b) → f a → f b |
| $$ \eta s : S \to P(S) $$       | $$ \eta s(x) = {x} $$               | pure ∷ Applicative f ⇒ a → f a        |
| $$ \mu s : P(P(S)) \to P(S) $$ | $$ \mu s(L) = \cup L $$               | join ∷ Monad f ⇒ f (f a) → f a        |
Where $$ \eta,\mu $$ are [[Natural transformation]]s.

For functor instance to work [[Higher-kinded data type]]s type must be [[Function application][applied]] until it has kind =( * -> * )=, and after functors can be [[Function composition][composed]] to [[Lift][lift]] through layers of structure.

Functor can be used to filter-out error cases (Nothing & Left cases) in [[Maybe]], [[Either]] and related types.

Functor abides [[Functor laws]].
*** Functor laws
Type instance of functor should abide this laws:
**** Functor identity law
#+begin_src haskell
fmap id == id
#+end_src
**** Functor composition law
#+begin_src haskell
fmap (f.g) == fmap f . fmap g
#+end_src
In words, it is if several functions are [[functional composition][composed]] and then fmap is applied on them - it should be the same as if functions was fmapped and then composed.
*** Lift
Lift is to do a [[Function application][function application]] through the data structure.
*** Forgetful functor
[[Functor]] that forgets part or all of what defines structure in [[Domain][domain]] [[Category][category]].
*** /*/
**** Powerset functor
See: [[Functor]]
**** fmap
See: [[Functor]]
** Fundamental theorem of algebra :drill:
:PROPERTIES:
:ID:       c44040e1-2dcf-4f25-9dee-05fd95337dc2
:END:
Any non-constant single-variable polynomial with complex coefficients has at least one complex root.
Also derives that the field of complex numbers is algebraically closed.
** Gen type :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       a4d8e374-a99a-4d9a-b159-13b004c2b3ed
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:40]
:END:
Generator. List it returns gets infinitely cycled.
** Girard–Reynolds polymorphic lambda calculus :drill:
:PROPERTIES:
:ID:       a205f8f5-6e7b-4348-bbe9-818f4eca5fd2
:END:
See [[System F]].
** Guerrilla patch :drill:
:PROPERTIES:
:ID:       500e9e31-5960-4275-a8e3-3190b3b63f8f
:END:
/*/ changing code/applying patch sneakily - and possibility incompatibility with other at runtime.
[[Monkey patch]] is derivative term.
** Higher-order function :drill:
:PROPERTIES:
:ID:       61a40480-45d2-4632-9948-986eecd8b7cb
:END:
[[Function]] [[Arity][arity]] > 1.

----

Has function as a [[Parameter][parameter]].
Evaluates to function.
*** /*/
**** HOF
See: [[Higher-order function]]
** Hindley–Milner type system :drill:
:PROPERTIES:
:ID:       67b414eb-6659-455f-bbb5-cb507c643567
:END:
Classical type system for the [[Lambda calculus]] with [[Parametric polymorphism]] and [[Type inference]].
Where types marked as polymorphic variables, and overall type inference is possible all over the code.
Also known as Damas–Milner or Damas–Hindley–Milner system.
** Hom-set :drill:
:PROPERTIES:
:ID:       69d139d5-3a8d-4a07-a5b3-44778cc0ce61
:END:
Collection of all [[Morphism][morphisms]] from X to Y.

Denotation:
$$ hom(X,Y) $$
*** Hom-functor
For C (locally small category), its hom-functor is the functor $$ hom:C^{op} \times C \to Set $$,
from the product category of the category C wit its opposite category to the category Set of sets.

Denotation:
variants:
$$ H_A &=& \mathrm{Hom}(-, A) $$
$$ h_A &=& {\cal C}(-, A) $$
$$ Hom(A,-) : C \to Set $$

Hom-bifunctor:
$$ Hom(-,-):C^{op} \times C \to Set $$
** Idempotence :drill:
:PROPERTIES:
:ID:       1c821458-dd2b-4112-aa32-416e27b161ba
:END:
After the initial application operation can be applied multiple times without changing the result.
Example: Start and Stop buttons on machines.
** Idiom :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       bc244256-751d-4205-857e-368a45580884
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 15:20]
:END:
Idiom - something having a meaning that cannot be derived from the conjoined meanings.
Meaning can be special for language speakers or human with particular knowledge.

For different meaning - it is [[Applicative functor]].
*** /*/
**** Idiomatic
See [[Idiom]].
** Iff :drill:
:PROPERTIES:
:ID:       50d0c8a8-4e41-4ddd-92fa-8135124c1809
:END:
If and only if, exectly when, just.
Denotation:
$$ \iff $$
** Impredicative :drill:
:PROPERTIES:
:ID:       0f1f3bcf-df47-44de-8320-03ed8f18dc38
:END:
Self-referencing definition.

---

/Antonym - [[Predicative]]./
** Infix :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       6de70cc8-f8a0-461f-ae1a-0a8ead07799b
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:59]
:END:
Form of wrinting of operaton application in-between variables.
** Inhabit :drill:
:PROPERTIES:
:ID:       3d5a5fec-312b-47a2-bcb7-8d87f6a2baf3
:END:
What [[Value][values]] inhabit [[Data type][data type]]
** Initial object :drill:
:PROPERTIES:
:ID:       8d962644-6fcd-4152-b82a-fabb9ed38f6b
:END:
Initial object - is an object I in category C: $$ \exists I \in C: \; \forall X \in C, \exists ! (I \to X) $$.
** Interface :drill:
:PROPERTIES:
:ID:       2ef38e57-e693-490c-af8e-f92b3c31e6b3
:END:
Point of mutual meeting. Code behind interface determines how data is consumed.
** IO :drill:
:PROPERTIES:
:ID:       40e4a54b-c1c7-41fc-ac84-d3f167eb320f
:END:
Type for values whose evaluations has a posibility to cause side effects or return unpredictable result.
Haskell standard uses monad for constructing and transforming IO actions.
IO actions can be evaluated multiple times.

IO data type has unpure imperative actions inside. Haskell is pure [[Lambda calculus]], and unpure IO integrates in the Haskell purely (type system abstracts IO unpurity inside IO data type).

IO collects effects sequences one after another:
#+begin_src haskell
:{
twoBinds :: IO ()
twoBinds =
  putStrLn "First:" >>
  getLine >>=
  \a ->
  putStrLn "Second:" >>
  getLine >>=
  \b ->
  putStrLn ("\nFirst: "
    ++ a ++ ".\nSecond "
    ++ b ++ ".")
main = twoBinds
:}
#+end_src
** Kernel :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       44aee181-f629-4047-abf5-f2ae438f2063
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 15:00]
:END:
Kernel of a [[Homomorphism]] is a number that measures the degree that homomorphism fails to meet [[Injective][injectivity]] (AKA be [[Monomorphic]]).
It is a number of elements that collide and fail injectivity, thou Kernel $$ [ x | x \leftarrow 0 || x \ge 2 ] $$.

Denotation:
$$ \operatorname{ker}T = \{ \mathbf{v} \in V:T(\mathbf{v}) = \mathbf{0}_{W} \} $$.
*** Kernel homomorphism
Morphism of elements from the [[Kernel]]. Map of elements that make main [[Morphism]] not [[Monomorphic]] ([[Injective]]).
** Kind :drill:
:PROPERTIES:
:ID:       56fd7e68-49b4-496f-bc0b-bcdd8ee3fa57
:END:
Kind -> Type -> Data
** Lambda abstraction :drill:
:PROPERTIES:
:ID:       5baf8dda-dacf-447f-bcdf-26d3b3599a42
:END:
[[Lambda term]] that has a head and body and is applied to an argument.
$$ \lambda x.x+1 $$
#+begin_src haskell
\x -> x + 1
^^
#+end_src
** Lambda calculus :drill:
:PROPERTIES:
:ID:       f484ba96-5cb1-45d2-9265-25130f62361c
:END:
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and [[Function application][application]] by substituting variables and [[Bind][binding]] values.

/*/ has [[Lambda term][lambda terms]]:
   * variable ($$ x $$)
   * [[Function application][application]] ($$ (ts) $$)
   * [[Lambda function][abstraction]] ($$ (\lambda x . t) $$)
*** /*/
**** Lambda term
See [[Lambda calculus]]
** Lambda cube :drill:
:PROPERTIES:
:ID:       9ecad208-0bba-4d09-8906-5f5f76777182
:END:
λ-cube shows the dimentions of generalization from simply typed [[Lambda calculus]] to [[Calculus of constructions]].

Each dimension of the cube corresponds to a new way of making objects depend on other objects:
  * ([[First-class polymorphism]]) - terms allowed to depend on types, corresponding to polymorphism.
  * ([[Higher-rank polymorphism]]) - types depending on terms, corresponding to dependent types.
  * ([[Type class]]) - types depending on types, corresponding to type operators.
** Lambda function :drill:
:PROPERTIES:
:ID:       857ef4b3-f3e6-4065-aac4-fd3607ed5284
:END:
[[Function]] of [[Lambda calculus]].
$$ \lambda x y.x^2 + y^3 $$
 ^^ ^    ^
 || |     \__variable
 ||  \__variable
 || (_____)
 ||     \___BODY
 ||
 | \__parameter
  \___parameter
(___)
   \____HEAD
*** Lambda expression
See [[Lambda function]]
*** Anonymous function
[[Lambda function]] without the name to [[Bind][bind]] to.
** Leaf :drill:
:PROPERTIES:
:ID:       8ca6b84c-9c42-4f2c-948e-39a94246ad14
:END:
 _
** Left associative :drill:
:PROPERTIES:
:ID:       ccf220ac-e213-44ce-9d1b-ccd87f8b9a9a
:END:
Same level [[Expression][expression]] parts in reality follow grouping from left to right.
$$ (\lambda x . x)(\lambda y . y)z \equiv ((\lambda x . x)(\lambda y . y))z $$
** Level of code :drill:
:PROPERTIES:
:ID:       c0196ee9-7ddc-4b66-b2bb-0d52f1051d75
:END:
There are mainly three levels of Haskell code.
*** Term level
[[Level of code]] that works with [[Data type][data types]]
*** Type level
[[Level of code]] that does logical execution.
*** Compile level
[[Level of code]] when code compiles/compiled.
**** Compilation level
*** Runtime level
[[Level of code]] when binary code executes in machine.
*** /*/
**** Code level
See [[Level of code]]
** Lexical scope :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       989a2a14-8faf-4edb-a1cf-c3ae3a929425
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:45]
:END:
Scope bound by the structure of source code where the named entity is defined.
*** /*/
**** Static scope
See [[Lexical scope]]
** Dynamic scope :drill:
:PROPERTIES:
:ID:       477d92da-63ca-4929-b54c-aa16f6d2c71e
:END:
The name resolution depends upon the program state when the name is encountered, which is determined by the execution context or calling context.
** Linear type :drill:
:PROPERTIES:
:ID:       eda588af-3ef5-43a8-8f06-6a6f2f556036
:END:
Type system and algebra that also track the multiplicity of data.
There are 3 general linear type groups:
 * 0 - exists only at type level and is not allowed to be used at value level. Aka `s` ins ST-Trick.
 * 1 - data that is not duplicated
 * 1< - all other data, that can be duplicated multiple times.

Linear types are great to control/minimize resource usage.
** Local scope :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       4dba73c1-5cb4-4612-b9dc-f7a05d463baa
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:52]
:END:
[[Scope]] applies only in an area.
*** /*/
**** Local
See: [[Local scope]]
** Magma :drill:
:PROPERTIES:
:ID:       c40ac83b-c730-4de5-915d-04d76c88398c
:END:
Set with a single binary operation.

The category of magmas, denoted $$ Mag $$, has as objects sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).
** Module :drill:
:PROPERTIES:
:ID:       d96e515e-8f88-413f-a12c-50bdb5f0a096
:END:
Importable organization unit.
** Modulus :drill:
:PROPERTIES:
:ID:       740ee455-cd6f-4ee2-8ba1-46841e8b010a
:END:
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Monad :drill:
:PROPERTIES:
:ID:       b1faf835-213f-4336-86a9-8e331dd60986
:END:
μόνος /monos/ sole
μονάδα /monáda/ unit

A [[Monoid]] in [[Endofunctor category]].
Monads are [[Applicative functor][applicative functors]] with natural transformation.

Mostly Monads used for sequencing actions (that looks like imperative programming), there are Commutative Monads that do not order actions.

Monadic internals are Haskell data types, so they can be consumed any number of times.

Monad can shorten/terminate sequence of computations. It is implemented inside Monad instance. For example Maybe Monad on Nothing drops chain of computation and returns Nothing.

Monad and Applicative according instances must have the same behaviour, this usually expressed in the form:
#+begin_src haskell
import Control.Monad (ap)

(<*>) == ap
#+end_src
*** Functor -> Applicative -> Monad progression
#+begin_src haskell
<$> ::     Functor f =>    (a -> b)   -> f a -> f b
<*> :: Applicative f =>   f (a -> b)  -> f a  -> f b
flip >>= ::  Monad f =>   (a -> f b)  -> f a  -> f b
#+end_src
This is [[Natural transformation]]s.
*** Monad type class
#+begin_src haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
#+end_src

*** Monad functions
**** Return
#+begin_src haskell
return == pure
#+end_src
[[Nonstrict]].
**** Bind
#+begin_src haskell
>>= :: Monad f => f a -> (a -> f b) -> f b
#+end_src
[[Nonstrict]].

The most ubiqutous way to >>= something is to use [[Lambda function]]:
#+begin_src haskell
getLine >>= \name -> putStrLn "age pls:"
#+end_src

Also very neet way is to bundle and handle Monad - is to bundle it with bind, and leave applied partially.
And use that partial bundle as a function - every evaluation of the function would trigger evaluation of internal Monad structure. Thumbs up. 
#+begin_src haskell
printOneOf ∷ Bool → IO ()
printOneOf False = putStr "1"
printOneOf  True = putStr "2"

quant ∷ (Bool → IO b) → IO b
quant = (>>=) (randomRIO (False, True))

recursePrintOneOf ∷ Monad m ⇒ (t → m a) → t → m b
recursePrintOneOf f x = (f x) >> (recursePrintOneOf f x)

main ∷ IO ()
main = recursePrintOneOf (quant) $ printOneOf
#+end_src
***** (>>=)
See [[Bind]]
**** Join
#+begin_src haskell
join :: Monad m => m (m a) -> m a
#+end_src
Flattens two layers of structure into one.
Join is a generalization of `concat`.

The way to express ordering in lambda calculus is to nest.
***** join.fmap == (=<<)
#+begin_src haskell
-- b = f b
fmap      :: Monad f => (a -> f b) -> f a -> f (f b)
join      :: Monad f =>                      f (f a) -> f a
join.fmap :: Monad f => (a -> f b) -> f a            -> f b
flip >>=  :: Monad f => (a -> f b) -> f a            -> f b
#+end_src

**** Sequencing operator (>>) == (*>):
Discards any resulting value of the action and sequence next action.
#+begin_src haskell
(>>) :: m a -> m b -> m b
(*>) :: f a -> f b -> f b
#+end_src
Applicative has a similar operator.
*** Monad OR Applicative
**** Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>='
If you wrote code and really needed only those - move that code to Applicative.
#+begin_src haskell
return -> pure
ap -> <*>
liftM -> liftA -> <$>
>> -> *>
#+end_src
**** Basic case when Applicative can be used
Can be rewriten in [[Applicative]]:
#+begin_src haskell
func = do
  a <- f
  b <- g
pure (a, b)
#+end_src

Can't be rewritten in [[Applicative]]:
#+begin_src haskell
somethingdoSomething' n = do
a <- f n
b <- g a
pure (a, b)
#+end_src
(f n) creates monadic structure, binds ot to /a/ wich is consumed then by g.
**** Applicative block vs Monad block
With Type Applicative every condition fails/succseeds independently. It needs a boilerplate data constructor/value pattern matching code to work. And code you can write only for so many cases and types, so boilerplate can not be so flexible as Monad that allows polymorphism.
With Type Monad computation can return value that dependent from the previous computation result. So abort or dependent processing can happen.
*** Maybe monad
Drops the chain of computation and returns Nothing as soon as Nothing arrives.
*** Either monad
Drops sequencing computation as soon as Left arrives.
*** Monad laws
[[Pure]] ([[Return]]) should only put [[Argument][argument]] into structure.
**** Monad left identity law
#+begin_src haskell
return x >>= f == f x
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f =>    f a  -> (a -> f b) -> f b
                  pure x >>=     f      == f x
#+end_src
Shows that >>= must get [[Argument]] internal to structure nad apply it to the second argument.

**** Monad right identity law
#+begin_src haskell
f >>= return == f
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f => f a  -> (a -> f b) -> f b
                  f   >>=    pure    == f
#+end_src
[[Tacit]] description of [[Monad][monad]] as [[Endofunctor][endofunctor]].

**** Monad associativity law
#+begin_src haskell
(m >>= f) >>= g == m >>= (\x -> f x >>= g)
#+end_src

*** Comonad
[[Category]] $$ C $$ comonad is a [[Monad][monad]] of oposite category $$ C^{op} $$.
** Monkey patch :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       8b05451a-ed92-464d-884a-654d9b5dad6a
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 20:08]
:END:
/From [[Guerrilla patch]]./

/*/ is a way for program to modify supporting system software affecting only the running instance of the program.
** Monoid :drill:
:PROPERTIES:
:ID:       6593c8fb-adda-488b-b86f-9544f62868eb
:END:
[[Semigroup]] that has [[Identity]] value.

#+begin_src haskell
class Monoid m where
mempty :: m
mappend :: m -> m -> m
mconcat :: [m] -> m
mconcat = foldr mappend mempty
#+end_src
*** Monoid laws
**** Monoid left identity law
#+begin_src haskell
mempty <> x = x
#+end_src

**** Monoid right identity law
#+begin_src haskell
x <> mempty = x
#+end_src

**** Monoid associativity law
#+begin_src haskell
x <> mempty = x (y <> z) = (x <> y) <> z
mconcat = foldr (mempty <>)
#+end_src

*** Commutative monoid
Commutative law:
$$ x \circ y = y \circ x $$
Very helpful at concurrent or distributed processing.
**** /*/
***** Abelian monoid
See [[Commutative monoid]]
** Monoidal functor :drill:
:PROPERTIES:
:ID:       8bafa7f0-72b2-4706-a623-69c5f09ab964
:END:
Functors between [[Monoid][monoidal]] [[Category][categories]] that preserves monoidal structure.
** Morphism :drill:
:PROPERTIES:
:ID:       8d0a8700-c48a-4195-8bd2-52a1b3866d76
:END:
μορφή /morphe/ form
Map between two objects in an abstract [[Category][category]].

Morphism is a generalization ($$ f(x*y) \equiv f(x) \diamond f(y) $$) of [[Homomorphism]] ($$ f(x*y) \equiv f(x) * f(y) $$).
Under morphism almost always mean homomorphism-like properties.

If some morphism corresponds to function requirements - than it is a [[Function]].
*** Homomorphism
ὁμός /homos/ same (chosen by initial Anglish mistranslation "similar")
μορφή /morphe/ form
similar form

Homomorphism is a map between two algebraic structures of the same type, that preserves the operation of the structures.
This means a map $$ f:A\to B $$ between two sets $$ A, B $$ equipped with the same structure such that, if $$ ∗ $$ is an operation of the structure (supposed here, for simplification, to be a binary operation), then $$ f(x*y)=f(x)*f(y) $$.

The concept of homomorphism has been generalized under the name of [[Morphism][morphism]] to many other structures that either do not have an underlying set, or are not algebraic.

Homomorphisms send [[Identity morphism][identities]] to identities and inverses to inverses.
Homomorphism preserves operations, as such:
=*= homomorphism - map between =*= and preserves =*= operations
  case =*= of:
  * semigroup
  * monoid
  * groups
  * ring
  * linear map
  * module
  * algebra
**** /*/
***** Homomorphic
See [[Homomorphism]]
*** Identity morphism
Identity morphism - or simply identity: $$ x \in C : \; id_{x}=1_{x} : x \to x $$
Composed with other morphism gives same morphism.

Corresponds to [[Reflexivity]] and [[Automorphism]].
**** Identity
Identity only possible with morphism. See [[Identity morphism]].

There is also knowledge of [[Zero]] value.
***** Two-sided identity of a predicate
$$ P() $$ is [[Commutative][commutative]].
$$ \exist e \in S, \forall a \in S : \; P(e,a)=P(a,e)=a $$

[[Predicate]]
***** Left identity of a predicate
$$ \exist e \in S, \forall a \in S : \; P(e,a)=a $$

[[Predicate]]
***** Right identity of a predicate
$$ \exist e \in S, \forall a \in S : \; P(a,e)=a $$

[[Predicate]]
**** Identity function
Return itself.
(\x.x)
#+begin_src haskell
id :: a -> a
#+end_src
*** Monomorphism
μονο /mono/ only
μορφή /morphe/ form

Initial set of /f/ is fully uniquely mapped onto the image of /f/.
Left is mono (uniquely) mapped to the right, so left [[Domain][domain]] can be equal or less to the right [[Codomain][codomain]].
It is [[Injection][injective]].
It always has a inverse morphism.

$$ f^{X \to Y}, \forall x \in X \, \exists y=f(x) \vDash f(x) = f_{mono}(x) $$ - from [[Homomorphism]] context
$$ f_{mono} \circ g1 \equiv f_{mono} \circ g2 \vDash \; g1 \equiv g2 $$ - from general [[Morphism]] context
Thus it is left canselable.
**** /*/
***** Monomorphic
See [[Monomorphism]].
*** Epimorphism
επι /epi/ on, over
μορφή /morphe/ form

Image fully uses codomain - epimorphism.
It is surjective.

$$ f^{X \to Y}, \forall y \in Y \, \exists f(x) \vDash f(x)=f_{epi}(x) $$ - from [[Homomorphism]] context
$$ g_1 \circ f_{epi} \equiv g_2 \circ f_{epi} \vDash \; g_1 = g_2 $$ - from general [[Morphism]] context
Thus it is right canselable.

Left is epi to the right. So left is bigger or equal then the right. And right is a projection of the left.
**** /*/
***** Epimorphic
See [[Epimorphism]].
*** Isomorphism
ἴσος /isos/ equal
μορφή /morphe/ form

Morphism that has inverse morphism.
[[Bijection][Bijective]] [[Homomorphis][homomorphism]] is also isomorphism.

$$ f^{-1, b \to a} \circ f^{a \to b} \equiv id^a, \; f^{a \to b} \circ f^{-1, b \to a} \equiv id^b $$

2 reasons for non-isomorphism:
- function at least ones collapses a values of domain into one value in codomain
- image (of a function in codomain) does not fill-in codomain. Then isomorphism can exists for image but not whole codomain.
**** /*/
***** Isomorphic
See [[Isomorphism]].
*** Endomorphism
ενδο /endo/ internal
μορφή /morphe/ form

Morphism whose [[Domain][domain]] equals the [[Codomain][codomain]].
Epimorphism is a [[Monoid]], because of [[Category]] [[Composition]].
**** Automorphism
\alpha\upsilon\tau\omicron /auto/ self
μορφή /form/ form

[[Endomorphism]] that is [[Isomorphism]].

Corresponds to [[Identity]] and [[Reflexivity]].
***** /*/
****** Automorphic
See [[Automorphism]]
**** /*/
***** Endomorphic
See [[Endomorphism]]
*** Catamorphism
κατά /kata/ downward
μορφή /morphe/ form

Denotes the unique [[Homomorphism][homomorphism]] from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
**** /*/
***** Catamorphic
See [[Catamorphism]]
** Natural transformation :drill:
:PROPERTIES:
:ID:       8591d1eb-0f0f-4f0e-b46b-05a4262646da
:END:
Roughly  /*/ is:
#+begin_src haskell
trans :: forall a. F a -> G a
#+end_src

/*/ provides a way of transforming one [[Functor]] into another, while respecting the internal structure (i.e., the [[Composition]] of [[Morphism]]s) of the [[Category][categories]] involved.
/*/ is a "morphism of functors", especially in functor categories.

** newtype declaration :drill:
:PROPERTIES:
:ID:       f9bbca43-6672-48e8-8d1c-af323786efc2
:END:
Creates a new type from old type using a new constructor.
#+begin_src haskell
newtype FirstName = FirstName String
#+end_src

Data will have exactly the same representation at runtime, as the type that is wrapped.

#+begin_src haskell
newtype Book = Book (Int, Int)
#+end_src
#+begin_src text
      (,)
      / \
Integer Integer
#+end_src
** Node :drill:
:PROPERTIES:
:ID:       44946197-24dd-48fd-810c-6af851f6a0cf
:END:
#+begin_src text
 *
/ \
#+end_src
** NonEmpty list data type :drill:
:PROPERTIES:
:ID:       809c682b-457e-47df-bdfd-92302d3c42da
:END:
Data.List.NonEmpty
Has a Semigroup instance but can't have a Monoid instance. It never can be an empty list.

#+begin_src haskell
data NonEmpty a = a :| [a]
  deriving (Eq, Ord, Show)
#+end_src

:| - an infix data costructor that takes two (type) arguments. In other words :| returns a product type of left and right
** Normal form :drill:
:PROPERTIES:
:ID:       728a6769-55f0-41a3-bb0c-acfa02096e7f
:END:
In context: [[Beta normal form]]
** Nothing :drill:
:PROPERTIES:
:ID:       350c03dd-e563-4d42-b554-d38370619667
:END:
Any Haskell expression can't return nothing.
** Open formula :drill:
:PROPERTIES:
:ID:       dc5f353b-84dc-4bce-85e2-eaa56f18401f
:END:
[[Function]] with [[Arity][arity]].
** Operation :drill:
:PROPERTIES:
:ID:       10f782ae-17e5-434e-8d2e-ee8ee3f9b530
:END:
[[Function][Function]]. Word used in mathematics. Often a symbol, [[Infix][infix]], binary.
** Operator :drill:
:PROPERTIES:
:ID:       ad158f22-64c6-44c6-b140-4fc5c2b065f7
:END:
[[Infix]] [[Function][function]].
** Orphan type instance :drill:
:PROPERTIES:
:ID:       9a4837d3-82e9-49f1-860d-e198013a60b5
:END:
[[Type instance]] that appeared from inconsistent code base. Duplicate of instance, or instance present on [[Type class][type class]] or on the [[Type][type]] level.

Solution for addressing orphan instances:
1. You defined the type but not the type class?
Put the instance in the same module as the type so that the type cannot be imported without its instances.
2. You defined the type class but not the type?
Put the instance in the same module as the type class definition so that the type class cannot be imported without its instances.
3. Neither the type nor the type class are yours?
Define your own newtype wrapping the original type and now you’ve got a type that “belongs” to you for which you can rightly define type class instances. There are means of making this less annoying which we’ll discuss later.
** Parameter :drill:
:PROPERTIES:
:ID:       737527a3-4fcf-4499-9d27-6fab664d9da0
:END:
παρά /para/ subsidiary
μέτρον /metron/ measure

Or Formal Parameter - named varible of a [[Function][function]].
Is variable defined in function definition.
Contrary to the [[Argument]] wich is a supplied value to a function.
** Partial application :drill:
:PROPERTIES:
:ID:       3ec44a13-f6e9-4ba4-b0af-1c12b8017775
:END:
Part of [[Function][function]] [[Parameter][parameters]] [[Application][applied]].
** Partial function :drill:
:PROPERTIES:
:ID:       d8d7edc3-b943-4afa-8832-ddb2ef2a386d
:END:
One that does not cover all [[Domain]].
Unsafe and causes trouble.
** Permutation :drill:
:PROPERTIES:
:ID:       af01cb45-6b61-4b9f-bac6-390a2ec82a5c
:END:
[[Bijective]] [[Function]] from [[Domain][domain]] to itself.
** Point-free :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       4a6fc5de-f277-4bb9-afd0-6dcb3698b317
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 15:58]
:END:
/Use Tacit very carefully - it hides types and harder to change code where it is used./
/Use just enough Tacit to communicate better. Mostly only partial point-free communicates better./

Point-free style, is a paradigm in which functions only describe the [[Morphism]] itself.
If brackets /()/ can be changed to /$/ then $ equal to [[Composition]]:
#+begin_src haskell
\x -> g (f x)
\x -> g $ f x
\x -> g . f $ x
\x -> g . f -- eta-recution

\x1 x2 -> g (f x1 x2)
\x1 x2 -> g $ f x1 x2
\x1 x2 -> g . f x1 $ x2
\x1    -> g . f x1
#+end_src
*** \eta-abstraction :drill:
:PROPERTIES:
:ID:       c385db49-d92d-4b80-85b9-ecd8b786671e
:END:
$$ (\lambda x.Mx) \xleftarrow[\eta]{} M $$
**** /*/
***** \eta-reduction
See [[\eta-abstraction]]
***** \eta-conversion
See [[\eta-abstraction]]
***** eta-abstraction
See [[\eta-abstraction]]
***** eta-reduction
See [[\eta-abstraction]]
***** eta-conversion
See [[\eta-abstraction]]
*** Blackbird :drill:
:PROPERTIES:
:ID:       76123e3b-3042-4112-beaf-7f281c13e58a
:END:
#+begin_src haskell
(.).(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
#+end_src

[[Composition]] of compositions =(.).(.)= allows to compose =f1(c) . f2(a,b)=. During composition allows to apply two arguments to a binary function.
#+begin_src haskell
\f g x y -> f (g x y)
#+end_src
**** /*/
***** .) .
See [[Blackbird]]
***** Sectioning
See [[Blackbird]]
***** (.).(.)
See [[Blackbird]]
*** Swing :drill:
:PROPERTIES:
:ID:       1d5d1b4c-2390-4ebd-b79c-23ed3deec10e
:END:
#+begin_src haskell
swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
swing = flip . (. flip id)
swing f = flip (f . runCont . return)
swing f c a = f ($ a) c
#+end_src

*** Squish :drill:
:PROPERTIES:
:ID:       4813e27d-4ac4-415f-95c5-323b605c1de6
:END:
#+begin_src haskell
f >>= a . b . c =<< g
#+end_src

*** /*/
**** Pointfree
See [[Point-free]]
**** Tacit
See [[Point-free]]
**** Tacit programming
See [[Point-free]]
** Polymorphism :drill:
:PROPERTIES:
:ID:       83a22f3c-9140-490c-9390-85319566a443
:END:
At once several forms.

To [[Abstraction][abstract]] over [[Data type][data types]].


/Antonym - [[Monomorphism]]./

Types:
*** Levity polymorphism
Levity polymprphism is when polymorphism works with lifted and [[Unlifted type][unlifted types]].
*** Parametric polymorphism
[[Abstraction][Abstracting]] over [[Data type][data types]] by [[Parameter][parameter]].

/In most languages named as 'Generics' (generic programming)./

Types:
**** Rank-1 polymorphism
[[Parametric polymorphism]] in [[Type rank][rank-1 types]] by type variables.
***** /*/
****** Prenex
See [[Rank-1 polymorphism]]
****** Prenex polymorpism
See [[Rank-1 polymorphism]]
**** Let-bound polymorphism
It is property chosen for Haskell type system.
Haskell is based on Hindley-Milner type system, it is let-bound.
It means that to have strict [[Type inference][type inference]] - if `let` and `where` declarations a polymorphic - $\lambda$ declarations - should be not.
So:
#+begin_src haskell
foo :: (Int, Char)
foo = (\f -> (f 1, f 'a')) id
#+end_src
Is illegal in Haskell.

Lambda-bound function (i.e., one passed as argument to another function) cannot be instantiated in two different ways, if there is a let-bound polymorphism.
**** Constrained polymorphism
Constrained [[Parametric polymorphism]].
***** Ad hoc polymorphism
Artificial [[Constrained polymorphism][constrained polymorphism]] dependent on incoming [[Data type][data type]].
Achieved by creating a [[Type class][type class]] [[Function][functions]].
It is interface dispatch mechanism by data types.

/Commonly known as overloading./
**** Impredicative polymorphism
The most powerful form of [[Parametric polymorphism]].
First see [[Impredicative]].

Impredicative polymorphism allows type τ entities with polymorphic types, that can contain type τ itself.
$$ T = \forall X. X \to X : \; T \in X \vDash T \in T $$
This approach has Russell's paradox (and its form - Girard's paradox).
***** /*/
****** First-class polymorphism
More default term: [[Impredicative polymorphism]].
**** Higher-rank polymorphism
Means that polymorphic types can apper within other types (types of function).
There is a cases where higher-rank polymorphism than the a Ad hoc - is needed. For example where ad hoc polymorphism is used in constraints of several different implementations of functions, and you want to build a function on top - and use the abstract interface over these functions.
#+begin_src haskell
-- ad-hoc polymorphism
f1 :: forall a. MyType Class a => a -> String    ==    f1 :: MyType Class a => a  -> String
f1 = -- ...

-- higher-rank polymorphism
f2 :: Int -> (forall a. MyType Class a => a -> String) -> Int
f2 = -- ...
#+end_src
By moving `forall` inside the function - we can achive higher-rank polymorphism.

From: https://news.ycombinator.com/item?id=8130861
#+begin_src text
Higher-rank polymorphism is formalized using System F, and there are a few implementations of (incomplete, but decidable) type inference for it - see e.g. Daan Leijen's research page [1] about it, or my experimental implementation [2] of one of his papers. Higher-rank types also have some limited support in OCaml and Haskell.
#+end_src

Useful example aslo a [[ST-Trick monad]].
***** /*/
****** Rank-n polymorphism
See: [[Higher-rank polymorphism]]
*** Subtype polymorphism
Allows to declare usage of a Type and all of its Subtypes.
T - Type
S - Subtype of Type
<: - subtype of
$$ S <: T = S \le T $$

Subtyping is:
If it can be done to T, and there is subtype S - then it also can be done to S.
$$ S <:T : \; f^{T \to X} \Rightarrow f^{S \to X} $$
*** Row polymorphism
# NOTE: 2019-03-11: Currently WIP in https://github.com/ghc-proposals/ghc-proposals/pull/180 
Is a lot like Subtype polymorphism, but alings itself on allowence (with | r) of subtypes and types with requested properties.
#+begin_src haskell
printX :: { x :: Int | r } -> String
printX rec = show rec.x

printY :: { y :: Int | r } -> String
printY rec = show rec.y

-- type is inferred as `{x :: Int, y :: Int | r } -> String`
printBoth rec = printX rec ++ printY rec
#+end_src
*** Kind polymorphism
Achieved using a phantom type argument in the data type declaration.
#+begin_src haskell
;;         * -> *
data Proxy a = ProxyValue
#+end_src
Then, by default the data type can be inhabited and fully work being partially defined.
But multiple instances of kind polymorphic type can be distinguished by their particular type.

Example is the [[Proxy type]]:
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- * :: Proxy Int
let proxy2 = (ProxyValue :: Proxy a)   -- * -> * :: Proxy a
#+end_src

*** Linearity polymorphism
Leverages [[Linear type][linear types]].
For exampe - if fold over a dynamic array:
  1) In basic Haskell - array would be copied at every step.
  2) Use low-level unsafe functions.
  3) With Linear type function we guarantee that the array would be used only at one place at a time.

So, if we use a function (* -o * -o -o *) in foldr - the fold will use the initial value only once.
** Pragma :drill:
:PROPERTIES:
:ID:       92784b03-a83b-4599-9cd0-f2210dd5e177
:END:
Pragma - instruction to the compiler that specifies how a compiler should process the code.
Pragma in Haskell have form:
#+begin_src haskell
{-# PRAGMA options #-}
#+end_src
*** LANGUAGE pragma
Controls what variations of the language are permitted.
It has a set of allowed options: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html, which can be supplied.
**** LANGUAGE option
***** Useful by default
#+begin_src haskell
import EmptyCase
import FlexibleContexts
import FlexibleInstances
import InstanceSigs
import MultiParamTypeClasses
#+end_src
***** AllowAmbiguousTypes
Allow type signatures which appear that they would result in an unusable binding.
However GHC will still check and complain about a functions that can never be called.
***** ApplicativeDo
Enables an alternative in-depth reduction that translates the do-notation to the operators =<$>=, =<*>=, =join= as far as possible.

For GHC to pickup the patterns, the final statement must match one of these patterns exactly:

#+begin_src haskell
  pure E
  pure $ E
  return E
  return $ E
#+end_src

When the statements of do expression have dependencies between them, and ApplicativeDo cannot infer an Applicative type - GHC uses a heuristic $$ O(n^2) $$ algorithm to try to use <*> as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is aslo $$ O(n^3) $$ algorithm that finds the optimal solution: =[[-foptimal-applicative-do]]=.

Requires =ap = <*>=, =return = pure=, which is true for the most monadic types.
  * Allows use of do-notation with types that are an instance of Applicative and Functor
  * In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.

The only way it shows up at the source level is that you can have a =do= expression with only Applicative or Functor constaint.

It is possible to see the actual translation by using =[[-ddump-ds]]=.
***** ConstrainedClassMethods
Enable the definition of further constraints on individual class methods.

***** ConstraintKinds
Constraints are just handled as types of a particular kind (Constraint).
Any type of the kind Constraints can be used as a constraint.
Kind Constraint are:
  * Anything which is already allowed in code as a constraint without /*/. Saturated applications to type classes, implicit parameter and equality constraints.
  * [[Tuple]]s, all of whose component types have kind Constraint.
  #+begin_src haskell
  type Some a = (Show a, Ord a, Arbitrary a) -- is of kind Constraint.
  #+end_src
  * Anything form of which is not yet known, but the user has declared for it to have kind Constraint (for which they need to import it from GHC.Exts):
  #+begin_src haskell
  Foo (f :: Type -> Constraint) = forall b. f b => b -> b -- is allowed
  -- as well as examples involving type families:
  type family Typ a b :: Constraint
  type instance Typ Int  b = Show b
  type instance Typ Bool b = Num b

  func :: Typ a b => a -> b -> b
  func = ...
  #+end_src

***** CPP
Enable [[https://en.wikipedia.org/wiki/C_preprocessor][C preprocessor]].
***** DeriveFunctor
Automatic deriving of [[Type class instance][instance]]s for the Functor type class.
Since there is only one possible [[Functor][functor]] for any [[Data type][type]] - it is possible to check that it is derived right.
Allows does not care about writing Functor instances.
***** ExplicitForAll
Allow explicit forall quantificator in places where it is implicit by Haskell.
***** FlexibleContexts
Ability to use complex constraints in class declaration contexts.
The only restriction on the context in a class declaration is that the class hierarchy must be acyclic.
#+begin_src haskell
class C a where
  op :: D b => a -> b -> b

class C a => D a where ...
#+end_src
$$ C :> D $$, so in C we can talk about D.

Synergizes with [[ConstraintKinds]].
***** FlexibleInstances
Allow type class instances types contain nested types.
#+begin_src haskell
instance C (Maybe Int) where ...
#+end_src
Implies [[TypeSynonymInstances]].
***** GeneralizedNewtypeDeriving
Enable GHC’s =newtype= cunning generalised deriving mechanism.
#+begin_src haskell
newtype Dollars = Dollars Int
  deriving (Eq, Ord, Show, Read, Enum, Num, Real, Bounded, Integral)
#+end_src
(In old Haskell-98 only Eq, Ord, Enum could been inherited.)
***** ImplicitParams
Allow definition of functions expecting implicit parameters. In the Haskell that has static scoping of variables allows the dynamic scoping, such as in classic Lisp or ELisp.
Sure thing this one can be puzzling as hell inside Haskell.
***** LambdaCase
Enables expressions of the form:
#+begin_src haskell
\case { p1 -> e1; ...; pN -> eN }

-- OR

\case
  p1 -> e1
  ...
  pN -> eN
#+end_src

***** MultiParamTypeClasses
Implies: [[ConstrainedClassMethods]]
Enable the definitions of typeclasses with more than one parameter.
#+begin_src haskell
class Collection c a where
#+end_src

***** MultiWayIf
Enable multi-way-if syntax.
#+begin_src haskell
if | guard1 -> expr1
   | ...
   | guardN -> exprN
#+end_src

***** OverloadedStrings
Enable overloaded string literals (string literals become desugared via the IsString class).
Now string literal has type:
#+begin_src haskell
(IsString a) => a
#+end_src

The usual string syntax can be used, e.g., for ByteString, Text, and other variations of string like types.
Now they can be used in pattern matches as char->integer translations. To pattern match Eq must be derived.

To use class IsString - import it from GHC.Ext
***** PartialTypeSignatures
Partial type signature containins wildcards, placeholders (=_=, =_name=).
Allows programmer to which parts of a type to annotate and which to infer. Also applies to constraint part.

As untuped expression, partly typed can not polymorphicly recurse.

[[-Wno-partial-type-signatures]] supresses infer warnings.
***** RankNTypes
Enable types of arbitrary rank.
See [[Type rank]].

Implies [[ExplicitForAll]].

Allows =forall= quantifier:
  * Left side of \to
  * Right side of \to
  * as [[Argument][argument]] of a constructor
  * as type of a field
  * as type of an implicit parameter
  * used in pattern type signature of [[Lexically scoped type variables]]

It can synergyze with [[ScopedTypeVariables]].
***** ScopedTypeVariables
By default type variables do not have a scope except inside type signatures where they are used.

When there are internall type signatures provided in the code block (=where=, =let=, etc.) they (main type description of a function and internal type descriptions) restrain one-another and become not trully polymorphic, which creates a bounding interdependency of types that GHC would complain about.

/*/ option provides the [[Lexical scope][lexical scope]] inside the code block for [[Type variable][type variables]] that have [[Forall quantifier][forall quantifier]]. Because they are now lexiacally scoped - those type variables are used across internal type signatures.

For details see: https://ocharles.org.uk/guest-posts/2014-12-20-scoped-type-variables.html

Implies [[ExplicitForAll]].
***** TupleSections
Allow tuple section syntax:
#+begin_src haskell
(, True)
(, "I", , , "Love", , 1337)
#+end_src

***** TypeApplications
Allow type application syntax:
#+begin_src haskell
read @Int 5

:type pure @[]
pure @[] :: a -> [a]

:type (<*>) @[]
(<*>) @[] :: [a -> b] -> [a] -> [b]

--

instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)

λ> ($ 0) <$> generate (arbitrary @(Int -> Int))
#+end_src

***** TypeFamilies
Allow use and definition of indexed type and data families.

/*/ are type-level programming.
/*/ are overload data types in the same way that type classes overload functions.
/*/ allow handling of dependent types. Before it [[Functional dependencies]] and [[GADTs]] were used to solve that.
/*/ useful for generic programming, creating highly parametrised interfaces for libraries, and creating interfaces with enhanced static iformation (much like dependent types).

Implies: [[MonoLocalBinds]], [[KindSignatures]], [[ExplicitNamespaces]]

Two types of /*/ are:
****** Data families
****** Type synonym families
***** TypeSynonymInstances
Now type synonim can have it's own type class instances.
***** UndecidableInstances
Permit instances which may lead to type-checker non-termination.

GHC has [[Instance termination rules]] regardless of [[FlexibleInstances]] [[FlexibleContexts]].
***** ViewPatterns
#+begin_src haskell
size (view -> Unit) = 1
size (view -> Arrow t1 t2) = size t1 + size t2
#+end_src
(/expression/ \to /pattern/): what came to match - apply the /expression/, then do /pattern/-match.
[[Semantics]]:
  * variables of /expression/ and /pattern/ are shared
  * if /expression/ :: t1 -> t2 && /pattern/ :: t2, then (/expression/ \to /pattern/) :: t1.

/*/ are like [[Pattern guard][pattern guards]] that can be nested inside of other patterns.
/*/ are a convenient way to pattern-match [[Algebraic data type][algebraic data type]].
***** DatatypeContexts
Allow [[Context][contexts]] in [[Data type][data types]].
#+begin_src haskell
data Eq a => Set a = NilSet | ConsSet a (Set a)

-- NilSet :: Set a
-- ConsSet :: Eq a => a -> Set a -> Set a
#+end_src
Considered misfeature, deprecated, going to be removed.
**** How to make a GHC LANGUAGE extension
In `libraries/ghc-boot-th/GHC/LanguageExtensions/Type.hs` add new constructor to the `Extension` type
#+begin_src haskell
data Extension
  = Cpp
  | OverlappingInstances
  ...
  | Foo
#+end_src

`/main/DynFlags.hs` extend `xFlagsDeps`:
#+begin_src haskell
xFlagsDeps = [
  flagSpec "AllowAmbiguousTypes" LangExt.AllowAmbiguousTypes,
  ...
  flagSpec "Foo"                 LangExt.Foo
]
#+end_src
It is for basic case. For testing, parser see further: https://blog.shaynefletcher.org/2019/02/adding-ghc-language-extension.html
*** Pragma option
Values supplied to the [[Pragma]] directive.
** Predicate :drill:
:PROPERTIES:
:ID:       6f4b0532-ca5f-4ec6-b827-bceb4afb0d3f
:END:
[[Assertion]] [[Function][function]] that includes [[Variable][variable]] and results in true or false statement.

Notation: $$ P(x) $$
[[Application]] of [[Argument][argument]] yealds true or false predicate.
** Predicative :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       aee54dbf-2387-403e-9589-f93bcb416963
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 1.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 13:22]
:END:
Non-self-referencing definition.

---

/Antonym - [[Impredicative]]./
** Principal type :drill:
:PROPERTIES:
:ID:       55ec2cac-10dc-4a09-a795-4e99c7e5aaed
:END:
The most generic [[Data type][data type]] that still typechecks.
** Principle of compositionality :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       d8df7582-1e97-4cf9-9d0d-146ede21ad1f
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 16:02]
:END:
The meaning of a complex [[Expression][expression]] is determined by the meanings of its constituent expressions and the rules used to combine them.
Phrases are [[Composition][composable]] expressions.
** Proxy type :drill:
:PROPERTIES:
:ID:       a895477f-99de-4a09-bc9d-dc2c86e0a0af
:END:
Proxy type holds no data, but has a phantom parameter of arbitrary type (or even kind). Able to provide type information, even though has no value of that type (or it can be may too costly to create one).
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- a has kind `Type`
let proxy2 = (ProxyValue :: Proxy List) -- a has kind `Type -> Type`
#+end_src
** \Psi-combinator :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       dd833dc5-91f9-4bec-aa5a-e292dfb387d8
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 22:13]
:END:
Transforms two of the same type into one of some type. By applying mediate transformation, and applying combination of them into result.
#+begin_src haskell
import Data.Function (on)
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
#+end_src
*** /*/
**** Psi-combinator
See: [[\Psi-combinator]]
**** On-combinator
See: [[\Psi-combinator]]
** Purity :drill:
:PROPERTIES:
:ID:       5c84fbd6-2c97-464f-9431-965dd8c91aef
:END:
[[Referential transparency][Referential transparent]] [[Function][function]]
** Quantifier :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       ac758691-4dc3-4e6c-9f18-59793263a845
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 16:02]
:END:
Specifies the quantity of specimens.

Two most common quantifiers $$ \forall $$ ([[Forall]]) and $$ \exists $$ (Exists).
*** Forall quantifier
Permits to not [[Type inference][infer]] the type, but to use any that fits. The variant depends on the [[LANGUAGE option]] used:
[[ScopedTypeVariables]]
[[RankNTypes]]
[[ExistentialQuantification]]
**** /*/
***** Forall
See [[Forall quantifier]]
** Recursion :drill:
:PROPERTIES:
:ID:       2e2d87ae-d918-47fc-b810-f95366fe4039
:END:
Repeated function application allow computing results that may require indefinite amount of work.
** Redex :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       3d5326a4-74a7-433d-860a-2590072bb61d
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 15:00]
:END:
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction :drill:
:PROPERTIES:
:ID:       11776f99-f2e5-46fd-a566-8e08060fd7f0
:END:
See [[Beta reduction]]
** Referential transparency :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       b7cbd6cd-5739-431a-9eae-5922e60dff81
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 1.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 22:12]
:END:
Returns the same output given the same values to evaluate.

/*/ [[expression]] - can be replaced with its corresponding resulting value without change for program's behavior.
/*/ [[Function][functions]] are called [[Pure][pure]].
** Relation :drill:
:PROPERTIES:
:ID:       ab1fec36-4201-4970-a717-70d56aa09e1b
:END:
Is not directed and not limited.
** REPL :drill:
:PROPERTIES:
:ID:       f77f5734-1b15-4192-be41-f0ee8ac15441
:END:
Interactive CLI. Read-eval-print loop.
** Scope :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       a2989c15-2adc-403a-add7-35855e9de65c
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:39]
:END:
Area where [[Bind][bind]]s are accessible.
** Sectioning :drill:
:PROPERTIES:
:ID:       c8cadab6-16e6-4d0e-9b79-6e3b56dcbd8e
:END:
Writing [[Function][function]] in a parentheses. Allows to pass around [[Partial application][partially applied]] [[Function][functions]].
** Semantics :drill:
:PROPERTIES:
:ID:       f47d8882-a0eb-4956-9b87-56ac0c20d069
:END:
Philosophical study of meaning.
*** Operational semantics
Properties, such as correctness, safety or security, are verified by constructing proofs from logical [[Assertion][statements]] about execution and procedures.

Good to solve in-point localized tasks.
Process of abstraction.
*** Denotational semantics
Constructing mathematical objects (called denotations), that describe the meanings. It is an abstractions that are ment, laying above the code, allow to implement and reason about the code. Sometimes /*/ can be directly represented in the implementation, but it is not strict requirement.

Good to achive more broad approach/meaning.
Also see [[Abstraction]].

/*/ are [[Composition][composable]].
*** Axiomatic semantics
Describing effect of operation on assertions about the overall state.

Good for examining interconnections.
Empirical process.
** Semigroup :drill:
:PROPERTIES:
:ID:       7e67196b-643c-4726-8a17-6207826764bb
:END:
$$ \forall (a,b,c) \in S : \; P(a,P(b,c)) \equiv P(P(a,b),c) $$

Semigroup - [[Magma]] with [[Associative law][associative law]].
Semigroup is closed (forms a closed set).

Defined in Haskell as:
#+begin_src haskell
class Semigroup a where
(<>) :: a -> a -> a
#+end_src

** Set :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       3065b5ef-e7af-41af-a46e-201ced7f3c28
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 22:17]
:END:
Well-defined collection of distinct objects.
** SET category :drill:
:PROPERTIES:
:ID:       c6c7f178-7b69-4154-83ed-34de9b102193
:END:
[[Category]] in which [[Object][objects]] are sets.
** Shadowing :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       45b1bebf-431f-45dd-8522-ea688968090f
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 20:08]
:END:
Global [[Scope][scope]] variable overriden by variable in [[Local scope][local scope]].
** Shift operator :drill:
:PROPERTIES:
:ID:       48503777-55e0-4c6e-8675-f220bb2c11c8
:END:
Shift operator defined by Lagrange through Differential operator.
$$ \displaystyle T^{t}=e^{t{\frac {d}{dx}}} $$
*** /*/
**** Shift
See [[Shift operator]]
** Shrinking :drill:
:PROPERTIES:
:ID:       bebb2732-e73d-4d2b-92e1-090ffa883c77
:END:
Process of reducing coplexity in the test case - re-run with smaller values and make sure that the test still fails.
** Singleton :drill:
:PROPERTIES:
:ID:       cd966fe0-f42d-4b75-b388-85649eacc84f
:END:
Singleton - unit set - set with exactly one element.
Also 1-tuple.
** Smart constructor :drill:
:PROPERTIES:
:ID:       e2aded58-a463-4762-97c4-7fc2238d386d
:END:
Place extra [[Constraint][constraints]] on the construction of values.
** Spine :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       9f1c254b-a3dd-4ba5-bdec-7b43be39d49f
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:44]
:END:
Is a chain of memory cells, each points to the both value of element and to the next memory cell.
#+begin_src text
Array:

  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

Spine:
  :
 / \
_   :
   / \
  _   :
     / \
    _  []

#+end_src
** Statement :drill:
:PROPERTIES:
:ID:       0fbcd5d9-8c13-4486-aabe-47c831900548
:END:
Declarative sentence that is true or false.
Gonzales: "What code does."
** Static typing :drill:
:PROPERTIES:
:ID:       3100b260-2b5c-40a7-bc27-2dc6e0f8f3c5
:END:
Static typechecking occurs at [[Compile level][compile level]].
** Structural type :drill:
:PROPERTIES:
:ID:       9fbc8692-d766-4b0b-bb07-76cb11b9aea8
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:24]
:END:
Mathematical [[Type][type]]. They form into [[structural type system]].
** Structural type system :drill:
:PROPERTIES:
:ID:       37dc5166-6ad1-468d-a3c2-d4144ac5bb83
:END:
Strict global hierarchy and relationships of types and their properties.
Haskell type system is /*/.
In most languages typing is name-based, not [[Structural type][structural]].
** Superclass :drill:
:PROPERTIES:
:ID:       7585ab04-6e2e-4908-88c9-28cf2dc9a73e
:END:
Broader parent class.
** Syntatic sugar :drill:
SCHT: <2019-06-10 Mon>
:PROPERTIES:
:ID:       244e15a8-9ae5-4842-82b1-279387d088fd
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-06 Thu 15:20]
:END:
Artificial way to make language easier to read and write.
** System F :drill:
:PROPERTIES:
:ID:       a33a26ee-f5e0-4a70-b01e-dbf9b41b8681
:END:
Formalizes the notion of parametric polymorphism in programming languages.
Differs from the simply typed lambda calculus by the introduction of universal [[Quantifier][quantification]] over types.
** Tail call :drill:
:PROPERTIES:
:ID:       0d5c9709-660d-47c7-b573-7dd06d9cb936
:END:
Final result of the function
** Tail recursion :drill:
:PROPERTIES:
:ID:       62dd2851-710e-4035-9890-6af1c17e6305
:END:
Tail calls are recursive invocantions of itself.
** Tensor :drill:
:PROPERTIES:
:ID:       e165b708-fdd2-4062-be87-b65487de4a0e
:END:
Object existing out of planes, thus it can translate objects from one plane into another.
They can be tried to be described with knowledge existing inside planes, but representation would always be partial, aka [[Ambigram]].
Tensor of rank 1 is a vector.

Tensors can be seen as [[Functor]]s.
** Terminal object :drill:
:PROPERTIES:
:ID:       8d7de2b2-7609-481a-837e-9887e779446f
:END:
Terminal object - is an object I in category C: $$ \exists I \in C : \; \forall X \in C, \, \exists ! (X \to I) $$.
** Testing :drill:
:PROPERTIES:
:ID:       07ea5b8e-05ee-4824-b690-455ab4918d77
:END:
*** Property testing
Since [[Property][property]] has a law, then family of that unit tests can be abstracted into the [[Lambda function][lambda function]].
And tests cases come from [[Generator][generator]].
**** Property
Property corresponds to the according law.
In property testing you need to think additionally about [[Generator][generator]]s and [[Shrinking][shrinking]].
**** Property testing types
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
|                          | Exhaustive                           | Randomized                           | Unit test (Single sample) |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
| Whole set of values      | Exhaustive property test             | Randomised property test             |                           |
| Special subset of values | Exhaustive specialised property test | Randomised specialised property test |                           |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
**** Generator
#+begin_src text
Seed
|
v
Gen A -> A
^
|
Size
#+end_src

Seed allows reproducibility.
There is anyway a need to have some seed.
Size allows setting upper bound on size of generated value. Think about infinity of list.

After failed test - shrinking tests value parts of contrexample, finds a part that still fails, and recurses shrinking.
***** Custom generator
When sertain theorem only works for a specific set of values - the according generator needs to be produced.

#+begin_src haskell
arbitrary :: Arbitrary a => Gen a
suchThat :: Gen a -> (a -> Bool) -> Gen a
elements :: [a] -> Gen a
#+end_src
**** Reusing test code
Often it is convinient to abstract testing of same function properties:

It can be done with (aka TestSuite [[Combinator][combinator]]):
#+begin_src haskell
-- Definition
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
eqSpec :: forall a. Arbitrary a => Spec

-- Usage
{-# LANGUAGE TypeApplications #-}
spec :: Spec
spec = do
  eqSpec @Int
#+end_src

#+begin_src haskell
Eq Int
  (==) :: Int -> Int -> Bool
    is reflexive
    is symetric
    is transitive
    is equivalent to (\ a b -> not $ a /= b)
  (/=) :: Int -> Int -> Bool
    is antireflexive
    is equivalent to (\ a b -> not $ a == b)
#+end_src
***** Commutative property
[[Commutativity]]
#+begin_src haskell
:: Arbitrary a => (a -> a -> a) -> Property
#+end_src
***** Symmetry property
[[Symmetry]]
#+begin_src haskell
:: Arbitrary a => (a -> a -> Bool) -> Property
#+end_src
***** Equivalence property
[[Equivalence]]
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (a -> b) -> Property
#+end_src
***** Inverse property
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (b -> a) -> Property
#+end_src

**** QuickCheck
`SomethingSomething` is a member of the Arbitrary type class.
`SomethingSomething -> Bool` is something `Testable`.
Generator `arbitrary`, gets the seed, and generates.
`quickCheck` runs the loop and tests.
**** Manual automation with QuickCheck properties
#+begin_src haskell
import Test.QuickCheck
import Test.QuickCheck.Function
import Test.QuickCheck.Property.Common
import Test.QuickCheck.Property.Functor
import Test.QuickCheck.Property.Common.Internal

data Four' a b = Four' a a a b
  deriving (Eq, Show)

instance Functor (Four' a) where
  fmap f (Four' a b c d) = Four' a b c (f d)

instance (Arbitrary a, Arbitrary b) ⇒ Arbitrary (Four' a b) where
  arbitrary = do
    a1 ← arbitrary
    a2 ← arbitrary
    a3 ← arbitrary
    b ← arbitrary
    return (Four' a1 a2 a3 b)

-- Wrapper around `prop_FunctorId`
prop_AutoFunctorId ∷ Functor f ⇒ f a → Equal (f a)
prop_AutoFunctorId = prop_FunctorId T

type Prop_AutoFunctorId f a
  = f a
  → Equal (f a)

-- Wrapper around `prop_AutoFunctorCompose`
prop_AutoFunctorCompose ∷ Functor f ⇒ Fun a1 a2 → Fun a2 c → f a1 → Equal (f c)
prop_AutoFunctorCompose f1 f2 = prop_FunctorCompose (applyFun f1) (applyFun f2) T

type Prop_AutoFunctorCompose structureType origType midType resultType
  = Fun origType midType
  → Fun midType resultType
  → structureType origType
  → Equal (structureType resultType)

main = do
  quickCheck $ eq $ (prop_AutoFunctorId ∷ Prop_AutoFunctorId (Four' ())Integer)
  quickCheck $ eq $ (prop_AutoFunctorId ∷ Prop_AutoFunctorId (Four' ()) (Either Bool String))
  quickCheck $ eq $ (prop_AutoFunctorCompose ∷ Prop_AutoFunctorCompose (Four' ()) String Integer String)
  quickCheck $ eq $ (prop_AutoFunctorCompose ∷ Prop_AutoFunctorCompose (Four' ()) Integer String (Maybe Int))
#+end_src
*** Write tests algorithm
1. Pick the right language/stack to implement features.
2. How expensive breakage can be.
3. Pick the right tools to test this.
** Tuple :drill:
:PROPERTIES:
:ID:       fd6d5368-51bc-4577-a4e3-97b62b7a4442
:END:
Data type that stores multiple values withing a single value.
Tuples by [[Arity][arity]]:
  * empty, [[Unit][unit]]          - 0
  * pair, two-tuples     - 2
  * thriple, three-tuple - 3
** Type :drill:
:PROPERTIES:
:ID:       7b89bfd2-3558-4520-939f-4030302bdda0
:END:
Type - [[Set][set]] of values.
For type to have sence the values share some sence, properties.

See [[Data type]]
** Type alias :drill:
:PROPERTIES:
:ID:       35a84a4d-afa8-44b1-aaf4-8fa258f5220c
:END:
Create new [[Type constructor][type constructor]], and use all data structure of the base type.
** Type class :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       41fe6fb3-8069-40d4-ac21-1e2995e652be
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:39]
:END:
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
** Type class inheritance :drill:
:PROPERTIES:
:ID:       d41bdd5c-5a64-4ab8-8201-8c9ae3437a61
:END:
[[Type class]] has a [[Superclass][superclass]].
** Type constant :drill:
:PROPERTIES:
:ID:       06ae5a19-fd5f-485c-b7da-c3027c76d523
:END:
See: [[Constant]]
** Type constructor :drill:
:PROPERTIES:
:ID:       9b49b7ac-d596-45c5-a551-cf2f9b3d6cb3
:END:
Name of [[Data type][data type]]

Nullary type constructor is [[Type constant]]
** type declaration :drill:
:PROPERTIES:
:ID:       9ab3591b-b3b1-464c-856b-0e3ed4834b33
:END:
Synonim for existing type. Uses the same data constructor.
#+begin_src haskell
type FirstName = String
#+end_src
Used to distinct one entities from other entities, while they have the same type.
Also main type functions can operate on a new type.
** Type inference :drill:
:PROPERTIES:
:ID:       6e24ecce-be5d-4fcc-b167-649f710d1be8
:END:
Automatic [[Data type][data type]] detection of [[Expression][expression]].
** Type instance :drill:
:PROPERTIES:
:ID:       2408c5a2-39ba-4732-a4b2-347e87c268d6
:END:
Unique [[Type class][type class]]->[[Data type][type]] pairing.
Defines type class->type methods.
** Type variable :drill:
:PROPERTIES:
:ID:       6f31712e-d46b-4474-bd68-6b3bc2c90309
:END:
Refer to an unspecified type in Haskell type signature.
** Uncurry :drill:
:PROPERTIES:
:ID:       c24534d9-0a6b-4e76-9925-bc25496bbfdd
:END:
Replace number of [[Function][functions]] with [[Tuple][tuple]] of number of values
** Undefined :drill:
SCHT: <2019-06-08 Sat>
:PROPERTIES:
:ID:       c2bc65ee-1d9b-4633-9aa1-780fa07752a8
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-04 Tue 19:54]
:END:
Value helps to do typechecking
** Unit :drill:
:PROPERTIES:
:ID:       8c2d205c-140f-4aa6-bcd4-8563433879d9
:END:
Value, [[Data type][type]]. Represents nothing. Empty [[Tuple][tuple]]
** Unlifted type :drill:
:PROPERTIES:
:ID:       071c758f-9a93-4769-a7f0-aaa02652e57f
:END:
Type that directly exist on the hardware. The type abstraction can be completely removed.
With unlifted types Haskel type system directly manages data in the hardware.
** Unsafe :drill:
:PROPERTIES:
:ID:       b48b82e3-f86c-4360-a568-727c2500d06c
:END:
[[Function]] that does not cover some edge case.
** Variable :drill:
:PROPERTIES:
:ID:       1362e457-cca3-44c3-b5a4-24111d56d71c
:END:
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funсtions]].
** Variadic :drill:
:PROPERTIES:
:ID:       b6592f9f-3718-4f2f-9423-06b590e6b84d
:END:
Variadic funtion has a indefinite [[Arity][arity]]. Assepts a variable number of [[Argument][arguments]].
** Zero :drill:
:PROPERTIES:
:ID:       403807c4-a2de-47ca-bdee-96b8b47994c2
:END:
Zero is the value operation with which always gives Zero value.
$n, zero \in C : \forall n, zero*n=zero$
There is also distinct [[Identity]] value.
** Bound :drill:
SCHT: <2019-06-09 Sun>
:PROPERTIES:
:ID:       31ef00a3-6d1e-4ee4-a0da-eac26238aace
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:51]
:END:
Haskell /*/ [[Type class][type class]] means to have lowest value & highest value, so a bounded range of values.
*** /*/
**** Bounded
See [[Bound]]
** Typed hole :drill:
:PROPERTIES:
:ID:       54480f81-42f0-4545-bfa6-93e56eba36ae
:END:
In GHC if to use placeholder =_= or =_name=, GHC on evaluation of the hole would supply derived type information and information to help fill the gap.
** First-order logic :drill:
:PROPERTIES:
:ID:       fbfe3772-5c3a-41c4-9d53-6b2bc571236e
:END:
Collection of formal systems used in mathematics, philosophy, linguistics, and computer science. First-order logic uses quantified variables over non-logical objects and allows the use of sentences that contain variables
*** /*/
**** Predicate logic
See [[First-order logic]]
**** First-order predicate calculus
See [[First-order logic]]
** Context :drill:
:PROPERTIES:
:ID:       c7212fc4-2c44-4cc0-b57a-76e9ba194ac3
:END:
[[Constraint]] placed on the types under [[Parametric polymorphism][polymorphic]] variables.
Written before the main type signature and denoted:
#+begin_src haskell
TypeClass a =>
#+end_src

* Give definitions
** Kleisli category
** Free object
** Thin category
** Partial order
** Total order
** Preorder
** Identity type
** Constant type
** Arbitrary
** Gen
** ST-Trick monad
ST is like a lexical scope, where all the variables/state disappear when the function returns
https://wiki.haskell.ohttps://www.schoolofhaskell.com/school/to-infinity-and-beyond/older-but-still-interesting/deamortized-strg/Monad/ST
https://dev.to/jvanbruegge/what-the-heck-is-polymorphism-nmh
** Lax monoidal functor
** Tensorial strength
** Strong monad
** Either
Allows to separate and preserve information about happened, ex. error handling.
*** /*/
**** Either data type
See [[Either]]
** Weak head normal form
*** /*/
**** WHNF
See [[Weak head normal form]]
** Function image
*** Image
See [[Function image]]
** Maybe
** Homomorphis
** LANGUAGE pragma options
** Pattern guard
Allows check a list of pattern matches against functions, and then proceed.

| (/pattern1/) <- (/funcCheck1/)
, (/pattern2/) <- (/funcCheck2/)
= /[[LHS]]/

#+begin_src haskell
lookup :: FiniteMap -> Int -> Maybe Int

addLookup env var1 var2
   | Just val1 <- lookup env var1
   , Just val2 <- lookup env var2
   = val1 + val2
{-...other equations...-}
#+end_src
check both  to succeed, bind results to val1, val2, then proceed to the equation.

Default in Haskell 2010.
** Inverse
1. [[Inverse function]]

2. In logic: $$ P \to Q \Rightarrow \neg P \to \neg Q $$
** Inversion
1. Is a permutation where two elements are out of order.

2. See [[Inverse]]
** Inverse function

    $$ f^{X \to Y} \circ {f^{X \to Y}}^{-1} = {id}_{X}_{} $$

/*/ $$ \iff $$ [[Function][function]] is [[Bijection][bijective]].
Otherwise - [[Partial inverse][partial inverse]]
** Partial inverse
/*/ when [[Function][function]] is now [[Bijection][bijective]]. When bijective see [[Inverse function][inverse function]].
** Define LANGUAGE pragma options
*** ExistentialQuantification
*** GADTs
*** GeneralizedNewTypeClasses
** Type rank
[[Weak ordering]] of types.

The rank of [[Parametric polymorphism][polymorphic type]] shows at what level of nesting =forall= quantifier appears.
Count-in only quantifiers that appear to the left of arrows.
#+begin_src haskell
f1 :: forall a b. a -> b -> a    ==    fi :: a -> b -> c
g1 :: forall a b. (Ord a, Eq b) => a -> b -> a    ==    g1 :: (Ord a, Eq b) => a -> b -> a
#+end_src
f1, g1 - rank-1 types. Haskell itself implicitly adds universal quantification.

#+begin_src haskell
f2 :: (forall a. a->a) -> Int -> Int
g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int
#+end_src
f2, g2 - rank-2 types. Quantificator is on the left side of a \to. Quantificator shows that type on the left can be overloaded.

#+begin_src haskell
f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool
#+end_src
f3 - rannk3-type. Has rank-2 types on the left of a \to.

#+begin_src haskell
f :: Int -> (forall a. a -> a)
g :: Int -> Ord a => a -> a
#+end_src
f, g are rank 1. Quantifier appears to the right of an arrow, not to the left. These types are not Haskell-98. They are supported in [[RankNTypes]].

Type inference in Rank-2 is possible, but but not higher.

** GHC debug keys
*** -ddump-ds
Dump desugarer output.
**** /*/
***** GHC desugar
See: [[-ddump-ds]].
** GHC optimize keys
*** -foptimal-applicative-do
$$ O(n^3) $$
Always finds optimal reduction into <*> for ApplicativeDo do notation.
** GHC check keys
*** -Wno-partial-type-signatures
Supresses [[PartialTypeSignatures]] wildcard infer warning.
** RHS
Right-hand side of the expression.
** LHS
Left-hand side of the expression.
** Generalised algebraic data types
LANGUAGE [[GADTs]]
*** /*/
**** GADT
See [[Generalised algebraic data types]]
** Order theory
Investigates in thepth the intuitive notion of order using binary relations.
*** Domain theory
Formalizes approximation and convergense.
Has close relation to [[Topology]].
*** Lattice
Abstract structure that consists of [[Partial order][partially ordered]] set, where every two elements have unique supremum and infinum. == /*/ algebraic structure satisfying certain axiomatic identities.
/*/ order-theory & algebraic.
*** Ordering
**** Preorder
R^{X \to X} : [[Reflexive]] & [[Transitive]]:
$$ aRa $$
$$ aRb, bRc \Rightarrow aRc $$

Generalization of [[Equivalence][equivalence relations]] and [[Partial order][partial orders]].

/*/ [[Antisymmetric]] \Rightarrow [[Partial ordering]].
/*/ [[Symmetric]] \Rightarrow [[Equivalence]].
***** Total preorder
$$ \forall a,b : a \le b \lor b \le a $$ \Rightarrow Total [[Preorder]].
**** Partial ordering
A binary relation must be [[Reflexive][reflexive]], [[Antisymmetry][antisymmetic]] and [[Transitive][transitive]].

Partial - not every elempents between them need to be comparable.

Good example of /*/ is a genealogical descendancy. Only related people produce relation, not related do not.
***** /*/
****** Partially ordered set
See [[Partial ordering]]
****** Poset
See [[Partially ordered set]]
** Universal algebra
Studies algebraic structures.
** Relation
*** Reflexivity
$$ R^{X \to X}, \forall x \in X : x R x $$
[[Order theory]]: $$ a \le a $$

/*/ - each element is comparable to itself.

Corresponds to [[Identity]] and [[Automorphism]].
**** /*/
***** Reflexive
See [[Reflexivity]]
***** Reflexive relation
See [[Reflexivity]]
*** Irreflexivity
$$ R^{X \to X}, \forall x \in X : \nexists R(x, x) $$
**** /*/
***** Anti-reflexive
See [[Irreflexivity]]
***** Anti-reflexive relation
See [[Irreflexivity]]
***** Irreflexive
See [[Irreflexivity]]
***** Irreflexive relation
See [[Irreflexivity]]
*** Transitivity
$$ \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc $$

/*/ - the start of a chain of precedence relations must precede the end of the chain.
**** /*/
***** Transitive
See [[Transitivity]]
***** Transitive relation
See [[Transitivity]]
*** Symmetry
$$ \forall a,b \in X : (aRb \iff bRa) $$
**** /*/
***** Symmetric
See [[Symmetry]]
***** Symmetric relation
*** Equivalence
| [[Reflexive]]              | [[Symmetric]]                    | [[Transitive]]                                  |
|----------------------------+----------------------------------+-------------------------------------------------|
| $$ \forall x \in X, \exists R : x R x $$ | $$ \forall a,b \in X : (aRb \iff bRa) $$ | $$ \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc $$ |
| $$ a = a $$                | $$ a = b \iff b = a $$           | $$ a = b, b = c \Rightarrow a = c $$                      |

**** /*/
***** Equivalent
See [[Equivalence]]
***** Equivalent relation
See [[Equivalence]]
*** Antisymmetry
$$ \forall a, b \in X : aRb, bRa \Rightarrow a = b $$ ~ $$ aRb, a \ne b \Rightarrow \nexists bRa $$.
Antisymmetry does not say anything about $$ R(a,a) $$.

/*/ - no two different elements precede each other.
**** /*/
***** Antisymmetric
See [[Antisymmetry]]
***** Antisymmetric relation
See [[Antisymmetry]]
*** Asymmetry
$$ \forall a,b \in X (aRb \Rightarrow \neg (bRa)) $$
/*/ $$ \iff $$ [[Antisymmetric]] \land [[Irreflexive]].
Asymmetry \ne "not symmetric"
[[Symmetric]] \land [[Asymmetric][Asymmetric]] is only empty relation.
**** /*/
***** Asymmetric
See [[Asymmetry]]
***** Asymmetric relation
See [[Asymmetry]]
** Commutativity
** Cryptomorphism
Equivalent, interconvertable with ni loss of information.
*** /*/
**** Crypromorphic
See [[Cryptomorphism]]
** Lexically scoped type variables
Enable [[Lexical scope][lexical scope]] for [[Forall quantifier][forall quantifier]] defined [[Type variable][type variables]]

Implemented in [[ScopedTypeVariables]]
** Type family
Defines by pattern matching the partial functions between types.
Associates data types by type-level function defined by open-ended collection of valid instances of input types and corresponding output types.

** Abstract data type
Several definitions here, reduce them.

Data type mathematical model, defined by its semantics from the user point of view, listing possible values, operations on the data of the type, and behaviour of these operations.

/*/ class of objects whose logical behaviour is defined by a set of values and set of operations (analogue to algebraic structure in mathematics).

A specification of a data type like a stack or queue where the specification does not contain any implementation details at all, only the operations for that data type. This can be thought of as the contract of the data type. 
*** /*/
**** AbsDT
See [[Abstract data type]]
** ADT
1. [[Abstract data type]]
2. [[Algebraic data type]]
* Citations
"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))
* Good code :drill:
:PROPERTIES:
:ID:       0061ec53-dc1b-40a8-a00a-f07fd4213be2
:END:
** Type aliasing :drill:
:PROPERTIES:
:ID:       db5d6252-f9b1-4c2e-ab00-a4a99d026c2a
:END:
Use data type aliases to deferentiate logic of values.
** Type wideness :drill:
:PROPERTIES:
:ID:       f84197b4-6d5d-4f8f-bb4d-3c6a1460a37b
:END:
Parametric polymorphism is broader then constrained polymorphism
Unconstrained means most flexible, but the most useless.
The more constrained system has more usefulness.
** Read Conventions of variables (page 176) :drill:
:PROPERTIES:
:ID:       6dc2fbe3-f3de-4a52-97d5-dc001e59869c
:END:
** Print :drill:
:PROPERTIES:
:ID:       1d0f6f0e-2d81-4c35-a9b3-a362557121f2
:END:
print :: Show a => a -> IO ()
print a = putStrLn (show a)
** Read code evaluation (488 on-ward) :drill:
:PROPERTIES:
:ID:       e2222b7e-75c8-4c75-98b2-9d99167232c3
:END:
** Fold :drill:
:PROPERTIES:
:ID:       e646277c-54f3-47c4-b721-b3721acc6a6f
:END:
foldr spine recursion intermediated by the folding
foldl spine folding is unconditional, then solding starts.

So foldr can terminate at any point, while foldl unconditionally recurses across the spine, even if it infinite.
** Computation model :drill:
:PROPERTIES:
:ID:       a6b88a42-c287-47ae-9db0-f7c2aa0d0cd3
:END:
Model the domain and types before thinking about how to write computations.
** Make bottoms only local :drill:
:PROPERTIES:
:ID:       8d96eb06-0984-4325-a447-4e751ff820e0
:END:
** Newtype wrap is ideally transparent for compiler and does not change performance :drill:
:PROPERTIES:
:ID:       0a8b1bec-1a25-42e0-b137-232fb01b25d7
:END:
** Instances of types/type classes must go with code you write :drill:
:PROPERTIES:
:ID:       2bafb381-43ce-44b0-9abf-ffa1f3f0c6e1
:END:
** Functions can be abstracted as arguments :drill:
:PROPERTIES:
:ID:       714c9ca5-052c-4c5b-b3c6-fcd7741250b0
:END:
** Infix operators can be bind to arguments :drill:
:PROPERTIES:
:ID:       defb1467-4b50-451b-8fb3-ab12af4409af
:END:
** Arbitrary :drill:
:PROPERTIES:
:ID:       7c3cb682-9b20-471b-9483-7a22c3ec468d
:END:
Product types can be tested as a product of random generators.
Sum types require to implement generators with separate constructors, and picking one of them, use `oneof` or `frequency` to pick generators.

** Principle of Separation of concerns :drill:
:PROPERTIES:
:ID:       a07f55f7-1a15-4aa9-b8c8-fb58149924d7
:END:
** Function composition :drill:
:PROPERTIES:
:ID:       ade1516e-44f1-4a8e-bfe4-5b773d0f27d6
:END:
In Haskell inline composition requires:
#+begin_src haskell
  h.g.f $ i
#+end_src
Function application has a higher priority than composition. That is why parentheses over argument are needed.
This precedence allows idiomatically compose partially applied functions.

But it is a way better then:
#+begin_src haskell
  h (g (f i))
#+end_src
** Functor application :drill:
:PROPERTIES:
:ID:       67dab545-6f12-4d3a-b8c7-acfc0f267d03
:END:
Function application on n levels beneath:
#+begin_src haskell
(fmap.fmap) function twoLevelStructure
#+end_src

How fmap.fmap typechecks:
#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
fmap :: Functor f => (m -> n) -> f m -> f n
fmap :: Functor g => (x -> y) -> g x -> g y

(.) :: (Functor f, Functor g)
  => ((g x -> g y) -> f.g (x) -> f.g (y))
  -> ((x -> y) -> g x -> g y)
  -> (x -> y) -> f.g (x) -> f.g. (y)
fmap.fmap :: (x -> y) -> f.g (x) -> f.g. (y)
#+end_src

** Parameter order :drill:
:PROPERTIES:
:ID:       05494702-c932-47ef-a91b-6ffd27a6b51f
:END:
In functions parameter order is important.
It is best to use first the most reusable parameters.
And as last one the one that can be the most variable, that is important to chain.
** Applicative monoid :drill:
:PROPERTIES:
:ID:       e417b5f0-fc63-45e0-971a-68b2c6ae4d22
:END:
There can be more then one valid Monoid for a data type. &&
There can be more than one valid Applicative instance for a data type. ->
There can be differnt Applicatives with different Monoid implementations.
** Creative process :drill:
:PROPERTIES:
:ID:       b5b69b79-144b-49f0-a997-ed7c056e182b
:END:
*** Pick phylosophy principles one to three the more - the harder the implementation
*** Draw the most blurred representation
*** Deduce abstractions and write remotely what they are
*** Model of computation
**** Model the domain
**** Model the types
**** Think how to write computations
*** Create
** About operators (<$) (*>) (<*) (>>) :drill:
:PROPERTIES:
:ID:       25e19a69-21f7-435a-b2ff-f1a489e9a159
:END:
Where character is not present - discards the according value.
** About operators mapM_ sequence_ :drill:
:PROPERTIES:
:ID:       03ad3fac-221c-42de-8b63-e7ccf645f183
:END:
Trailing /_/ means ignoring the result.
** Guideliles :drill:
:PROPERTIES:
:ID:       30bdcb7b-27f5-4d34-993d-d4a710d41969
:END:
*** Wiki.haskell
**** Documentation
***** Comments write in application terms, not technical.
***** Tell what code needs to do not how it does.
**** Haddoc
***** Put haddock comments to ever exposed data type and function.
***** Haddock header
#+begin_src haskell
{- |
Module      :  <File name or $Header$ to be replaced automatically>
Description :  <optional short text displayed on contents page>
Copyright   :  (c) <Authors or Affiliations>
License     :  <license>

Maintainer  :  <email>
Stability   :  unstable | experimental | provisional | stable | frozen
Portability :  portable | non-portable (<reason>)

<module description starting at first column>
-}
#+end_src
**** Code
***** Try to stay closer to portable (Haskell98) code
***** Try make lines no longer 80 chars
***** Last char in file should be newline
***** Symbolic infix identifiers is only library writer right
***** Every function does one thing.
** Use Typed holes to progress the code :drill:
:PROPERTIES:
:ID:       27c029f7-9299-4d74-b2e3-5064b57dce4a
:END:
[[Typed hole]]s help build code in complex situations.
** Haskell has infinite terms not not infinite types. :drill:
:PROPERTIES:
:ID:       6299a8fe-2bb5-4d63-94a6-4aa8561027ad
:END:
That is why infinite types throw infinite type error.
** Use type sysnonims to differ the information :drill:
:PROPERTIES:
:ID:       43181c5d-630a-4b5d-815c-272e26c8e42f
:END:
Even if there is types - define type synonims. They are free.
That distinction with synonims, would allow [[TypeSynonymInstances]], which would allow you to create a diffrent type class instances and behaviour for different information.
** Control.Monad.Error -> Control.Monad.Except :drill:
:PROPERTIES:
:ID:       4ba41ec2-5115-4be9-9aa4-4892322db1e8
:END:
** Point-free becomes better in multi-dimentional data :drill:
:PROPERTIES:
:ID:       0eb49ad1-9992-4707-88c8-64ff7f8c3cbb
:END:
BigData and OLAP analysis.
* Bad code :drill:
:PROPERTIES:
:ID:       e60a3084-2f70-4363-8f47-6df2e610d4ad
:END:
** Pragma
*** Dangerous LANGUAGE pragma options

  - DatatypeContexts
  - OverlappingInstances
  - IncoherentInstances
  - ImpredicativeTypes
  - AllowAmbigiousTypes

Mine addition:
  - UndecidableInstances

* Useful functions to remember
** Prelude
#+begin_src haskell
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
#+end_src
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo
*** List operations
#+begin_src haskell
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
#+end_src
** Data.List
#+begin_src haskell
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
#+end_src
** Data.Char
#+begin_src haskell
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
#+end_src
** QuickCheck
#+begin_src haskell
quickCheck :: Testable prop => prop -> IO ()

quickCheck . verbose - run verbose mode
#+end_src

* Investigate
** Control.Monad
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
** What been evaluated already
:sprint name
* Tools :drill:
:PROPERTIES:
:ID:       756dd451-6df6-4c86-8ff8-b431f2943685
:END:
** Search over the Haskell packages code: Codesearch from Aelve
https://codesearch.aelve.com/
* Libs :drill:
:PROPERTIES:
:ID:       dfc5ca16-c4ee-4ef5-bee6-b44a4b29f51d
:END:
** Parsers - megaparsec
** CLIs - optparse-applicative
** HTML - Lucid
** Web applications - Servant
** IO libraries
*** Conduit - practical, monolythic, guarantees termination return
*** Pipes + Pipes Parse - modular, more primitive, theoretically driven
* Misc
* Reference
** Haskell-98
*** Instance termination rules
  1. \forall class constraint (C t1 .. tn):
    1.1 type variables have occurances \le head
    1.2 constructors+variables+repetitions < head
    1.3 \not type functions (type func application can expand to arbitrary size)
 2. \forall functional dependencies, ⟨tvs⟩_left \to ⟨tvs⟩_right, of the class, every type variable in S(⟨tvs⟩_right) must appear in S(⟨tvs⟩_left), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.
