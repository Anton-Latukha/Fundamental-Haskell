#+title: Fundamental Haskell notes
#+author: Anton Latukha
#+creator: Self-published by Anton Latukha
#+description: Fundamental notes on Haskell, Category theory and related fields.
#+subtitle: Encyclopedcal handbook for learning and undersatanding fundamentals
#
#
#

#+begin_src text

                        _oo0oo_
                        o88888o
                       88" . "88
                       (| -_- |)
                       0\  =  /0
                     ___/`---'\____
                  .'  \|       |//  '.
                 /  /|||   :    |||/\ \
                |  _|\||| -:-  |||||   \
               /   | \\    -  ///  |\   \
               |   \_| ''\---/''   |/   |
                \  .-\__  '-'  ___/-.  /
              ___'. .'  /--.--\ `.  .'___
           ."" '<  `.___\_<|>_/___.' >' "".
          | | :  `- \`.;`\ _ /`;.`/ - ` : | |
          \  \ `_.   \_ __\ /__ _/   .-` /  /
      =====`-.____`.___ \_____/___.-`___.-'=====
                        `=---='

#+end_src

#
#
#
#+startup: latexpreview
#+startup: entitiespretty
#+setupfile: ./org-html-themes/setup/theme-readtheorg.setup
#+options: tags:nil
#+options: stat:t
#+options: H:10
#+options: num:t
#+options: toc:10
#+options: p:nil
#+options: \n:t
#+options: -:t
#+options: e:t
#+toc: headlines 10
#+latex_class: book
#+latex_class_options: [a4paper,14pt,oneside]
#+latex_header: \usepackage{marvosym}    % Some symbols which probably not used in my book
#+latex_header: \usepackage{wasysym}    % Some symbols which may be not used in my book
#+latex_header: \tolerance=1000
#+latex_header: \usepackage{tikz}
#+latex_header: \usetikzlibrary{cd}
#+latex_header: \hypersetup{colorlinks=true,linkcolor=blue,urlcolor=cyan,}
#+latex_header: \usepackage{enumitem}
#+latex_header: \setlistdepth{10}
#+latex_header: \setlist[itemize,1]{label=$\bullet$}
#+latex_header: \setlist[itemize,2]{label=$\bullet$}
#+latex_header: \setlist[itemize,3]{label=$\bullet$}
#+latex_header: \setlist[itemize,4]{label=$\bullet$}
#+latex_header: \setlist[itemize,5]{label=$\bullet$}
#+latex_header: \setlist[itemize,6]{label=$\bullet$}
#+latex_header: \setlist[itemize,7]{label=$\bullet$}
#+latex_header: \setlist[itemize,8]{label=$\bullet$}
#+latex_header: \setlist[itemize,9]{label=$\bullet$}
#+latex_header: \setlist[itemize,10]{label=$\bullet$}
#+latex_header: \renewlist{itemize}{itemize}{10}
#+latex_header: \setlist[enumerate,1]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,2]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,3]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,4]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,5]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,6]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,7]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,8]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,9]{label=$\alph*.$}
#+latex_header: \setlist[enumerate,10]{label=$\alph*.$}
#+latex_header: \renewlist{enumerate}{enumerate}{10}
#+latex_header: \usepackage{fancyhdr}    % Enable fancy page style package
#+latex_header: \setlength{\headheight}{15.2pt}    % Vertical size of the header box
#+latex_header: \pagestyle{fancy}    % Enable fancy page style: Documentation: http://mirror.datacenter.by/pub/mirrors/CTAN/macros/latex/contrib/fancyhdr/fancyhdr.pdf
#+latex_header: \pagestyle{headings,chapters,sections,subsections}    % Add complex heading
#+latex_header: \setlength\marginparwidth{0mm}
#+latex_header: \setlength\textwidth{455pt}
#+latex_header: \setlength\textheight{661pt}    % Text height on the page, value was experimentally found by me
#+latex_header: \fancyfoot[C]{\thepage}    % Footer center
#+latex_header: \setlength\footskip{0mm}
#+latex_header: \usepackage{booktabs}
#+latex_header: \usepackage{xcolor}
#+latex_header: \usepackage{colortbl}
#+latex_header: \usepackage{siunitx}
#+latex_header: \usepackage[table]{xcolor}
#+latex_header: \usepackage{geometry}    % Package aligns the geometry right, probably required by other page offset packages
#+latex_header: \geometry{bottom=28mm}
#+latex_header: \setcounter{secnumdepth}{100}
#+latex_header: \setcounter{tocdepth}{100}
#+latex_header: \fancyheadoffset{0mm}    % Offset for header
#+latex_header: \newbox\FHline    % Calculate the box for the header
#+latex_header: \setbox\FHline=\hbox{\hsize=\paperwidth%
#+latex_header:   \hspace*{0mm}%
#+latex_header:   \rule{\textwidth}{\headrulewidth}\hspace*{0mm}%
#+latex_header: }
#+latex_header: \renewcommand\headrule{\vskip-.7\baselineskip\copy\FHline}    % Set rule for header line box
#+latex_header: \setlength{\parindent}{0mm}    % Paragraph first line indentation
#+latex_header: \usepackage{fancyvrb}    % Verbatim LaTeX handler&transformer, `minted` requires it.
#+latex_header: \usepackage{fvextra}    % Official extension to `fancyvrb`, can be used by `minted` in some cases.
#+latex_header: \usepackage{minted}    % Python3 Pygments code highlighter, requires permission of LaTeX compiler for external tools
#+latex_header: \usemintedstyle{rainbow_dash}    % Theme that is most close my setup
#+latex_header: \usepackage{caption}
#+latex_header: \newcommand{\source}[1]{\caption*{Source: {#1}} }
#+latex_header: \usepackage{mathtools}
#+latex_header: \usepackage[utf8]{inputenc}
# Enable MathJax
#+html_head: <style type="text/css">div.MathJax_Display{display: inline-block !important; width: auto;}</style>
# Enable MathJax TiKz
#+html_head: <link rel="stylesheet" type="text/css" href="http://tikzjax.com/v1/fonts.css">
#+html_head: <script src="http://tikzjax.com/v1/tikzjax.js"></script>
#+keywords: Haskell,Org-mode,Org-drill,Category theory,Functor,Applicative,Monad,Learning,Terms,Definitions,Theory,Book,Dictionary,Encyclopedia,Handbook,Philosophy,Philosophy of mathematics

* Introduction

/“Employ your time in improving yourself by other men's writings so that you shall come easily by what others have labored hard for.”
(Socrates by Plato)/

Important notes on Haskell, category theory & related fields, terms and recommendations.

Resources:
 * Web book: https://blog.latukha.com/haskell-notes
 * GitHub: https://github.com/Anton-Latukha/haskell-notes
 * GitLab: https://gitlab.com/Anton.Latukha/haskell-notes
 * View PDF: https://github.com/Anton-Latukha/haskell-notes/blob/master/README.pdf
 * Download PDF: https://github.com/Anton-Latukha/haskell-notes/raw/master/README.pdf
 * LaTeX: https://github.com/Anton-Latukha/haskell-notes/raw/master/README.tex

This is a complex Org markup file with LaTeX formulas.
GitHub & GitLab only partially parse Org into HTML.

To get the full view:
  * Outline navigation
  * LaTeX formulas: \( {\displaystyle\left[{-\frac{\hbar^{2}}{2m}}\nabla^{2}+V(\vec{r},t)\right]\Psi({\vec{r}},t)=i\hbar{\partial\over\partial{t}}\Psi({\vec{r}},t),\quad\sum_{k,j}\left[-{\frac{\hbar^{2}}{\sqrt{a}}}{\frac{\partial}{\partial{q^{k}}}}\left({\sqrt{a}}a^{kj}{\frac{\partial}{\partial{q^{j}}}}\right)+V\right]\Psi+{\frac{\hbar}{i}}{\frac{\partial{\Psi}}{\partial{t}}}=0} \)
  * Interlinks: <<<Interlinks>>>

, please refere to Web book, PDF, LaTeX, of use Org-mode capable viewer/editor.

Note about markup: =<<<This is a radio target>>>= - the dynamic linking.

Users of =Emacs= can prettify radio targets to see as simple hyper-links with this =Elisp= snippet:

#+begin_src elisp
;;;;  2019-06-12: NOTE:
;;;;  Prettify '<<<Radio targets>>>' to be shown as '_Radio_targets_',
;;;;  when `org-descriptive-links` set.
;;;;  This is improvement of the code from: Tobias&glmorous:
;;;;  https://emacs.stackexchange.com/questions/19230/how-to-hide-targets
;;;;  There exists library created from the sample:
;;;;  https://github.com/talwrii/org-hide-targets
(defcustom org-hidden-links-additional-re "\\(<<<\\)[[:print:]]+?\\(>>>\\)"
  "Regular expression that matches strings where the invisible-property
    of thesub-matches 1 and 2 is set to org-link."
  :type '(choice (const :tag "Off" nil) regexp)
  :group 'org-link)
(make-variable-buffer-local 'org-hidden-links-additional-re)

(defun org-activate-hidden-links-additional (limit)
  "Put invisible-property org-link on strings matching
    `org-hide-links-additional-re'."
  (if org-hidden-links-additional-re
      (re-search-forward org-hidden-links-additional-re limit t)
    (goto-char limit)
    nil))

(defun org-hidden-links-hook-function ()
  "Add rule for `org-activate-hidden-links-additional'
    to `org-font-lock-extra-keywords'.
    You can include this function in `org-font-lock-set-keywords-hook'."
  (add-to-list 'org-font-lock-extra-keywords
                '(org-activate-hidden-links-additional
                  (1 '(face org-target invisible org-link))
                  (2 '(face org-target invisible org-link)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-hidden-links-hook-function)
#+end_src

=SCHT:= and metadata in =:properties:= - of my =org-drill= practices, please just run =org-drill-strip-all-data=.

* Contents :TOC:noexport:
- [[#introduction][Introduction]]
- [[#definitions][Definitions]]
  - [[#algebra][<<<Algebra>>>]]
    - [[#][/*/]]
    - [[#algebraic][<<<Algebraic>>>]]
    - [[#algebraic-structure][<<<Algebraic structure>>>]]
      - [[#-1][/*/]]
      - [[#fundamental-theorem-of-algebra][<<<Fundamental theorem of algebra>>>]]
    - [[#modular-arithmetic][<<<Modular arithmetic>>>]]
      - [[#-2][/*/]]
      - [[#modulus][<<<Modulus>>>]]
        - [[#-3][/*/]]
  - [[#category-theory][<<<Category theory>>>]]
    - [[#-4][/*/]]
    - [[#abelian-category][<<<Abelian category>>>]]
      - [[#-5][/*/]]
    - [[#composition][<<<Composition>>>]]
      - [[#-6][/*/]]
    - [[#endofunctor-category][<<<Endofunctor category>>>]]
    - [[#functor][<<<Functor>>>]]
      - [[#-7][/*/]]
      - [[#power-set-functor][<<<Power set functor>>>]]
        - [[#-8][/*/]]
        - [[#power-set-functor-laws][<<<Power set functor laws>>>]]
          - [[#-9][/*/]]
          - [[#power-set-functor-identity-law][<<<Power set functor identity law>>>]]
          - [[#power-set-functor-composition-law][<<<Power set functor composition law>>>]]
        - [[#lift][<<<Lift>>>]]
          - [[#-10][/*/]]
        - [[#power-set-functor-is-a-free-monad][<<<Power set functor is a free monad>>>]]
      - [[#functorial][<<<Functorial>>>]]
      - [[#forgetful-functor][<<<Forgetful functor>>>]]
        - [[#-11][/*/]]
      - [[#identity-functor][<<<Identity functor>>>]]
      - [[#endofunctor][<<<Endofunctor>>>]]
        - [[#-12][/*/]]
      - [[#applicative-functor][<<<Applicative functor>>>]]
        - [[#-13][/*/]]
        - [[#applicative-law][<<<Applicative law>>>]]
        - [[#-14][/*/]]
          - [[#applicative-identity-law][<<<Applicative identity law>>>]]
          - [[#applicative-composition-law][<<<Applicative composition law>>>]]
          - [[#applicative-homomorphism-law][<<<Applicative homomorphism law>>>]]
          - [[#applicative-interchange-law][<<<Applicative interchange law>>>]]
        - [[#applicative-function][<<<Applicative function>>>]]
          - [[#lifta][<<<liftA*>>>]]
            - [[#lifta-1][<<<liftA>>>]]
            - [[#lifta2][<<<liftA2>>>]]
            - [[#lifta2-][<<<liftA2 (<*>)>>>]]
            - [[#lifta2-lifta2-][<<<liftA2 (liftA2 (<*>))>>>]]
            - [[#lifta3][<<<liftA3>>>]]
          - [[#conditional-applicative-computations][Conditional applicative computations]]
        - [[#special-applicatives][<<<Special applicatives>>>]]
          - [[#identity-applicative][<<<Identity applicative>>>]]
          - [[#constant-applicative][<<<Constant applicative>>>]]
          - [[#maybe-applicative][<<<Maybe applicative>>>]]
          - [[#either-applicative][<<<Either applicative>>>]]
          - [[#validation-applicative][<<<Validation applicative>>>]]
        - [[#monad][<<<Monad>>>]]
          - [[#-15][/*/]]
          - [[#monad-law][<<<Monad law>>>]]
            - [[#-16][/*/]]
            - [[#monad-left-identity-law][<<<Monad left identity law>>>]]
            - [[#monad-right-identity-law][<<<Monad right identity law>>>]]
            - [[#monad-associativity-law][<<<Monad associativity law>>>]]
          - [[#monad-type-class][<<<Monad type class>>>]]
            - [[#monadplus-type-class][<<<MonadPlus type class>>>]]
              - [[#-17][/*/]]
          - [[#functor---applicative---monad-progression][Functor -> Applicative -> Monad progression]]
          - [[#monad-function][<<<Monad function>>>]]
            - [[#return-function][<<<Return function>>>]]
            - [[#join-function][<<<Join function>>>]]
              - [[#-18][/*/]]
              - [[#join--fmap--][join . fmap == (=<<)]]
            - [[#bind-function][<<<Bind function>>>]]
              - [[#-19][/*/]]
                - [[#-20][(>>=)]]
                - [[#-21][>>=]]
                - [[#-22][(=<<)]]
                - [[#-23][=<<]]
            - [[#sequencing-operator---][<<<Sequencing operator>>> (>>) == (*>):]]
            - [[#monadic-versions-of-list-functions][Monadic versions of list functions]]
            - [[#liftm][<<<liftM*>>>]]
              - [[#liftm-1][<<<liftM>>>]]
              - [[#liftm2][<<<liftM2>>>]]
          - [[#comonad][<<<Comonad>>>]]
          - [[#kleisli-arrow][<<<Kleisli arrow>>>]]
            - [[#-24][/*/]]
          - [[#kleisli-composition][<<<Kleisli composition>>>]]
          - [[#kleisli-category][<<<Kleisli category>>>]]
          - [[#special-monad][<<<Special monad>>>]]
            - [[#identity-monad][<<<Identity monad>>>]]
            - [[#maybe-monad][<<<Maybe monad>>>]]
            - [[#either-monad][<<<Either monad>>>]]
            - [[#error-monad][<<<Error monad>>>]]
            - [[#list-monad][<<<List monad>>>]]
              - [[#-25][/*/]]
            - [[#reader-monad][<<<Reader monad>>>]]
            - [[#writer-monad][<<<Writer monad>>>]]
            - [[#state-monad][<<<State monad>>>]]
          - [[#monad-transformer][<<<Monad transformer>>>]]
            - [[#maybet][<<<MaybeT>>>]]
            - [[#eithert][<<<EitherT>>>]]
              - [[#-26][/*/]]
            - [[#readert][<<<ReaderT>>>]]
            - [[#monadtrans-type-class][<<<MonadTrans>>> type class]]
                - [[#monadio-type-class][<<<MonadIO>>> type class]]
                  - [[#-27][/*/]]
        - [[#alternative-type-class][<<<Alternative type class>>>]]
          - [[#-28][/*/]]
      - [[#monoidal-functor][<<<Monoidal functor>>>]]
      - [[#fusion][<<<Fusion>>>]]
      - [[#-29][<<<=$>=>>>]]
      - [[#multifunctor][<<<Multifunctor>>>]]
        - [[#-30][/*/]]
      - [[#-31][/*/]]
    - [[#hask-category][<<<Hask category>>>]]
      - [[#-32][/*/]]
    - [[#magma][<<<Magma>>>]]
      - [[#mag-category][<<<Mag category>>>]]
        - [[#-33][/*/]]
      - [[#semigroup][<<<Semigroup>>>]]
        - [[#-34][/*/]]
        - [[#monoid][<<<Monoid>>>]]
          - [[#-35][/*/]]
          - [[#monoid-laws][<<<Monoid laws>>>]]
            - [[#monoid-left-identity-law][<<<Monoid left identity law>>>]]
            - [[#monoid-right-identity-law][<<<Monoid right identity law>>>]]
            - [[#monoid-associativity-law][<<<Monoid associativity law>>>]]
          - [[#commutative-monoid][<<<Commutative monoid>>>]]
            - [[#-36][/*/]]
          - [[#group][<<<Group>>>]]
            - [[#-37][/*/]]
            - [[#commutative-group][<<<Commutative group>>>]]
              - [[#-38][/*/]]
              - [[#ring][<<<Ring>>>]]
                - [[#-39][/*/]]
    - [[#morphism][<<<Morphism>>>]]
      - [[#-40][/*/]]
      - [[#homomorphism][<<<Homomorphism>>>]]
        - [[#-41][/*/]]
      - [[#identity-morphism][<<<Identity morphism>>>]]
        - [[#identity][<<<Identity>>>]]
          - [[#two-sided-identity-of-a-predicate][<<<Two-sided identity of a predicate>>>]]
          - [[#left-identity-of-a-predicate][<<<Left identity of a predicate>>>]]
          - [[#right-identity-of-a-predicate][<<<Right identity of a predicate>>>]]
        - [[#identity-function][<<<Identity function>>>]]
      - [[#monomorphism][<<<Monomorphism>>>]]
        - [[#-42][/*/]]
      - [[#epimorphism][<<<Epimorphism>>>]]
        - [[#-43][/*/]]
      - [[#isomorphism][<<<Isomorphism>>>]]
        - [[#-44][/*/]]
        - [[#lax][<<<Lax>>>]]
      - [[#endomorphism][<<<Endomorphism>>>]]
        - [[#automorphism][<<<Automorphism>>>]]
          - [[#-45][/*/]]
        - [[#-46][/*/]]
      - [[#catamorphism][<<<Catamorphism>>>]]
        - [[#-47][/*/]]
        - [[#catamorphism-law][<<<Catamorphism law>>>]]
          - [[#hylomorphism][<<<Hylomorphism>>>]]
            - [[#-48][/*/]]
        - [[#anamorphism][<<<Anamorphism>>>]]
          - [[#-49][/*/]]
      - [[#kernel][<<<Kernel>>>]]
        - [[#kernel-homomorphism][<<<Kernel homomorphism>>>]]
    - [[#set-category][<<<Set category>>>]]
    - [[#natural-transformation][<<<Natural transformation>>>]]
      - [[#-50][/*/]]
      - [[#natural-transformation-component][<<<Natural transformation component>>>]]
        - [[#-51][/*/]]
      - [[#natural-transformation-in-haskell][<<<Natural transformation in Haskell>>>]]
      - [[#cat-category][<<<Cat category>>>]]
        - [[#-52][/*/]]
        - [[#bicategory][Bicategory]]
    - [[#category-dual][<<<Category dual>>>]]
          - [[#-53][/*/]]
      - [[#coalgebra][<<<Coalgebra>>>]]
    - [[#thin-category][<<<Thin category>>>]]
      - [[#-54][/*/]]
    - [[#commuting-diagram][<<<Commuting diagram>>>]]
      - [[#-55][/*/]]
    - [[#universal-construction][<<<Universal construction>>>]]
      - [[#-56][/*/]]
    - [[#product][<<<Product>>>]]
      - [[#-57][/*/]]
    - [[#coproduct][<<<Coproduct>>>]]
      - [[#-58][/*/]]
    - [[#free-object][<<<Free object>>>]]
    - [[#internal-category][<<<Internal category>>>]]
    - [[#hom-set][<<<Hom set>>>]]
      - [[#-59][/*/]]
      - [[#hom-functor][<<<Hom-functor>>>]]
      - [[#exponential-object][<<<Exponential object>>>]]
        - [[#-60][/*/]]
        - [[#enriched-category][<<<Enriched category>>>]]
          - [[#-61][/*/]]
  - [[#data-type][<<<Data type>>>]]
    - [[#-62][/*/]]
    - [[#actual-type][<<<Actual type>>>]]
    - [[#algebraic-data-type][<<<Algebraic data type>>>]]
      - [[#-63][/*/]]
    - [[#cardinality][<<<Cardinality>>>]]
      - [[#-64][/*/]]
    - [[#data-constant][<<<Data constant>>>]]
    - [[#data-constructor][<<<Data constructor>>>]]
    - [[#data-declaration][<<<data declaration>>>]]
    - [[#dependent-type][<<<Dependent type>>>]]
      - [[#-65][/*/]]
    - [[#gen-type][<<<Gen type>>>]]
    - [[#higher-kinded-data-type][<<<Higher-kinded data type>>>]]
      - [[#-66][/*/]]
    - [[#newtype-declaration][<<<newtype declaration>>>]]
    - [[#principal-type][<<<Principal type>>>]]
    - [[#product-data-type][<<<Product data type>>>]]
      - [[#-67][/*/]]
      - [[#sequence][<<<Sequence>>>]]
        - [[#-68][/*/]]
        - [[#list][<<<List>>>]]
    - [[#proxy-type][<<<Proxy type>>>]]
    - [[#static-typing][<<<Static typing>>>]]
    - [[#structural-type][<<<Structural type>>>]]
      - [[#-69][/*/]]
    - [[#structural-type-system][<<<Structural type system>>>]]
      - [[#-70][/*/]]
    - [[#sum-data-type][<<<Sum data type>>>]]
    - [[#type-alias][<<<Type alias>>>]]
    - [[#type-class][<<<Type class>>>]]
      - [[#-71][/*/]]
      - [[#arbitrary-type-class][<<<Arbitrary type class>>>]]
        - [[#arbitrary-function][<<<Arbitrary function>>>]]
      - [[#coarbitrary-type-class][<<<CoArbitrary type class>>>]]
        - [[#-72][/*/]]
      - [[#typeable-type-class][<<<Typeable type class>>>]]
        - [[#-73][/*/]]
      - [[#type-class-inheritance][<<<Type class inheritance>>>]]
      - [[#derived-instance][<<<Derived instance>>>]]
        - [[#-74][/*/]]
    - [[#type-constant][<<<Type constant>>>]]
    - [[#type-constructor][<<<Type constructor>>>]]
    - [[#type-declaration][<<<type declaration>>>]]
    - [[#typed-hole][<<<Typed hole>>>]]
      - [[#-75][/*/]]
    - [[#type-inference][<<<Type inference>>>]]
      - [[#-76][/*/]]
    - [[#type-class-instance][<<<Type class instance>>>]]
    - [[#type-rank][<<<Type rank>>>]]
      - [[#-77][/*/]]
    - [[#type-variable][<<<Type variable>>>]]
    - [[#unlifted-type][<<<Unlifted type>>>]]
      - [[#-78][/*/]]
    - [[#linear-type][<<<Linear type>>>]]
      - [[#-79][/*/]]
    - [[#nonempty-list-data-type][<<<NonEmpty list data type>>>]]
    - [[#session-type][<<<Session type>>>]]
    - [[#binary-tree][<<<Binary tree>>>]]
    - [[#bottom-value][<<<Bottom value>>>]]
      - [[#-80][/*/]]
    - [[#bound][<<<Bound>>>]]
      - [[#-81][/*/]]
    - [[#constructor][<<<Constructor>>>]]
      - [[#-82][/*/]]
    - [[#context][<<<Context>>>]]
      - [[#-83][/*/]]
    - [[#inhabit][<<<Inhabit>>>]]
    - [[#maybe][<<<Maybe>>>]]
        - [[#-84][/*/]]
    - [[#expected-type][<<<Expected type>>>]]
    - [[#adt][<<<ADT>>>]]
    - [[#concrete-type][<<<Concrete type>>>]]
    - [[#type-punning][<<<Type punning>>>]]
    - [[#kind][<<<Kind>>>]]
      - [[#-85][/*/]]
    - [[#io][<<<IO>>>]]
  - [[#expression][<<<Expression>>>]]
    - [[#-86][/*/]]
    - [[#closed-form-expression][<<<Closed-form expression>>>]]
    - [[#rhs][<<<RHS>>>]]
    - [[#lhs][<<<LHS>>>]]
    - [[#redex][<<<Redex>>>]]
    - [[#concatenate][<<<Concatenate>>>]]
    - [[#alpha-equivalence][<<<Alpha equivalence>>>]]
    - [[#ground-expression][<<<Ground expression>>>]]
      - [[#-87][/*/]]
    - [[#variable][<<<Variable>>>]]
      - [[#-88][/*/]]
    - [[#phrase][<<<Phrase>>>]]
  - [[#function][<<<Function>>>]]
    - [[#-89][/*/]]
    - [[#arity][<<<Arity>>>]]
    - [[#bijection][<<<Bijection>>>]]
      - [[#-90][/*/]]
    - [[#combinator][<<<Combinator>>>]]
      - [[#psi-combinator][<<<\Psi-combinator>>>]]
        - [[#-91][/*/]]
    - [[#function-application][<<<Function application>>>]]
      - [[#-92][/*/]]
    - [[#function-body][<<<Function body>>>]]
    - [[#function-composition][<<<Function composition>>>]]
      - [[#-93][/*/]]
    - [[#function-head][<<<Function head>>>]]
    - [[#function-range][<<<Function range>>>]]
    - [[#higher-order-function][<<<Higher-order function>>>]]
      - [[#-94][/*/]]
      - [[#fold][<<<Fold>>>]]
    - [[#injection][<<<Injection>>>]]
      - [[#-95][/*/]]
    - [[#partial-function][<<<Partial function>>>]]
    - [[#purity][<<<Purity>>>]]
      - [[#-96][/*/]]
    - [[#pure-function][<<<Pure function>>>]]
    - [[#sectioning][<<<Sectioning>>>]]
    - [[#surjection][<<<Surjection>>>]]
      - [[#-97][/*/]]
    - [[#unsafe-function][<<<Unsafe function>>>]]
      - [[#-98][/*/]]
    - [[#variadic][<<<Variadic>>>]]
    - [[#domain][<<<Domain>>>]]
    - [[#codomain][<<<Codomain>>>]]
    - [[#open-formula][<<<Open formula>>>]]
    - [[#recursion][<<<Recursion>>>]]
      - [[#-99][/*/]]
      - [[#base-case][<<<Base case>>>]]
      - [[#tail-recursion][<<<Tail recursion>>>]]
      - [[#polymorphic-recursion][<<<Polymorphic recursion>>>]]
        - [[#-100][/*/]]
    - [[#free-variable][<<<Free variable>>>]]
    - [[#closure][<<<Closure>>>]]
      - [[#-101][/*/]]
    - [[#parameter][<<<Parameter>>>]]
      - [[#-102][/*/]]
    - [[#partial-application][<<<Partial application>>>]]
      - [[#-103][/*/]]
    - [[#well-formed-formula][<<<Well-formed formula>>>]]
      - [[#-104][/*/]]
  - [[#homotopy][<<<Homotopy>>>]]
    - [[#-105][/*/]]
  - [[#lambda-calculus][<<<Lambda calculus>>>]]
    - [[#-106][/*/]]
    - [[#lambda-cube][<<<Lambda cube>>>]]
      - [[#-107][/*/]]
    - [[#lambda-function][<<<Lambda function>>>]]
      - [[#-108][/*/]]
      - [[#anonymous-lambda-function][<<<Anonymous lambda function>>>]]
        - [[#-109][/*/]]
      - [[#uncurry][<<<Uncurry>>>]]
    - [[#beta-reduction][<<<\beta-reduction>>>]]
      - [[#-110][/*/]]
      - [[#beta-normal-form][<<<\beta-normal form>>>]]
        - [[#-111][/*/]]
    - [[#calculus-of-constructions][<<<Calculus of constructions>>>]]
      - [[#-112][/*/]]
    - [[#curryhoward-correspondence][<<<Curry–Howard correspondence>>>]]
      - [[#-113][/*/]]
    - [[#currying][<<<Currying>>>]]
      - [[#-114][/*/]]
    - [[#hindleymilner-type-system][<<<Hindley–Milner type system>>>]]
      - [[#-115][/*/]]
    - [[#reduction][<<<Reduction>>>]]
      - [[#-116][/*/]]
    - [[#beta-eta-normal-form][<<<\beta-\eta normal form>>>]]
      - [[#-117][/*/]]
    - [[#eta-abstraction][<<<\eta-abstraction>>>]]
      - [[#-118][/*/]]
    - [[#lambda-expression][<<<Lambda expression>>>]]
  - [[#operation][<<<Operation>>>]]
    - [[#constant][<<<Constant>>>]]
    - [[#binary-operation][<<<Binary operation>>>]]
      - [[#-119][/*/]]
    - [[#operator][<<<Operator>>>]]
      - [[#shift-operator][<<<Shift operator>>>]]
        - [[#-120][/*/]]
      - [[#differential-operator][<<<Differential operator>>>]]
        - [[#-121][/*/]]
    - [[#infix][<<<Infix>>>]]
    - [[#fixity][<<<Fixity>>>]]
      - [[#-122][/*/]]
    - [[#zero][<<<Zero>>>]]
    - [[#bind][<<<Bind>>>]]
      - [[#-123][/*/]]
    - [[#declaration][<<<Declaration>>>]]
    - [[#dispatch][<<<Dispatch>>>]]
    - [[#evaluation][<<<Evaluation>>>]]
  - [[#permutation][<<<Permutation>>>]]
  - [[#point-free][<<<Point-free>>>]]
    - [[#-124][/*/]]
    - [[#blackbird][<<<Blackbird>>>]]
      - [[#-125][/*/]]
    - [[#swing][<<<Swing>>>]]
    - [[#squish][<<<Squish>>>]]
  - [[#polymorphism][<<<Polymorphism>>>]]
    - [[#-126][/*/]]
    - [[#levity-polymorphism][<<<Levity polymorphism>>>]]
    - [[#parametric-polymorphism][<<<Parametric polymorphism>>>]]
      - [[#rank-1-polymorphism][<<<Rank-1 polymorphism>>>]]
        - [[#-127][/*/]]
      - [[#let-bound-polymorphism][<<<Let-bound polymorphism>>>]]
      - [[#constrained-polymorphism][<<<Constrained polymorphism>>>]]
        - [[#ad-hoc-polymorphism][<<<Ad hoc polymorphism>>>]]
            - [[#-128][/*/]]
      - [[#impredicative-polymorphism][<<<Impredicative polymorphism>>>]]
        - [[#-129][/*/]]
      - [[#higher-rank-polymorphism][<<<Higher-rank polymorphism>>>]]
        - [[#-130][/*/]]
    - [[#subtype-polymorphism][<<<Subtype polymorphism>>>]]
    - [[#row-polymorphism][<<<Row polymorphism>>>]]
    - [[#kind-polymorphism][<<<Kind polymorphism>>>]]
    - [[#linearity-polymorphism][<<<Linearity polymorphism>>>]]
  - [[#pragma][<<<Pragma>>>]]
    - [[#language-pragma][<<<LANGUAGE pragma>>>]]
      - [[#language-option][<<<LANGUAGE option>>>]]
        - [[#-131][/*/]]
        - [[#useful-by-default][Useful by default]]
        - [[#allowambiguoustypes][<<<AllowAmbiguousTypes>>>]]
        - [[#applicativedo][<<<ApplicativeDo>>>]]
        - [[#constrainedclassmethods][<<<ConstrainedClassMethods>>>]]
        - [[#cpp][<<<CPP>>>]]
        - [[#derivefunctor][<<<DeriveFunctor>>>]]
        - [[#explicitforall][<<<ExplicitForAll>>>]]
        - [[#flexiblecontexts][<<<FlexibleContexts>>>]]
        - [[#flexibleinstances][<<<FlexibleInstances>>>]]
        - [[#generalizednewtypederiving][<<<GeneralizedNewtypeDeriving>>>]]
        - [[#implicitparams][<<<ImplicitParams>>>]]
        - [[#lambdacase][<<<LambdaCase>>>]]
        - [[#multiparamtypeclasses][<<<MultiParamTypeClasses>>>]]
        - [[#multiwayif][<<<MultiWayIf>>>]]
        - [[#overloadedstrings][<<<OverloadedStrings>>>]]
        - [[#partialtypesignatures][<<<PartialTypeSignatures>>>]]
        - [[#rankntypes][<<<RankNTypes>>>]]
        - [[#scopedtypevariables][<<<ScopedTypeVariables>>>]]
        - [[#tuplesections][<<<TupleSections>>>]]
        - [[#typeapplications][<<<TypeApplications>>>]]
        - [[#typesynonyminstances][<<<TypeSynonymInstances>>>]]
        - [[#undecidableinstances][<<<UndecidableInstances>>>]]
        - [[#viewpatterns][<<<ViewPatterns>>>]]
        - [[#datatypecontexts][<<<DatatypeContexts>>>]]
        - [[#standalonekindsignatures][<<<StandaloneKindSignatures>>>]]
          - [[#-132][/*/]]
        - [[#partialtypesignatures-1][<<<PartialTypeSignatures>>>]]
      - [[#how-to-make-a-ghc-language-extension][How to make a GHC LANGUAGE extension]]
  - [[#compositionality][<<<Compositionality>>>]]
    - [[#-133][/*/]]
  - [[#referential-transparency][<<<Referential transparency>>>]]
    - [[#-134][/*/]]
  - [[#semantics][<<<Semantics>>>]]
    - [[#operational-semantics][<<<Operational semantics>>>]]
      - [[#argument][<<<Argument>>>]]
        - [[#argument-of-a-function][<<<Argument of a function>>>]]
          - [[#-135][/*/]]
        - [[#first-class][<<<First-class>>>]]
      - [[#relation][<<<Relation>>>]]
        - [[#-136][/*/]]
    - [[#denotational-semantics][<<<Denotational semantics>>>]]
      - [[#abstraction][<<<Abstraction>>>]]
        - [[#-137][/*/]]
        - [[#leaky-abstraction][<<<Leaky abstraction>>>]]
          - [[#-138][/*/]]
        - [[#object][<<<Object>>>]]
          - [[#-139][/*/]]
          - [[#arrow][<<<Arrow>>>]]
            - [[#-140][/*/]]
          - [[#terminal-object][<<<Terminal object>>>]]
          - [[#initial-object][<<<Initial object>>>]]
          - [[#value][Value]]
            - [[#-141][/*/]]
          - [[#tensor][<<<Tensor>>>]]
            - [[#-142][/*/]]
      - [[#ambigram][<<<Ambigram>>>]]
      - [[#binary][<<<Binary>>>]]
      - [[#arbitrary][<<<Arbitrary>>>]]
      - [[#refutable][<<<Refutable>>>]]
      - [[#irrefutable][<<<Irrefutable>>>]]
      - [[#superclass][<<<Superclass>>>]]
      - [[#unit][<<<Unit>>>]]
      - [[#nullary][<<<Nullary>>>]]
      - [[#syntax-tree][<<<Syntax tree>>>]]
        - [[#abstract-syntax-tree][<<<Abstract syntax tree>>>]]
          - [[#-143][/*/]]
        - [[#concrete-syntax-tree][<<<Concrete syntax tree>>>]]
          - [[#-144][/*/]]
      - [[#stream][<<<Stream>>>]]
      - [[#linear][<<<Linear>>>]]
        - [[#-145][/*/]]
      - [[#predicative][<<<Predicative>>>]]
      - [[#quantifier][<<<Quantifier>>>]]
        - [[#-146][/*/]]
        - [[#forall-quantifier][<<<Forall quantifier>>>]]
          - [[#-147][/*/]]
    - [[#axiomatic-semantics][<<<Axiomatic semantics>>>]]
      - [[#property][<<<Property>>>]]
        - [[#-148][/*/]]
        - [[#associativity][<<<Associativity>>>]]
          - [[#-149][/*/]]
        - [[#left-associative][<<<Left associative>>>]]
          - [[#-150][/*/]]
        - [[#right-associative][<<<Right associative>>>]]
        - [[#non-associative][<<<Non-associative>>>]]
        - [[#basis][<<<Basis>>>]]
          - [[#contravariant][<<<Contravariant>>>]]
            - [[#-151][/*/]]
          - [[#covariant][<<<Covariant>>>]]
            - [[#-152][/*/]]
        - [[#commutativity][<<<Commutativity>>>]]
          - [[#-153][/*/]]
        - [[#idempotence][<<<Idempotence>>>]]
          - [[#-154][/*/]]
        - [[#distributive-property][<<<Distributive property>>>]]
          - [[#-155][/*/]]
      - [[#effect][<<<Effect>>>]]
      - [[#bisimulation][<<<Bisimulation>>>]]
        - [[#-156][/*/]]
    - [[#content-word][<<<Content word>>>]]
    - [[#ancient-greek-and-latin-prefixes][Ancient Greek and Latin prefixes]]
      - [[#-157][/*/]]
    - [[#idiom][<<<Idiom>>>]]
      - [[#-158][/*/]]
    - [[#impredicative][<<<Impredicative>>>]]
    - [[#context-free-grammar][<<<Context-free grammar>>>]]
      - [[#-159][/*/]]
  - [[#set][<<<Set>>>]]
    - [[#-160][/*/]]
    - [[#closed-set][<<<Closed set>>>]]
    - [[#power-set][<<<Power set>>>]]
    - [[#singleton][<<<Singleton>>>]]
    - [[#russells-paradox][<<<Russell's paradox>>>]]
    - [[#cartesian-product][<<<Cartesian product>>>]]
      - [[#pullback][<<<Pullback>>>]]
        - [[#-161][/*/]]
  - [[#testing][<<<Testing>>>]]
    - [[#property-testing][<<<Property testing>>>]]
      - [[#function-property][<<<Function property>>>]]
      - [[#property-testing-type][<<<Property testing type>>>]]
      - [[#generator][<<<Generator>>>]]
        - [[#-162][/*/]]
        - [[#custom-generator][Custom generator]]
      - [[#reusing-test-code][<<<Reusing test code>>>]]
        - [[#test-commutative-property][<<<Test Commutative property>>>]]
        - [[#test-symmetry-property][<<<Test Symmetry property>>>]]
        - [[#test-equivalence-property][<<<Test Equivalence property>>>]]
        - [[#test-inverse-property][<<<Test Inverse property>>>]]
      - [[#quickcheck][<<<QuickCheck>>>]]
        - [[#manual-automation-with-quickcheck-properties][Manual automation with QuickCheck properties]]
    - [[#write-tests-algorithm][Write tests algorithm]]
    - [[#shrinking][<<<Shrinking>>>]]
  - [[#logic][Logic]]
    - [[#proposition][<<<Proposition>>>]]
      - [[#-163][/*/]]
      - [[#atomic-proposition][<<<Atomic proposition>>>]]
        - [[#-164][/*/]]
      - [[#compound-proposition][<<<Compound proposition>>>]]
        - [[#-165][/*/]]
      - [[#propositional-logic][<<<Propositional logic>>>]]
        - [[#-166][/*/]]
        - [[#first-order-logic][<<<First-order logic>>>]]
          - [[#-167][/*/]]
          - [[#second-order-logic][<<<Second-order logic>>>]]
            - [[#higher-order-logic][<<<Higher-order logic>>>]]
    - [[#logical-connective][<<<Logical connective>>>]]
      - [[#-168][/*/]]
      - [[#conjunction][<<<Conjunction>>>]]
      - [[#disjunction][<<<Disjunction>>>]]
    - [[#predicate][<<<Predicate>>>]]
    - [[#statement][<<<Statement>>>]]
      - [[#-169][/*/]]
    - [[#iff][<<<Iff>>>]]
  - [[#haskell-structure][Haskell structure]]
    - [[#-170][/*/]]
    - [[#pattern-match][<<<Pattern match>>>]]
      - [[#as-pattern][<<<As-pattern>>>]]
        - [[#-171][/*/]]
      - [[#wild-card][<<<Wild-card>>>]]
        - [[#-172][/*/]]
      - [[#case][<<<Case>>>]]
      - [[#guard][<<<Guard>>>]]
        - [[#-173][/*/]]
      - [[#pattern-guard][<<<Pattern guard>>>]]
        - [[#-174][/*/]]
      - [[#lazy-pattern][<<<Lazy pattern>>>]]
        - [[#-175][/*/]]
      - [[#pattern-binding][<<<Pattern binding>>>]]
        - [[#-176][/*/]]
    - [[#smart-constructor][<<<Smart constructor>>>]]
    - [[#level-of-code][<<<Level of code>>>]]
      - [[#-177][/*/]]
      - [[#type-level][<<<Type level>>>]]
        - [[#type-level-declaration][<<<Type level declaration>>>]]
          - [[#-178][/*/]]
        - [[#type-check][<<<Type check>>>]]
          - [[#-179][/*/]]
          - [[#complete-user-specific-kind-signature][<<<Complete user-specific kind signature>>>]]
            - [[#-180][/*/]]
      - [[#term-level][<<<Term level>>>]]
      - [[#compile-level][<<<Compile level>>>]]
        - [[#-181][/*/]]
      - [[#runtime-level][<<<Runtime level>>>]]
      - [[#kind-level][<<<Kind level>>>]]
        - [[#kind-check][<<<Kind check>>>]]
          - [[#-182][/*/]]
    - [[#orphan-type-instance][<<<Orphan type instance>>>]]
    - [[#undefined][<<<undefined>>>]]
    - [[#hierarchical-module-name][<<<Hierarchical module name>>>]]
      - [[#-183][/*/]]
    - [[#reserved-word][<<<Reserved word>>>]]
      - [[#-184][/*/]]
      - [[#import][<<<import>>>]]
      - [[#let][<<<let>>>]]
        - [[#-185][/*/]]
      - [[#where][<<<where>>>]]
        - [[#-186][/*/]]
    - [[#haskell-language-report][<<<Haskell Language Report>>>]]
      - [[#-187][/*/]]
    - [[#haskell][<<<Haskell'>>>]]
      - [[#-188][/*/]]
    - [[#lense][<<<Lense>>>]]
  - [[#computer-science][Computer science]]
    - [[#guerrilla-patch][<<<Guerrilla patch>>>]]
      - [[#monkey-patch][<<<Monkey patch>>>]]
    - [[#interface][<<<Interface>>>]]
    - [[#module][<<<Module>>>]]
    - [[#scope][<<<Scope>>>]]
      - [[#dynamic-scope][<<<Dynamic scope>>>]]
      - [[#lexical-scope][<<<Lexical scope>>>]]
        - [[#-189][/*/]]
      - [[#local-scope][<<<Local scope>>>]]
        - [[#-190][/*/]]
    - [[#shadowing][<<<Shadowing>>>]]
    - [[#syntatic-sugar][<<<Syntatic sugar>>>]]
    - [[#system-f][<<<System F>>>]]
      - [[#-191][/*/]]
    - [[#tail-call][<<<Tail call>>>]]
    - [[#thunk][<<<Thunk>>>]]
    - [[#application-memory][<<<Application memory>>>]]
    - [[#turing-machine][<<<Turing machine>>>]]
      - [[#turing-complete][<<<Turing complete>>>]]
        - [[#-192][/*/]]
    - [[#repl][<<<REPL>>>]]
    - [[#domain-specific-language][<<<Domain specific language>>>]]
      - [[#-193][/*/]]
      - [[#embedded-domain-specific-language][<<<Embedded domain specific language>>>]]
        - [[#-194][/*/]]
    - [[#data-structure][<<<Data structure>>>]]
      - [[#cons-cell][<<<Cons cell>>>]]
      - [[#construct][<<<Construct>>>]]
        - [[#-195][/*/]]
      - [[#leaf][<<<Leaf>>>]]
      - [[#node][<<<Node>>>]]
      - [[#spine][<<<Spine>>>]]
  - [[#graph-theory][<<<Graph theory>>>]]
    - [[#successor][<<<Successor>>>]]
      - [[#direct-successor][<<<Direct successor>>>]]
    - [[#predecessor][<<<Predecessor>>>]]
      - [[#direct-predecessor][<<<Direct predecessor>>>]]
    - [[#degree][<<<Degree>>>]]
      - [[#indegree][<<<Indegree>>>]]
      - [[#outdegree][<<<Outdegree>>>]]
    - [[#adjacency-matrix][<<<Adjacency matrix>>>]]
        - [[#instancesigs][<<<InstanceSigs>>>]]
    - [[#strongly-connected][<<<Strongly connected>>>]]
      - [[#-196][/*/]]
      - [[#strongly-connected-component][<<<Strongly connected component>>>]]
        - [[#-197][/*/]]
  - [[#tagless-final][<<<Tagless-final>>>]]
- [[#give-definitions][Give definitions]]
  - [[#identity-type][<<<Identity type>>>]]
  - [[#constant-type][<<<Constant type>>>]]
  - [[#gen][<<<Gen>>>]]
  - [[#tensorial-strength][<<<Tensorial strength>>>]]
  - [[#strong-monad][<<<Strong monad>>>]]
  - [[#weak-head-normal-form][<<<Weak head normal form>>>]]
    - [[#-198][/*/]]
  - [[#function-image][<<<Function image>>>]]
    - [[#-199][/*/]]
  - [[#invertible][<<<Invertible>>>]]
  - [[#invertibility][<<<Invertibility>>>]]
  - [[#define-language-pragma-options][<<<Define LANGUAGE pragma options>>>]]
    - [[#existentialquantification][<<<ExistentialQuantification>>>]]
    - [[#gadts][<<<GADTs>>>]]
    - [[#-200][/*/]]
    - [[#generalizednewtypeclasses][<<<GeneralizedNewTypeClasses>>>]]
    - [[#funcitonaldependencies][<<<FuncitonalDependencies>>>]]
  - [[#ghc-check-keys][<<<GHC check keys>>>]]
    - [[#-wno-partial-type-signatures][<<<-Wno-partial-type-signatures>>>]]
  - [[#generalised-algebraic-data-types][<<<Generalised algebraic data types>>>]]
    - [[#-201][/*/]]
  - [[#order-theory][<<<Order theory>>>]]
    - [[#domain-theory][<<<Domain theory>>>]]
    - [[#lattice][<<<Lattice>>>]]
    - [[#order][<<<Order>>>]]
      - [[#preorder][<<<Preorder>>>]]
        - [[#-202][/*/]]
        - [[#total-preorder][<<<Total preorder>>>]]
      - [[#partial-order][<<<Partial order>>>]]
        - [[#-203][/*/]]
    - [[#partial-order-1][<<<Partial order>>>]]
    - [[#total-order][<<<Total order>>>]]
  - [[#universal-algebra][<<<Universal algebra>>>]]
  - [[#relation-1][<<<Relation>>>]]
    - [[#reflexivity][<<<Reflexivity>>>]]
      - [[#-204][/*/]]
    - [[#irreflexivity][<<<Irreflexivity>>>]]
      - [[#-205][/*/]]
    - [[#transitivity][<<<Transitivity>>>]]
      - [[#-206][/*/]]
    - [[#symmetry][<<<Symmetry>>>]]
      - [[#-207][/*/]]
    - [[#equivalence][<<<Equivalence>>>]]
      - [[#-208][/*/]]
    - [[#antisymmetry][<<<Antisymmetry>>>]]
      - [[#-209][/*/]]
    - [[#asymmetry][<<<Asymmetry>>>]]
      - [[#-210][/*/]]
  - [[#cryptomorphism][<<<Cryptomorphism>>>]]
    - [[#-211][/*/]]
  - [[#lexically-scoped-type-variables][<<<Lexically scoped type variables>>>]]
  - [[#abstract-data-type][<<<Abstract data type>>>]]
    - [[#-212][/*/]]
  - [[#functional-dependencies][<<<Functional dependencies>>>]]
  - [[#monolocalbinds][<<<MonoLocalBinds>>>]]
  - [[#kindsignatures][<<<KindSignatures>>>]]
  - [[#explicitnamespaces][<<<ExplicitNamespaces>>>]]
  - [[#combinator-pattern][<<<Combinator pattern>>>]]
  - [[#symbolic-expression][<<<Symbolic expression>>>]]
    - [[#-213][/*/]]
  - [[#polynomial][<<<Polynomial>>>]]
    - [[#-214][/*/]]
  - [[#data-family][<<<Data family>>>]]
  - [[#type-synonym-family][<<<Type synonym family>>>]]
  - [[#indexed-type-family][<<<Indexed type family>>>]]
    - [[#-215][/*/]]
  - [[#typefamilies][<<<TypeFamilies>>>]]
  - [[#error][<<<Error>>>]]
    - [[#-216][/*/]]
  - [[#exception][<<<Exception>>>]]
    - [[#-217][/*/]]
  - [[#constraintkinds][<<<ConstraintKinds>>>]]
  - [[#specialisation][<<<Specialisation>>>]]
    - [[#-218][/*/]]
  - [[#diagram][<<<Diagram>>>]]
  - [[#cathegory-theoretical-presheaf][Cathegory theoretical <<<presheaf>>>]]
  - [[#topological-presheaf][Topological <<<presheaf>>>]]
  - [[#diagonal-functor][<<<Diagonal functor>>>]]
  - [[#limit-functor][<<<Limit functor>>>]]
  - [[#dual-vector-space][<<<Dual vector space>>>]]
  - [[#fundamental-group][<<<Fundamental group>>>]]
  - [[#algebra-of-continuous-function][<<<Algebra of continuous function>>>]]
  - [[#tangent-and-cotangent-bundle][<<<Tangent and cotangent bundle>>>]]
  - [[#group-action--representation][<<<Group action / representation>>>]]
  - [[#lie-algebra][<<<Lie algebra>>>]]
  - [[#tensor-product][<<<Tensor product>>>]]
  - [[#forgetful-functor-1][<<<Forgetful functor>>>]]
  - [[#free-functor][<<<Free functor>>>]]
  - [[#homomorphism-group][<<<Homomorphism group>>>]]
  - [[#representable-functor][<<<Representable functor>>>]]
  - [[#corecursion][<<<Corecursion>>>]]
  - [[#coinduction][<<<Coinduction>>>]]
  - [[#initial-algebra-of-an-endofunctor][<<<Initial algebra of an endofunctor>>>]]
  - [[#terminal-coalgebra-for-an-endofunctor][<<<Terminal coalgebra for an endofunctor>>>]]
- [[#citations][Citations]]
- [[#good-code][Good code]]
  - [[#good-type-aliasing][<<<Good: Type aliasing>>>]]
  - [[#good-type-wideness][<<<Good: Type wideness>>>]]
  - [[#good-print][<<<Good: Print>>>]]
  - [[#good-fold][<<<Good: Fold>>>]]
  - [[#good-computation-model][<<<Good: Computation model>>>]]
  - [[#good-make-bottoms-only-local][<<<Good: Make bottoms only local>>>]]
  - [[#good-newtype-wrap-is-ideally-transparent-for-compiler-and-does-not-change-performance][<<<Good: Newtype wrap is ideally transparent for compiler and does not change performance>>>]]
  - [[#good-instances-of-typestype-classes-must-go-with-code-you-write][<<<Good: Instances of types/type classes must go with code you write>>>]]
  - [[#good-functions-can-be-abstracted-as-arguments][<<<Good: Functions can be abstracted as arguments>>>]]
  - [[#good-infix-operators-can-be-bind-to-arguments][<<<Good: Infix operators can be bind to arguments>>>]]
  - [[#good-arbitrary][<<<Good: Arbitrary>>>]]
  - [[#good-principle-of-separation-of-concerns][<<<Good: Principle of Separation of concerns>>>]]
  - [[#good-function-composition][<<<Good: Function composition>>>]]
  - [[#good-point-free][<<<Good: Point-free>>>]]
    - [[#good-point-free-is-great-in-multi-dimentions][<<<Good: Point-free is great in multi-dimentions>>>]]
  - [[#good-functor-application][<<<Good: Functor application>>>]]
  - [[#good-parameter-order][<<<Good: Parameter order>>>]]
  - [[#good-applicative-monoid][<<<Good: Applicative monoid>>>]]
  - [[#good-creative-process][<<<Good: Creative process>>>]]
    - [[#pick-phylosophy-principles-one-to-three-the-more---the-harder-the-implementation][Pick phylosophy principles one to three the more - the harder the implementation]]
    - [[#draw-the-most-blurred-representation][Draw the most blurred representation]]
    - [[#deduce-abstractions-and-write-remotely-what-they-are][Deduce abstractions and write remotely what they are]]
    - [[#model-of-computation][Model of computation]]
      - [[#model-the-domain][Model the domain]]
      - [[#model-the-types][Model the types]]
      - [[#think-how-to-write-computations][Think how to write computations]]
    - [[#create][Create]]
  - [[#good-about-operators---------][<<<Good: About operators =(<$ )= =( **>)= =(<* )= =(>> )= >>>]]
    - [[#-][<<<= *>=>>>]]
  - [[#good-about-functions-like-mapm-sequence_][<<<Good: About functions like {mapM, sequence}_>>>]]
  - [[#good-guideliles][<<<Good: Guideliles>>>]]
    - [[#wikihaskell][Wiki.haskell]]
      - [[#documentation][Documentation]]
        - [[#comments-write-in-application-terms-not-technical][Comments write in application terms, not technical.]]
        - [[#tell-what-code-needs-to-do-not-how-it-does][Tell what code needs to do not how it does.]]
      - [[#haddoc][Haddoc]]
        - [[#put-haddock-comments-to-ever-exposed-data-type-and-function][Put haddock comments to ever exposed data type and function.]]
        - [[#haddock-header][Haddock header]]
      - [[#code][Code]]
        - [[#try-to-stay-closer-to-portable-haskell98-code][Try to stay closer to portable (Haskell98) code]]
        - [[#try-make-lines-no-longer-80-chars][Try make lines no longer 80 chars]]
        - [[#last-char-in-file-should-be-newline][Last char in file should be newline]]
        - [[#symbolic-infix-identifiers-is-only-library-writer-right][Symbolic infix identifiers is only library writer right]]
        - [[#every-function-does-one-thing][Every function does one thing.]]
  - [[#good-use-typed-holes-to-progress-the-code][<<<Good: Use Typed holes to progress the code>>>]]
  - [[#good-haskell-allows-infinite-terms-but-not-infinite-types][<<<Good: Haskell allows infinite terms but not infinite types>>>]]
  - [[#good-use-type-sysnonims-to-differ-the-information][<<<Good: Use type sysnonims to differ the information>>>]]
  - [[#good-controlmonaderror---controlmonadexcept][<<<Good: Control.Monad.Error -> Control.Monad.Except>>>]]
  - [[#good-monad-or-applicative][<<<Good: Monad OR Applicative>>>]]
      - [[#start-writing-monad-using-return-ap-liftm-liftm2--instead-of-do][Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>=']]
      - [[#basic-case-when-applicative-can-be-used][Basic case when Applicative can be used]]
      - [[#applicative-block-vs-monad-block][Applicative block vs Monad block]]
  - [[#good-haskell-package-versioning-policy][<<<Good: Haskell Package Versioning Policy>>>]]
    - [[#-219][/*/]]
  - [[#good-linear-type][<<<Good: Linear type>>>]]
  - [[#good-exception-vs-error][<<<Good: Exception vs Error>>>]]
  - [[#good-let-vs-where][<<<Good: Let vs. Where>>>]]
  - [[#good-rankntypes][<<<Good: RankNTypes>>>]]
  - [[#good-orphan-type-instance][<<<Good: Orphan type instance>>>]]
  - [[#good-smart-constructor][<<<Good: Smart constructor>>>]]
  - [[#good-thin-category][<<<Good: Thin category>>>]]
  - [[#good-recursion][<<<Good: Recursion>>>]]
  - [[#good-monoid][<<<Good: Monoid>>>]]
  - [[#good-free-monad][<<<Good: Free monad>>>]]
  - [[#good-use-mostly-where-clauses][<<<Good: Use mostly where clauses>>>]]
  - [[#good-where-clause-is-in-a-scope-with-function-parameters][<<<Good: Where clause is in a scope with function parameters>>>]]
  - [[#good-strong-preference-towards-pattern-matching-over-head-tail-etc-functions][<<<Good: Strong preference towards pattern matching over {head, tail, etc.} functions>>>]]
  - [[#good-patternmatching-is-possible-on-monadic-bind-in-do][<<<Good: Patternmatching is possible on monadic bind in do>>>]]
  - [[#good-applicative-vs-monad][<<<Good: Applicative vs Monad>>>]]
  - [[#good-statet-readert-writert][<<<Good: StateT, ReaderT, WriterT>>>]]
  - [[#good-working-with-monadtrans-and-lift][<<<Good: Working with MonadTrans and lift>>>]]
  - [[#good-dont-mix-where-and-let][<<<Good: Don't mix Where and Let>>>]]
  - [[#good-where-vs-let][<<<Good: Where vs. Let>>>]]
  - [[#good-the-proper-nature-algorithm-that-models-behaviour-of-many-objects-is-computation-heavy][<<<Good: The proper nature algorithm that models behaviour of many objects is computation heavy>>>]]
  - [[#good-in-haskell-parameters-bound-by-lambda-declaration-instantiate-to-only-one-concrete-type][<<<Good: In Haskell parameters bound by lambda declaration instantiate to only one concrete type>>>]]
  - [[#good-instance-is-a-good-structure-to-drew-a-type-line][<<<Good: Instance is a good structure to drew a type line>>>]]
  - [[#good-mtl-vs-transformers][<<<Good: MTL vs. Transformers>>>]]
- [[#bad-code][Bad code]]
  - [[#bad-pragma][<<<Bad pragma>>>]]
    - [[#bad-dangerous-language-pragma-option][Bad: Dangerous LANGUAGE pragma option]]
- [[#useful-functions-to-remember][Useful functions to remember]]
  - [[#prelude][Prelude]]
    - [[#ord][Ord]]
    - [[#calc][Calc]]
    - [[#list-operations][List operations]]
  - [[#datalist][Data.List]]
  - [[#datachar][Data.Char]]
  - [[#quickcheck-1][QuickCheck]]
- [[#tools][Tools]]
  - [[#ghc-pkg][ghc-pkg]]
  - [[#search-over-the-haskell-packages-code-codesearch-from-aelve][Search over the Haskell packages code: Codesearch from Aelve]]
  - [[#integration-of-nixosnix-with-haskell-ide-engine-hie-and-emacs-spacemacs][Integration of NixOS/Nix with Haskell IDE Engine (HIE) and Emacs (Spacemacs)]]
    - [[#1-install-the-cachix][1. Install the Cachix]]
    - [[#2-installation-of-hie][2. Installation of HIE]]
      - [[#21-provide-cached-builds][2.1. Provide cached builds]]
      - [[#22a-installation-on-nixos-distribution][2.2.a. Installation on NixOS distribution:]]
      - [[#22b-installation-with-nix-package-manager][2.2.b. Installation with Nix package manager:]]
    - [[#3-emacs-spacemacs-configuration][3. Emacs (Spacemacs) configuration:]]
    - [[#4-open-the-haskell-file-from-a-project][4. Open the Haskell file from a project]]
    - [[#5-be-pleased-writing-code][5. Be pleased writing code]]
    - [[#6-optional-debugging][6. (optional) Debugging]]
  - [[#debugger][Debugger]]
  - [[#ghcid][<<<GHCID>>>]]
  - [[#continuous-integration-platrorms-cis-for-open-source-haskell-projets][Continuous integration platrorms (CIs) for Open Source Haskell projets]]
- [[#libs][Libs]]
  - [[#exceptions][Exceptions]]
    - [[#exceptions---optionally-pure-extensible-exceptions-that-are-compatible-with-the-mtl][Exceptions - optionally pure extensible exceptions that are compatible with the mtl]]
    - [[#safe-exceptions---safe-simple-api-equivalent-to-the-underlying-implementation-in-terms-of-power-encourages-best-practices-minimizing-the-chances-of-getting-the-exception-handling-wrong][Safe-exceptions - safe, simple API equivalent to the underlying implementation in terms of power, encourages best practices minimizing the chances of getting the exception handling wrong.]]
    - [[#enclosed-exceptions---capture-exceptions-from-the-enclosed-computation-while-reacting-to-asynchronous-exceptions-aimed-at-the-calling-thread][Enclosed-exceptions - capture exceptions from the enclosed computation, while reacting to asynchronous exceptions aimed at the calling thread.]]
  - [[#memory-management][Memory management]]
    - [[#membrain---type-safe-memory-units][membrain - type-safe memory units]]
  - [[#parsers---megaparsec][Parsers - megaparsec]]
  - [[#clis---optparse-applicative][CLIs - optparse-applicative]]
  - [[#html---lucid][HTML - Lucid]]
  - [[#web-applications---servant][Web applications - Servant]]
  - [[#io-libraries][IO libraries]]
    - [[#conduit---practical-monolythic-guarantees-termination-return][Conduit - practical, monolythic, guarantees termination return]]
    - [[#pipes--pipes-parse---modular-more-primitive-theoretically-driven][Pipes + Pipes Parse - modular, more primitive, theoretically driven]]
  - [[#json---aeson][JSON - aeson]]
  - [[#backpack][<<<Backpack>>>]]
- [[#drafts][Drafts]]
  - [[#exception-handling][Exception handling]]
  - [[#constraints][Constraints]]
  - [[#monad-transformers-and-their-type-classes][Monad transformers and their type classes]]
  - [[#layering-monad-transformers][Layering monad transformers]]
  - [[#hoogle][Hoogle]]
    - [[#search][Search]]
    - [[#scope-1][Scope]]
      - [[#default][Default]]
      - [[#hierarchical-module-name-system-from-big-letter][Hierarchical module name system (from big letter):]]
      - [[#packages-lower-case][Packages (lower case):]]
  - [[#st-trick-monad][<<<ST-Trick monad>>>]]
    - [[#-220][/*/]]
  - [[#either][<<<Either>>>]]
    - [[#-221][/*/]]
  - [[#inverse][<<<Inverse>>>]]
  - [[#inversion][<<<Inversion>>>]]
  - [[#inverse-function][<<<Inverse function>>>]]
  - [[#inverse-morphism][<<<Inverse morphism>>>]]
  - [[#partial-inverse][<<<Partial inverse>>>]]
  - [[#patternsynonyms][<<<PatternSynonyms>>>]]
    - [[#-222][/*/]]
  - [[#ghc-debug-keys][<<<GHC debug keys>>>]]
    - [[#-ddump-ds][<<<-ddump-ds>>>]]
      - [[#-223][/*/]]
  - [[#ghc-optimize-keys][<<<GHC optimize keys>>>]]
    - [[#-foptimal-applicative-do][<<<-foptimal-applicative-do>>>]]
  - [[#computational-trinitarianism][<<<Computational trinitarianism>>>]]
    - [[#-224][/*/]]
  - [[#techniques-functional-programming-deals-with-the-state][Techniques functional programming deals with the state]]
    - [[#minimizing][Minimizing]]
    - [[#concentrating][Concentrating]]
    - [[#deferring][Deferring]]
  - [[#monadic-error-handling][Monadic Error handling]]
  - [[#functions][Functions]]
  - [[#void][<<<Void>>>]]
    - [[#-225][/*/]]
  - [[#constructive-proof][Constructive proof]]
  - [[#intuitionistic-logic][Intuitionistic logic]]
    - [[#-226][/*/]]
  - [[#principle-of-explosion][<<<Principle of explosion>>>]]
    - [[#-227][/*/]]
  - [[#universal-property][Universal property]]
  - [[#yoneda-lemma][Yoneda lemma]]
  - [[#monoidal-category-functoriality-of-adts-profunctors][Monoidal category, functoriality of ADTs, Profunctors]]
  - [[#const-functor][<<<Const functor>>>]]
  - [[#arrow-in-haskell][<<<Arrow in Haskell>>>]]
  - [[#contravariant-functor][Contravariant functor]]
  - [[#profunctor][Profunctor]]
  - [[#coerce][Coerce]]
    - [[#-228][/*/]]
- [[#reference][Reference]]
  - [[#functor-applicative-monad-proposal][<<<Functor-Applicative-Monad Proposal>>>]]
    - [[#-229][/*/]]
  - [[#haskell-98][Haskell-98]]
    - [[#old-instance-termination-rules][<<<Old instance termination rules>>>]]
  - [[#performance-results-and-comparisons-of-types--solutions][Performance results and comparisons of types & solutions]]
- [[#liturgy][Liturgy]]

* Definitions
:properties:
:ID:       68eb5f9c-7d07-4a32-9440-eb24e1399a7a
:end:

** <<<Algebra>>> :drill:
SCHT: <2021-01-29 Fri>
:properties:
:ID:       ef37e5f5-d52b-49eb-837e-1195558b6e79
:DRILL_LAST_INTERVAL: 326.7529
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 23:22]
:end:

الجبر /al-jabr/ assemble parts

A system of parts based on given axioms (properties) and operations on them.


---

Additional meanings:

1) Algebra - a set with its algebraic structure.
2) Abstract algebra - the study of number systems and operations within them.
3) Algebra - vector space over a field with a multiplication.

*** /*/

<<<Algebras>>>

*** <<<Algebraic>>> :drill:
:properties:
:ID:       c97061e0-d726-44d0-bd18-fd1288c46a52
:end:

Composite from simple parts.
Also: Algebraic data type.

*** <<<Algebraic structure>>> :drill:
SCHT: <2020-04-20 Mon>
:properties:
:ID:       dcbe48e5-d7dd-400d-9963-d4e00d474b84
:DRILL_LAST_INTERVAL: 59.7841
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.889
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:43]
:end:

/*/ includes axioms that must be satisfied and operations on the underlying (or "carrier") set.

An underlying set with /*/ on top of it also called "an algebra".

/*/ include groups, rings, fields, and lattices. More complex structures can be defined by introducing multiple operations, different underlying sets, or by altering the defining axioms. Examples of more complex /*/ can be many modules, algebras and other vector spaces, and any variations that the definition includes.

#+caption: Algebraic structures
#+name: tab--algebraic-structure
|                   | Closure | Associativity | Identity | Invertability | Commutativity |
|-------------------+---------+---------------+----------+---------------+---------------|
| Semigroupoid      |         | \check             |          |               |               |
| Small Category    |         | \check             | \check        |               |               |
| Groupoid          |         | \check             | \check        | \check             |               |
| Magma             | \check       |               |          |               |               |
| Quasigroup        | \check       |               |          | \check             |               |
| Loop              | \check       |               | \check        | \check             |               |
| Semigroup         | \check       | \check             |          |               |               |
| Inverse Semigroup | \check       | \check             |          | \check             |               |
| Monoid            | \check       | \check             | \check        |               |               |
| Group             | \check       | \check             | \check        | \check             |               |
| Ring              | \check       | \check             | \check        | \check             | under +       |
| Abelian group     | \check       | \check             | \check        | \check             | \check             |

**** /*/

<<<Algebraic structures>>>

**** <<<Fundamental theorem of algebra>>> :drill:
SCHT: <2020-04-23 Thu>
:properties:
:ID:       c44040e1-2dcf-4f25-9dee-05fd95337dc2
:DRILL_LAST_INTERVAL: 45.2687
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 13
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.308
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

Any non-constant single-variable polynomial with complex coefficients has at least one complex root.

From this definition follows property that the field of complex numbers is algebraically closed.

*** <<<Modular arithmetic>>> :drill:
:properties:
:ID:       dcfa0301-d300-4efd-97b5-510b705012cc
:end:

System for integers where numbers wrap around the certain values (single - /modulus/, plural - /moduli/).

Example - 12-hour clock.

**** /*/

<<<Clock arithmetic>>>

**** <<<Modulus>>> :drill:
SCHT: <2020-08-06 Thu>
:properties:
:ID:       740ee455-cd6f-4ee2-8ba1-46841e8b010a
:DRILL_LAST_INTERVAL: 167.6121
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:36]
:end:

Special numbers where arithmetic wraps around in modular arithmetic.

***** /*/

<<<Moduli>>> - plural.

** <<<Category theory>>> :drill:
SCHT: <2020-06-17 Wed>
:properties:
:ID:       a026cdb8-26e0-494e-b51c-b49d0210d61b
:DRILL_LAST_INTERVAL: 175.4598
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:37]
:end:

Category \( \mathcal{C} \) consists of the basis:

Primitives:
  1. Objects - \( a^{\mathcal{C}} \). A node. Object of some type. Often sets, than it is Set category.
  2. Arrows - \( {(a,b)}^{\mathcal{C}} \) (AKA morphisms mappings).
  3. Arrow (morphism) composition - binary operation: \( {(a, b)}^{\mathcal{C}} \circ {(b, c)}^{\mathcal{C}} \equiv {(a, c)}^{\mathcal{C}} \ | \ \forall a, b, c \in \mathcal{C} \). AKA principle of compositionality for arrows.

Properties (or axioms):
  1. Associativity of morphisms: \( {h} \circ ({g} \circ {f}) \equiv ({h} \circ {g}) \circ {f} \ \ | \ \ {f}_{a \to b}, {g}_{b \to c}, {h}_{c \to d} \).
  2. Every object has (two-sided) identity morphism (& in fact - exactly one): \( {1}_x \circ {f}_{a \to x} \equiv {f}_{a \to x}, \ \ {g}_{x \to b} \circ {1_x} \equiv {g}_{x \to b } \ \ | \ \ \forall x \ \exists {1}_{x}, \forall {f}_{a \to x},  \forall {g}_{x \to b} \).
  3. Principle of compositionality.

From these axioms, can be proven that there is exactly one identity morphism for every object.

Object and morphism are complete abstractions for anything.
In majority of cases under object is a state and morphism is a change.

*** /*/

<<<Category>>>
<<<Categories>>>

*** <<<Abelian category>>> :drill:
SCHT: <2020-04-13 Mon>
:properties:
:ID:       dfd74db1-0c16-430d-83b7-8dcc2fb16d34
:DRILL_LAST_INTERVAL: 34.6157
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 3.214
:DRILL_EASE: 2.2
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:56]
:end:

Generalised category for homological algebra (having a possibility of basic constructions and techniques for it).

Category which:
  * has a zero object,
  * has all binary biproducts,
  * has all kernel's and cokernels,
  * (it has all pullbacks and pushouts)
  * all monomorphism's and epimorphism's are normal.
Abelian category is a stable structure; for example it is regular and satisfy the snake lemma.
The class of Abelian categories is closed under several categorical constructions.

There is notion of Abelian monoid (AKS Commutative monoid) and Abelian group (Commutative group).

Basic examples of /*/:
  * category of Abelian groups
  * category of modules over a ring.

/*/ are widely used in algebra, algebraic geometry, and topology.

/*/ has many constructions like in categories of modules:
  * kernels
  * exact sequences
  * commutative diagrams

/*/ has disadvantage over category of modules. Objects do not necessarily have elements that can be manipulated directly, so traditional definitions do not work. Methods must be supplied that allow definition and manipulation of objects without the use of elements. 

**** /*/

<<<Abelian categories>>>

*** <<<Composition>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       b3bc17d9-83e4-4862-a391-27e0b30e011e
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:27]
:end:

Axiom of Category.

**** /*/

<<<Composable>>>
<<<Compositions>>>

*** <<<Endofunctor category>>> :drill:
:properties:
:ID:       1a5d0ae1-6c37-4e53-860b-beddb4c00074
:end:

From the name, in this Category:
  * objects of \( End \) are Endofunctors \( E^{\mathcal{C \to C}} \)
  * morphisms are natural transformations between endofunctors

*** <<<Functor>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       8cb2d494-936a-4031-b1c1-7ee18caecf31
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:26]
:end:

/*/ full translation (map) of one category into another.
Translating objects and morphisms (as input can take morphism or object).

/*/ - forgetful - discards part of the structure.
/*/ - faithful - fully preserves all morphisms - injective on Hom-sets.
/*/ - full - translation of morphisms fully covers all the morphisms between according objecs in the target categoty.

For Functor type class or fmap - see Power set functor.

Functor properties (axioms):
  * \( F^{\mathcal{C \to D}}(a) \quad | \quad \forall a^{\mathcal{C}} \) - every source object is mapped to object in target category
  * \( \overrightarrow{(F^{\mathcal{C \to D}}(a),F^{\mathcal{C \to D}}(b))}^{\mathcal{D}} \ \ | \ \ \forall \overrightarrow{(a, b)}^{\mathcal{C}} \) - every source morphism is mapped to target category morphism between corresponding objects
  * \( F^{\mathcal{C \to D}}(\overrightarrow{g}^{\mathcal{C}} \circ \overrightarrow{f}^{\mathcal{C}}) = F^{\mathcal{C \to D}}(\overrightarrow{g}^{\mathcal{C}}) \circ F^{\mathcal{C \to D}}(\overrightarrow{f}^{\mathcal{C}}) \quad | \quad \forall y=\overrightarrow{f}^{\mathcal{C}}(x), \forall \overrightarrow{g}^{\mathcal{C}}(y) \) - composition of morphisms translates directly (tautologically goes from other two)

These axioms guarantee that composition of functors can be fused into one functor with composition of morphisms. This process called fusion.

In Haskell this axioms have form:
#+begin_src haskell
fmap id = id
fmap (f . g) = fmap f . fmap g
#+end_src

Since /*/ is 1-1 mapping of initial objects - it is a memoizable dictionary with cardinality of initial objects. Also in Hask category functors are obviously endofunctors \therefore they are special kinds of containers for the parametric values (AKA product type). In Haskell product type /*/ are endofunctors from polymorphic type into a functor wrapper of a polymorphic type. 

/*/ translates in one direction, and does not provide algorythm of reversing itself or retriving the parametric value.

**** /*/

<<<Functors>>>

**** <<<Power set functor>>> :drill:
SCHT: <2020-04-07 Tue>
:properties:
:ID:       1169dfd1-4e31-4789-a777-288fc9208094
:DRILL_LAST_INTERVAL: 135.4761
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:31]
:end:

\( \mathcal{P^{S \to P(S)}} \)

/*/ - functor from set \( S \) to its power set \( \mathcal{P}(S) \).

Functor type class in Haskell defines a /*/ and allows to do function application inside type structure layers (denoted \( f \) or \( m \)). IO is also such structure.
Power set is unique to the set, /*/ is unique to the category (data type).
/*/ embodies in itself any endofunctor. It is easily seen from Haskell definition - that the /*/ is the polymorphic generalization over any endofunctor in a category. Application of a function to /*/ gives a particular endofunctor (see Hask category).

#+begin_src haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src

Functor instance must be of kind =( * -> * )=, so instance for higher-kinded data type must be applied until this kind.

Composed /*/ can lift functions through any layers of structures that belong to Functor type class.

/*/ can be used to filter-out error cases (Nothing & Left cases) in Maybe, Either and related types.

***** /*/

<<<fmap>>>
<<<Functor type class>>>

***** <<<Power set functor laws>>> :drill:
SCHT: <2020-06-03 Wed>
:properties:
:ID:       653e04a0-f7b1-4c48-b0c1-e6c83bc6db7c
:DRILL_LAST_INTERVAL: 181.5069
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:15]
:end:

Type instance of functor should abide this laws:

****** /*/

<<<Functor laws>>>

****** <<<Power set functor identity law>>> :drill:
SCHT: <2020-08-17 Mon>
:properties:
:ID:       46aa6606-2ac1-477e-9632-e79143f4fe3b
:DRILL_LAST_INTERVAL: 178.6567
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:36]
:end:

#+begin_src haskell
fmap id == id
#+end_src

****** <<<Power set functor composition law>>> :drill:
:properties:
:ID:       a25f03e6-0423-41b5-92a1-26d84bd6243e
:end:

#+begin_src haskell
fmap (f.g) == fmap f . fmap g
#+end_src
In words, it is if several functions are composed and then fmap is applied on them - it should be the same as if functions was fmapped and then composed.

***** <<<Lift>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       d6a94338-9bce-4513-8a51-66aefcc483fb
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

#+begin_src haskell
fmap :: (a -> b) -> (f a -> f b)
#+end_src
Functor takes function =a -> b= and returns a function =f a -> f b= this is called lifting a function.
Lift does a function application through the data structure.

****** /*/

<<<Lifting>>>

***** <<<Power set functor is a free monad>>> :drill:
SCHT: <2020-02-28 Fri>
:properties:
:ID:       85146d1c-7cb7-4c9b-a998-791b33f1a518
:DRILL_LAST_INTERVAL: 62.2874
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-28 Sat 17:28]
:end:

Since:
  * \( \forall e \in S : \ \exists \{e\} \, \in \, {\mathcal{P}(S)} \ \vDash \ \ \forall e \in S : \ \exists (e \to \{e\}) \equiv unit \)
  * \( \forall \mathcal{P}(S) : \ \mathcal{P}(S) \in \mathcal{P}(S) \ \vDash \ \ \forall \mathcal{P}(S) : \ \exists (\mathcal{P}(\mathcal{P}(S)) \to \mathcal{P}(S)) \equiv join \)

**** <<<Functorial>>> :drill:
:PROPERTIES:
:ID:       982baa45-e1f4-4878-be33-5ebb98e3295e
:END:

Corresponds to functor laws.

**** <<<Forgetful functor>>> :drill:
:properties:
:ID:       f175e7f3-f5bc-4c5c-b351-9df5080720b1
:end:

Functor that forgets part or all of what defines structure in domain category.
\( F^{\mathbf {Grp} \to \mathbf {Set}} \) that translates groups into their underlying sets.
Constant functor is another example.

***** /*/

<<<Forgetful>>>

**** <<<Identity functor>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       9dbbb6a7-e9ae-4c29-8468-aa20fc143b84
:DRILL_LAST_INTERVAL: 89.5155
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:34]
:end:

Maps all category to itself. All objects and morphisms to themselves.

Denotation:
\( 1^{\mathcal{C \to C}} \)

**** <<<Endofunctor>>> :drill:
SCHT: <2020-07-07 Tue>
:properties:
:ID:       96d8e579-c7b5-45a0-afbe-c4fca13c4637
:DRILL_LAST_INTERVAL: 224.8335
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:16]
:end:

Is a functor which source (domain) and target (codomain) are the same category.

\( F^{\mathcal{C \to C}}, E^{\mathcal{C \to C}} \)

***** /*/

<<<Endofunctors>>>

**** <<<Applicative functor>>> :drill:
SCHT: <2020-09-02 Wed>
:properties:
:ID:       423ac24e-497b-4ab1-b1c5-99ed84ec6546
:DRILL_LAST_INTERVAL: 194.5828
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:45]
:end:

/*/ - Computer science term. Category theory name - lax monoidal functor. And in category \( Set \), and so in category \( Hask \) all applicatives and monads are strong (have tensorial strength).

/*/ - sequences functorial computations (plain functors can't).

#+begin_src haskell
(<*>) :: f (a -> b) -> f a -> f b
#+end_src

Requires Functor to exist.
Requires Monoidal structure.

Has monoidal structure rules, separated form function application inside structure.

Data type can have several applicative implementations.

Standard definition:
#+begin_src haskell
class Functor f => Applicative f
 where
  (<*>) :: f (a -> b) -> f a -> f b
  pure :: a -> f a
#+end_src

=pure= - if a functor, identity Kleisli arrow, natural transformation.

Composition of /*/ always produces /*/, contrary to monad (monads are not closed under composition).

=Control.Monad= has an old function =ap= that is old implementation of =<*>=:
#+begin_src haskell
ap :: Monad m => m (a -> b) -> m a -> m b
#+end_src

***** /*/

<<<Applicative>>>
<<<Applicatives>>>
<<<Applicative functors>>>

***** <<<Applicative law>>> :drill:
:properties:
:ID:       e2527c05-e4d8-49e6-8648-02d49ab27c3a
:end:

***** /*/
<<<Applicative laws>>>

****** <<<Applicative identity law>>> :drill:
SCHT: <2020-09-07 Mon>
:properties:
:ID:       2e87e916-1501-4310-9887-e0bcf7b9e1ca
:DRILL_LAST_INTERVAL: 181.9534
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.364
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:00]
:end:

#+begin_src haskell
pure id <*> v = v
#+end_src

****** <<<Applicative composition law>>> :drill:
SCHT: <2020-07-22 Wed>
:properties:
:ID:       74ed933d-bb1e-4169-919a-b3c491973011
:DRILL_LAST_INTERVAL: 190.2455
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.875
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:00]
:end:

Function composition works regularly.
#+begin_src haskell
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
#+end_src

****** <<<Applicative homomorphism law>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       fe44ce3c-3912-48bd-8e60-367cc3ac3b20
:DRILL_LAST_INTERVAL: 85.2825
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.285
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:37]
:end:

Internal function application doesn't change the structure around values.
#+begin_src haskell
pure f <*> pure x = pure (f x)
#+end_src

****** <<<Applicative interchange law>>> :drill:
SCHT: <2020-03-17 Tue>
:properties:
:ID:       f3e40391-0f29-4689-852c-6fc7c3f57dfd
:DRILL_LAST_INTERVAL: 25.9819
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.545
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:48]
:end:

On condition that internal order of evaluation is preserved - order of operands is not relevant.
#+begin_src haskell
u <*> pure y = pure ($ y) <*> u
#+end_src

***** <<<Applicative function>>>

****** <<<liftA*>>>

******* <<<liftA>>> :drill:
SCHT: <2020-07-21 Tue>
:properties:
:ID:       8d9bbfb6-95d0-46c5-85bc-05c357721882
:DRILL_LAST_INTERVAL: 133.7192
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

Essentially a fmap.
#+begin_src haskell
:type liftA
liftA :: Applicative f => (a -> b) -> f a -> f b
#+end_src

Lifts function into applicative function.

******* <<<liftA2>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       68d78ba7-589e-4eb0-90fc-c6d286fd327e
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:55]
:end:

Lifts binary function across two Applicative functors.
#+begin_src haskell
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
#+end_src

#+begin_src haskell
liftA2 f x y == pure f <*> x <*> y
#+end_src

******* <<<liftA2 (<*>)>>> :drill:
:properties:
:ID:       ac1da978-3adc-447a-a20d-3f15f8cfd940
:end:

liftA2 (<*>) is pretty useful. It can lift binary operation through the two layers:
It is two-layer Applicative.
#+begin_src haskell
liftA2 :: Applicative f => (    a       ->  b  ->  c ) -> f      a        ->  f    b   ->  f    c
<*> :: Applicative f =>    (f  (a -> b) -> f a -> f b)
liftA2 (<*>) :: (Applicative f1, Applicative f2) =>      f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
#+end_src

******* <<<liftA2 (liftA2 (<*>))>>> :drill:
:properties:
:ID:       276bd112-3c4c-4c31-9650-28bce44786f9
:end:

liftA2 (<*>) 3-layer version.

******* <<<liftA3>>> :drill:
SCHT: <2020-10-10 Sat>
:properties:
:ID:       8371488b-da13-401b-9648-c286f2af0c99
:DRILL_LAST_INTERVAL: 269.6572
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

liftA2 3-parameter version.

#+begin_src haskell
liftA3 f x y z == pure f <*> x <*> y <*> z
#+end_src

****** Conditional applicative computations :drill:
:properties:
:ID:       4c9c0341-bcaf-4965-9316-f657015323ef
:end:

#+begin_src haskell
when :: Applicative f => Bool -> f () -> f ()
#+end_src

Only when =True= - perform an applicative computation.

#+begin_src haskell
unless :: Applicative f => Bool -> f () -> f ()
#+end_src

Only when =False= - perform an applicative computation.

***** <<<Special applicatives>>> :drill:
:properties:
:ID:       c67fa1eb-a529-43a8-b88b-926325e124ce
:end:

****** <<<Identity applicative>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       72602f6e-4290-4db5-bd26-f6abe614384d
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:17]
:end:

#+begin_src haskell
-- Applicative f =>
-- f ~ Identity
type Id = Identity
instance Applicative Id
  where
    pure :: a -> Id a
    (<*>) :: Id (a -> b) -> Id a -> Id b

mkId = Identity
xs = [1, 2, 3]

const <$> mkId xs <*> mkId xs'
-- [1,2,3]
#+end_src

****** <<<Constant applicative>>> :drill:
SCHT: <2020-05-02 Sat>
:properties:
:ID:       9389eea3-10e3-410b-a6ef-a56d9ab7163e
:DRILL_LAST_INTERVAL: 53.7507
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:09]
:end:

It holds only to one value. The function does not exist and last parameter is a phantom.
#+begin_src haskell
-- Applicative f =>
-- f ~ Constant e
type C = Constant
instance Applicative C
 where
  pure :: a -> C e a
  (<*>) :: C e (a -> b) -> C e a -> C e b
#+end_src

****** <<<Maybe applicative>>> :drill:
SCHT: <2020-10-16 Fri>
:properties:
:ID:       5929b239-fa46-40c6-9896-a2dabe40f619
:DRILL_LAST_INTERVAL: 221.1724
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:58]
:end:

"There also can be no function at all."

If function might not exist - embed =f= in Maybe structure, and use Maybe applicative.
#+begin_src haskell
-- f ~ Maybe
type M = Maybe
pure :: a -> M a
(<*>) :: M (a -> b) -> M a -> M b
#+end_src

****** <<<Either applicative>>> :drill:
:properties:
:ID:       f85602e3-3339-4ab7-ac38-5025b8aa6828
:end:

=pure= is =Right=.
Defaults to =Left=.
And if there is two =Left='s - to Left of the first argument.

****** <<<Validation applicative>>> :drill:
SCHT: <2020-04-19 Sun>
:properties:
:ID:       84ed0f96-b39b-4132-aafa-c6e58cb280ab
:DRILL_LAST_INTERVAL: 59.2075
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:41]
:end:

The Validation data type isomorphic to Either, but has accumulative Applicative on the Left side.
Validation data type is not a monad. Validation is an example of, "An applicative functor that is not a monad."
While Either monad on =Left= case just drops computation and returns this first =Left=. 
Monad needs to process the result of computation - it requires to be able to process all Left error statement cases for Validation, it is or non-terminaring Monad or one which is impossible to implement in polymorphic way with Validation.

***** <<<Monad>>> :drill:
SCHT: <2020-04-06 Mon>
:properties:
:ID:       b1faf835-213f-4336-86a9-8e331dd60986
:DRILL_LAST_INTERVAL: 129.2024
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:47]
:end:

μόνος /monos/ sole
μονάδα /monáda/ unit

/*/ - monoid in endofunctor category with \( \eta \) (unit) and \( \mu \) (join) natural transformations.

Monad on \( \mathcal{C} \) is \( \{E^{\mathcal{C \to C}}, \, \eta, \, \mu\} \):
  * \( E^{\mathcal{C \to C}} \) - is an endofunctor
  * two natural transformations, \( 1^c \to E \) and \( E \circ E \to E \):
    * \( \eta^{1^{\mathcal{C}} \to E} = {unit}^{Identity \to E}(x) = f^{ x \to E(x)}(x) \)
    * \( \mu^{(E \circ E) \to E} = {join}^{(E \circ E) \to (Identity \circ E)}(x) = | y = E(x) | = f^{E (y) \to y}(y) \)

where:
  * \( \mathcal{C} \) is a category
  * \( 1^{\mathcal{C}} \) denotes the \( \mathcal{C} \) identity functor
  * \( (E \circ E) \) - endofunctor \( \mathcal{C \to C} \)

Definition with \( \{E^{\mathcal{C \to C}}, \, \eta, \, \mu\} \) (in Hask: (\( \{e \, :: \, f \, a \, \to \, f \, b, \ pure, \ join\} \))) - is classic categorical, in Haskell minimal complete definition is \( \{fmap, \, pure, \, (>>=)\} \).

If there is a structure \( S \), and a way of taking object \( x \) into \( S \) and a way of collapsing \( S \circ S \) - there probably a monad.

Mostly monads used for sequencing actions (computations) (that looks like imperative programming), with ability to dependend on previous chains. Note if monad is commutative - it does not order actions.

Monad can shorten/terminate sequence of computations. It is implemented inside Monad instance. For example Maybe monad on Nothing drops chain of computation and returns Nothing.

/*/ inherits the Applicative instance methods:
#+begin_src haskell
import Control.Monad (ap)
return == pure
ap == (<*>) -- + Monad requirement
#+end_src

#+latex: {\footnotesize
#+caption: Monad in mathematics and Haskell
#+name: tab--monad-in-mathematics-haskell
| Math     | Meaning                                 | Cat/Fctr        | \( X \in C \)            | Type                      | Haskell |
|----------+-----------------------------------------+-----------------+------------------------+---------------------------+---------|
| \( Id \) | endofunctor "Id"                        | \( C \to C \)     | \( X \to Id (X) \)       | \( a \to a  \)              | id      |
| \( E \)  | endofunctor "monad"                     | \( C \to C \)     | \( X \to E (X) \)        | \( m \ a \to m \ b \)       | fmap    |
| \( \eta \)  | natural transformation "unit"           | \( Id \to E \)    | \( Id (X) \to E (X) \)   | \( a \to m \ a \)           | pure    |
| \( \mu \)  | natural transformation "multiplication" | \( E \circ E \to E \) | \( E (E(X)) \to E (X) \) | \( m \ (m \ a) \to m \ a \) | join    |
#+latex: }

Internals of Monad are Haskell data types, and as such - they can be consumed any number of times.

Composition of monadic types does not always results in monadic type.

****** /*/

<<<Monads>>>
<<<Monadic>>>

****** <<<Monad law>>> :drill:
SCHT: <2020-04-29 Wed>
:properties:
:ID:       7829bf03-a14b-411b-8460-7a8781227b60
:DRILL_LAST_INTERVAL: 125.5079
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.375
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:29]
:end:

Monad corresponds to functor laws & applicative laws and additionally:

******* /*/
<<<Monad laws>>>

******* <<<Monad left identity law>>> :drill:
SCHT: <2020-08-20 Thu>
:properties:
:ID:       2a41dd66-e0bf-4741-932f-9d28ae3a95c7
:DRILL_LAST_INTERVAL: 164.0829
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.4
:DRILL_EASE: 2.1
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

#+begin_src haskell
pure x >>= f == f x
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f =>    f a  -> (a -> f b) -> f b
                  pure x >>=     f      == f x
#+end_src
Rule that >>= must get first argument structure internals and apply to the function that is the second argument.

******* <<<Monad right identity law>>> :drill:
SCHT: <2020-03-14 Sat>
:properties:
:ID:       c009e530-319b-4127-8ca3-c05faf4f86cd
:DRILL_LAST_INTERVAL: 105.5573
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.444
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:50]
:end:

#+begin_src haskell
f >>= pure == f
#+end_src

Explanation:
#+begin_src haskell
>>= :: Monad f => f a  -> (a -> f b) -> f b
                  f   >>=    pure    == f
#+end_src
AKA it is a tacit description of a monad bind as endofunctor.

******* <<<Monad associativity law>>> :drill:
SCHT: <2020-03-14 Sat>
:properties:
:ID:       24c71ee3-c7b5-46ca-a9fa-6dff090cf836
:DRILL_LAST_INTERVAL: 22.7088
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:22]
:end:

#+begin_src haskell
(m >>= f) >>= g == m >>= (\ x -> f x >>= g)
#+end_src

****** <<<Monad type class>>> :drill:
:properties:
:ID:       3d4d8b32-1508-41b1-83a8-c0a910d8e1e8
:end:

#+begin_src haskell
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
#+end_src

******* <<<MonadPlus type class>>> :drill:
SCHT: <2020-06-04 Thu>
:properties:
:ID:       379a53d8-b1a9-4e0d-a1c6-fe201b9e9fd4
:DRILL_LAST_INTERVAL: 162.3323
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:30]
:end:

Is a monoid over monad, with additional rules.
The precise set of rules (properties) not agreed upon. Class instances obey /monoid/ & /left zero/ rules, some additionally obey /left catch/ and others /left distribution/.

Overall there /*/ currently reforms (MonadPlus reform proposal) in several smaller nad strictly defined type classes.

Subclass of an Alternative.

******** /*/

<<<Monadplus>>>

****** Functor -> Applicative -> Monad progression :drill:
:properties:
:ID:       21916c6b-42f9-46be-a4bb-60200aa5cb8d
:end:

#+begin_src haskell
<$> :: Functor     f =>   (a -> b)   -> f a -> f b
<*> :: Applicative f => f (a -> b)   -> f a -> f b
=<< :: Monad       f =>   (a -> f b) -> f a -> f b
#+end_src
=pure= & =join= are Natural transformations for the =fmap=.

****** <<<Monad function>>> :drill:
:properties:
:ID:       e15d6b3b-61de-489d-8a06-9986b24926d6
:end:

******* <<<Return function>>> :drill:
SCHT: <2020-10-08 Thu>
:properties:
:ID:       bb5891cb-a918-476b-a27a-4d342bdc30a2
:DRILL_LAST_INTERVAL: 268.496
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

#+begin_src haskell
return == pure
#+end_src
Nonstrict.

******* <<<Join function>>> :drill:
:properties:
:ID:       fda130b8-e8ae-4c3d-948a-94129d562a63
:end:

#+begin_src haskell
join :: Monad m => m (m a) -> m a
#+end_src

Generales knowledge of =concat=.

Kleisli composition that flattens two layers of structure into one.

The way to express ordering in lambda calculus is to nest.

******** /*/

<<<join>>>

******** join . fmap == (=<<)

#+begin_src haskell
-- b = f b
fmap        :: Monad f => (a -> f b) -> f a -> f (f b)
join        :: Monad f =>                      f (f a) -> f a
join . fmap :: Monad f => (a -> f b) -> f a            -> f b
flip    >>= :: Monad f => (a -> f b) -> f a            -> f b
#+end_src

******* <<<Bind function>>> :drill:
:properties:
:ID:       b288ba16-30a9-4550-b037-f77d4c96e95a
:end:

#+begin_src haskell
>>=         :: Monad f => f a -> (a -> f b) -> f b
join . fmap :: Monad f => (a -> f b) -> f a -> f b
#+end_src
Nonstrict.

The most ubiqutous way to >>= something is to use Lambda function:
#+begin_src haskell
getLine >>= \name -> putStrLn "age pls:"
#+end_src

Also a neet way is to bundle and handle Monad - is to bundle it with bind, and leave applied partially.
And use that partial bundle as a function - every evaluation of the function would trigger evaluation of internal Monad structure. Thumbs up. 
#+begin_src haskell
printOneOf :: Bool -> IO ()
printOneOf False = putStr "1"
printOneOf  True = putStr "2"

quant :: (Bool -> IO b) -> IO b
quant = (>>=) (randomRIO (False, True))

recursePrintOneOf :: Monad m => (t -> m a) -> t -> m b
recursePrintOneOf f x = (f x) >> (recursePrintOneOf f x)

main :: IO ()
main = recursePrintOneOf (quant) $ printOneOf
#+end_src

******** /*/

<<<Monadic extend>>>
<<<Monadic bind>>>
<<<Monad bind>>>
<<<Binder>>>
<<<Binder function>>>

********* (>>=)

********* >>=

********* (=<<)

********* =<<

******* <<<Sequencing operator>>> (>>) == (*>): :drill:
SCHT: <2020-06-09 Tue>
:properties:
:ID:       f8d9b6e3-b18c-4996-a86d-08107f8eec1f
:DRILL_LAST_INTERVAL: 167.0823
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.714
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:38]
:end:

Discard any resulting value of the action and sequence next action.
Applicative has a similar operator.
#+begin_src haskell
(>>) :: m a -> m b -> m b
(*>) :: f a -> f b -> f b
#+end_src

******* Monadic versions of list functions :drill:
:properties:
:ID:       0a38c76a-ae98-46dd-830a-62424aa6c8f7
:end:

#+begin_src haskell
sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
#+end_src

Sequence gets the traversable of monadic computations and swaps it into monad computation of taverse. In the result the collection of monadic computations turns into one long monadic computation on traverse of data.

If some step of this long computation fails - monad fails.

#+begin_src haskell
mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
#+end_src

=mapM= gets the AMB function, then takes traversable data. Then applies AMB function to traversable data, and returns converted monadic traversable data.

#+begin_src haskell
foldM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
foldl ::  Foldable t           => (b -> a ->   b) -> b -> t a ->   b
#+end_src

/*/ is a monadic =foldl=.

=b= is initial comulative value, =m b= is a comulative bank.
Right folding achieved by reversing the input list.

#+begin_src haskell
filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
filter ::                   (a ->   Bool) -> [a] ->   [a]
#+end_src

Take Boolean monadic computation, filter the list by it.

#+begin_src haskell
zipWithM :: Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
zipWith  ::                  (a -> b ->   c) -> [a] -> [b] ->   [c]
#+end_src

Take monadic combine function and combine two lists with it.

#+begin_src haskell
msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
sum  :: (Foldable t, Num a)       => t    a  ->   a
#+end_src

******* <<<liftM*>>>
:properties:
:ID:       6a0f3747-8f90-496b-9c5d-b4794502b725
:end:

******** <<<liftM>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       10f01bcb-ef2b-45c5-b950-6f2cb56eb908
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:27]
:end:

Essentially a fmap.

#+begin_src haskell
liftM :: Monad m => (a -> b) -> m a -> m b
#+end_src

Lifts a function into monadic equivalent.

******** <<<liftM2>>> :drill:
:properties:
:ID:       5915fc63-5e3a-47fa-83ba-3904abeccb14
:end:

Monadic liftA2.
#+begin_src haskell
liftM2 :: Monad m => (a -> b -> c) -> m a -> m a -> m c
#+end_src

Lifts binary function into monadic equivalent.

****** <<<Comonad>>> :drill:
SCHT: <2020-05-14 Thu>
:properties:
:ID:       f0f0fdd4-f056-4d4d-85ad-f449103b1d8c
:DRILL_LAST_INTERVAL: 140.9922
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.125
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:38]
:end:

Category \( \mathcal{C} \) comonad is a monad of opposite category \( \mathcal{C}^{op} \).

****** <<<Kleisli arrow>>> :drill:
:properties:
:ID:       0210aefe-3d66-4279-be2d-d323eef71954
:end:

Morphism that while doing computation also adds monadic-able structure.

#+begin_src haskell
a -> m b
#+end_src

******* /*/

<<<Kleisli arrows>>>
<<<Kleisli morphism>>>
<<<Kleisli morphisms>>>

****** <<<Kleisli composition>>> :drill:
:properties:
:ID:       2ca0a8e3-3fc8-4b82-90ae-99c684695d80
:end:

Composition of Kleisli arrows.

#+begin_src haskell
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c infixr 1
;; compare
(.)   ::            (b ->  c ) -> (a ->  b ) -> a ->  c
#+end_src

Often used left-to-right version:

#+begin_src haskell
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
;; compare
(>>=) :: Monad m =>       m a  -> (a -> m b)      -> m b
#+end_src

Which allows to replace monadic bind chain with Kleisli composition.

#+begin_src haskell
f1 arg >>= f2 >>= f3
==
f1 >=> f2 >=> f3 $ arg
==
f3 <=< f2 <=< f1 $ arg
#+end_src

****** <<<Kleisli category>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       4039e73f-073c-4930-9753-1af3fde66050
:DRILL_LAST_INTERVAL: 21.6837
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.357
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:46]
:end:

Category \( \mathcal{C} \), \( 〈E, \overrightarrow{\eta}, \overrightarrow{\mu}〉 \) monad over \( \mathcal{C} \).

Kleisli category \( \mathcal{C}_{T} \) of \( \mathcal{C} \):

\( \mathrm{Obj}(\mathcal{C}_{T}) \ = \ \mathrm{Obj}(\mathcal{C}) \)
\( \mathrm{Hom}_{\mathcal{C}_{T}}(x,y) \ = \ \mathrm{Hom}_{\mathcal{C}}(x,E(y)) \)

****** <<<Special monad>>>
:properties:
:ID:       6b44c29f-6e27-4ff3-bd40-d7f6ad97121b
:end:

******* <<<Identity monad>>> :drill:
:properties:
:ID:       dda1f03b-a476-48eb-894b-06d18733297b
:end:

Wraps data in the Identity constructor.

Useful: Creates monads from monad transformers.

Bind: Applies internal value to the bound function.

Code: (see: coerce)
#+begin_src haskell
newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
  fmap     = coerce

instance Applicative Identity where
  pure     = Identity
  (<*>)    = coerce

instance Monad Identity where
  m >>= k  = k (runIdentity m)
#+end_src

Example:
#+begin_src haskell
-- derive the State monad using the StateT monad transformer
type State s a = StateT s Identity a
#+end_src

******* <<<Maybe monad>>> :drill:
:properties:
:ID:       dce21b9b-4b6a-4aea-8cbe-06a84f8c1c0f
:end:

Something that may not be or not return a result. Any lookups into the real world, database querries.

Bind: =Nothing= input gives =Nothing= output, =Just x= input uses =x= as input to the bound function.

When some computation results in Nothing -  drops the chain of computations and returns Nothing.

Zero: Nothing
Plus: result in first occurence of Just else Nothing.

Code:
#+begin_src haskell
data Maybe a = Nothing | Just a

instance Monad Maybe where
  return         = Just
  fail           = Nothing
  Nothing  >>= _ = Nothing
  (Just x) >>= f = f x

instance MonadPlus Maybe where
  mzero             = Nothing
  Nothing `mplus` x = x
  x `mplus` _       = x
#+end_src

Example:
Given 3 dictionaries:
 1. Full names to email addresses,
 2. Nicknames to email addresses,
 3. Email addresses to email preferences.

Create a function that finds a person's email preferences based on either a full name or a nickname.
#+begin_src haskell
data MailPref = HTML | Plain
data MailSystem = ...

getMailPrefs :: MailSystem -> String -> Maybe MailPref
getMailPrefs sys name =
  do let nameDB = fullNameDB sys
         nickDB = nickNameDB sys
         prefDB = prefsDB sys
  addr <- (lookup name nameDB) `mplus` (lookup name nickDB)
  lookup addr prefDB
#+end_src

******* <<<Either monad>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       6e6e76cd-71f0-4c01-8c1b-8cde9026a30a
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:50]
:end:

When computation results in =Left= - drops other computations & returns the recieved =Left=.

******* <<<Error monad>>> :drill:
SCHT: <2020-03-08 Sun>
:properties:
:ID:       860961d0-78d3-4fdd-9845-3e1a2b800cf7
:DRILL_LAST_INTERVAL: 29.0758
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.143
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 22:48]
:end:

Someting that can fail, throw exceptions.

The failure process records the description of a failure. Bind function uses successful values as input to the bound function, and passes failure information on without executing the bound function.

Useful:
Composing functions that can fail. Handle exceptions, crate error handling structure.

Zero: empty error.
Plus: if first argument failed then execute second argument.

******* <<<List monad>>> :drill:
:properties:
:ID:       1645e551-ef15-4415-9a40-8d4a7066ff0b
:end:

Computations which may return 0 or more possible results.

Bind: The bound function is applied to all possible values in the input list and the resulting lists are concatenated into list of all possible results.

Useful: Building computations from sequences of non-deterministic operations.

Zero: []
Plus: (++)

******** /*/

<<<[] monad>>>

******* <<<Reader monad>>> :drill:
SCHT: <2020-07-20 Mon>
:properties:
:ID:       fff0059d-0484-41ee-b7c0-e91360c9ff62
:DRILL_LAST_INTERVAL: 149.727
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:16]
:end:

Creates a read-only shared environment for computations.

The =pure= function ignores the environment, while >>= passes the inherited environment to both subcomputations.

Today it is defined though ReaderT transformer:
#+begin_src haskell
type Reader r = ReaderT r Identity   -- equivalent to ((->) e), (e ->)
#+end_src

Old definition was:
#+begin_src haskell
newtype Reader e a = Reader { runReader :: (e -> a) }
#+end_src

For =(e ->)=:
  * Functor is =(.)=
#+begin_src haskell
fmap :: (b -> c) -> (a -> b) -> a -> c
fmap = (.)
#+end_src
  * Applicative:
    * =pure= is =const=
#+begin_src haskell
pure :: a -> b -> a
pure x _ = x
#+end_src
    * =(<*>)= is:
#+begin_src haskell
(<*>) :: (a -> b -> c) -> (a -> b) -> a -> c
(<*>) f g = \a -> f a (g a)
#+end_src

  * Monad:
#+begin_src haskell
(>>=) :: (a -> b) -> (b -> a -> c) -> a -> c
(>>=) m k = Reader $ \r ->
  runReader (k (runReader m r)) r

join :: (e -> e -> a) -> e -> a
join f x = f x x
#+end_src

#+begin_src haskell
runReader
  :: Reader r a  -- the Reader to run
  -> r  -- an initial environment
  -> a  -- extracted final value
#+end_src

Usage:
#+begin_src haskell
data Env = ...

createEnv :: IO Env
createEnv = ...

f :: Reader Env a
f = do
  a <- g
  pure a

g :: Reader Env a
g = do
  env <- ask  -- "Open the environment namespace into env"
  a <- h env  -- give env to h
  pure a

h :: Env -> a
...  -- use env and produce the result

main :: IO ()
main = do
  env <- createEnv
  a = runReader g env
  ...
#+end_src

In Haskell under normal circumstances impure functions should not directy call impure functions.
=h= is an impure function, and =createEnv= is impure function, so they should have intermediary.

******* <<<Writer monad>>> :drill:
:properties:
:ID:       fe69112e-4524-4ff4-b100-ac229efe5849
:end:

Computations which accumulate monoid data to a shared Haskell storage.
So /*/ is parametrized by monoidal type.

Accumulator is maintained separately from the returned values.

Shared value modified through Writer monad methods.

/*/ frees creator and code from manually keeping the track of accumulation.

Bind: The bound function is applied to the input value, bound function allowed to =<>= to the accumulator.

#+begin_src haskell
type Writer r = WriterT r Identity
#+end_src

Example:
#+begin_src haskell
f :: Monoid b => a -> (a, b)
f a = if _condition_
         then runWriter $ g a
         else runWriter do
           a1 <- h a
           pure a1

g :: Monoid b => Writer b a
g a = do
  tell _value1_  -- accumulator <> _value1_
  pure a  -- observe that accumulator stored inside monad and only a main value needs to be returned

h :: Monoid b => Writer b a
h a = do
  tell _value2_  -- accumulator <> _value_
  pure a
#+end_src

#+begin_src haskell
runWriter :: Writer w a -> (a, w)  -- Unwrap a writer computation as a (result, accumulator) pair.
                                   -- The inverse of writer.
#+end_src

=WriterT=, =Writer= unnecessarily keeps the entire logs in the memory. Use =fast-logger= for logging.

******* <<<State monad>>> :drill:
:properties:
:ID:       800e0e70-a69e-48e9-8592-426f5dd910cf
:end:

Computations that pass-over a state.

The bound function is applied to the input value to produce a state transition function which is applied to the input state.

Pure functional language cannot update values in place because it violates referential transparency.

#+begin_src haskell
type State s = StateT s Identity
#+end_src

Binding copies and transforms the state parameter through the sequence of the bound functions so that the same state storage is never used twice. Overall this gives the illusion of in-place update to the programmer and in the code, while in fact the autogenerated transition functions handle the state changes.

Example type: =State st a=

=State= describes functions that consume a state and produce a tuple of result and an updated state.

Monad manages the state with the next process:
#+downloaded: https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/State_Monad_Bind.svg/1162px-State_Monad_Bind.svg.png @ 2019-07-17 20:01:27
[[file:Book/1162px-State_Monad_Bind.svg_2019-07-17_20-01-27.png]]
Where:
  * f  - processsor making function
  * pA, pAB, pB - state processors
  * sN - states
  * vN - values
Bind with a processor making function from state procesor (pA) creates a new state processor (pAB).
The wrapping and unwrapping by State/runState is implicit.

****** <<<Monad transformer>>> :drill:
:properties:
:ID:       1357bbcf-fbf7-4607-9044-4d6e26c513d5
:end:

/*/ is a practical solution to the current functional programming problem about composition of monads.

Monad is not closed under compostion.
Composition of monadic types does not always results in monadic type.

Basic case: during implementation of monadic type composition, type =m T m a= arises, which does not allow to =unit=, =join= the =m= monadic layers.

/*/ have desirable properies and can add them to monads. /*/ user their implementation to solve the compostion type layering and allow to attach desirable property to result.

/*/ solve monad composition and type layering by cheating, using own structure and information about itself. It is often that process involves a catamorphism of a /*/ type layer.

In type signatures of transformers =*T m= - =m= is already an extended monad, so =*T= is just a wrapper to point that out.

Transformers have a light wrapper around the data that tags the modification with this transformer.

Main monadic structure =m= is wrapped around the internal data (core is =a=). The structure that corresponds to the transformer creation properties (if it emitted by \( \eta \) of a transformer), goes into =m= . Open parameters go external to the =m=.

#+begin_src haskell
newtype ExceptT e m a =
  ExceptT { runExceptT :: m (Either e a) }

newtype MaybeT m a =
  MaybeT { runMaybeT :: m (Maybe a) }

newtype ReaderT r m a =
  ReaderT { runReaderT :: r -> m a }
#+end_src

This has an effect that on stacking monad transformers, =m= becomes monad stack, and every next transformer injects the transformer creation-specific properies \( \eta \) inside the stack, so out-most transformer has inner-most structure. Base monad is structurally the outermost.

******* <<<MaybeT>>> :drill:
:properties:
:ID:       a339250b-4cbc-4c45-b9f8-092f8c166f8f
:end:

/*/ extends monads by injecting Maybe layer underneath monad, and processing that structure:
#+begin_src haskell
newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
#+end_src

******* <<<EitherT>>> :drill:
:properties:
:ID:       4c9b6c87-9795-4be9-ba24-3b6ea86e479a
:end:

/*/ extends monads by injecting Either layer underneath monad, and processing that structure:

#+begin_src haskell
newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }
#+end_src

=EitherT= of =either= package gets replaced by =ExceptT= of =transformers= or =mtl= packages.

******** /*/
<<<ExceptT>>>

******* <<<ReaderT>>> :drill:
:properties:
:ID:       90fe2f52-5a12-42aa-b622-8dfca4934998
:end:

Definition:
#+begin_src haskell
newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }
#+end_src

/*/ functions: input monad =m a=, out: =m a= wrapped it in a free-variable =r= (partially applied function).
That allows to use transformed =m a=, now it requires and can use the =r= passed environment.

To create a Reader monad:

#+begin_src haskell
type Reader r = ReaderT r Identity
#+end_src

******* <<<MonadTrans>>> type class :drill:
:properties:
:ID:       b09785c6-fd74-4096-8329-9908b7864d61
:end:

Allows to lift monadic actions into a larger context in a neutral way.

=pure= takes a parametric type and embodies it into constructed structure (talking of monad transformers - structure of the stacked monads).

=lift= takes monad and extends it with a transformer.

In fact, for monad transformers - =lift= is a last stage of the =pure=, it follows from the lift law.

Method:
#+begin_src haskell
lift :: Monad m => m a -> t m a
#+end_src
Lift a computation from the argument monad to the constructed monad.

Neutral means:
#+begin_src haskell
lift . return = return

lift (m >>= f) = lift m >>= (lift . f)
#+end_src

The general pattern with MonadTrans instances is that it is usually lifts the injection
of the known structure of transformer over some Monad.

lift embeds one monadic action into monad transformer.

The difference between pure, lift and MaybeT contructor becomes clearer if you look at the types:

Example, for =MaybeT IO a=:
#+begin_src haskell
pure      ::      a  -> MaybeT IO a
lift   ::    IO a  -> MaybeT IO a
MaybeT :: IO (Maybe a) -> MaybeT IO a

x = (undefined :: IO a)

:t (pure x)
(pure x) :: Applicative t => t (IO a)  -- t recieves one argument of product type
:t (pure x :: MaybeT IO a)
-- Expected type: MaybeT IO a1
--   Actual type: MaybeT IO (IO a0)

-- While the real type would be
:t (pure x :: MaybeT IO (IO a))
(pure x :: MaybeT IO (IO a)) :: MaybeT IO (IO a) -- This goes into a conflict of what type&kind (* -> *) transformer constructor awaits, and `m (m a)` is a layering we not interested in.


:t (lift x)
(lift x) :: MonadTrans t => t IO a  -- result is a proper expected product type

-- To belabour
:t (lift x :: MaybeT IO a)
(lift x) :: MonadTrans t => t IO a  -- result is a proper expected product type
#+end_src

=lift= is a natural transformation \( \eta \) from an Identity monad (functor) with other monad as content into transformer monad (functor), with the preservation of the conteined monad:
#+begin_src haskell
-- Abstract monads with content as parameters. Define '~>' as a family of morphisms that translate one functor into another (natural transformation)
type f ~> g = forall x. f x -> g x
-- follows
lift :: m ~> t m
#+end_src

********* <<<MonadIO>>> type class :drill:
:properties:
:ID:       af50ee71-0b5d-4c55-912b-7ffdfdc217a1
:end:

/*/ - allows to lift IO action until reaching the IO monad layer at the top of the =Monad= stack (which is allways in the Haskell code that does IO).

#+begin_src haskell
class (Monad m) => MonadIO m where
  liftIO :: IO a -> m a
#+end_src

=liftIO= laws:
#+begin_src haskell
liftIO . pure = pure

liftIO (m >>= f) = liftIO m >>= (liftIO . f)
#+end_src

Which is identical laws to MonadTrans =lift.=

Since =lift= is one step, and liftIO all steps - all steps defined in terms of one step and all other steps, so the most frequent implementation is self-recursive =lift . liftIO=:

#+begin_src haskell
liftIO ioa = lift $ liftIO ioa
#+end_src

********** /*/

<<<liftIO>>>

***** <<<Alternative type class>>> :drill:
SCHT: <2020-06-30 Tue>
:properties:
:ID:       b74a4135-6cc8-4944-9ba4-542b27c83dbe
:DRILL_LAST_INTERVAL: 188.0364
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 11:58]
:end:

Monoid over applicative. Has left catch property.

Allows to run simolteniously several instances of a computation (or computations) and from them yeld one result by law from =(<|>) :: Type -> Type -> Type=.

Minimal complete definition:
#+begin_src haskell
empty :: f a    -- The identity element of <|>
(<|>) :: f a -> f a -> f a    -- Associative binary operation
#+end_src

****** /*/

<<<Alternative>>>

**** <<<Monoidal functor>>> :drill:
:properties:
:ID:       8bafa7f0-72b2-4706-a623-69c5f09ab964
:end:

Functors between monoidal categories that preserves monoidal structure.

**** <<<Fusion>>> :drill:
SCHT: <2020-10-24 Sat>
:properties:
:ID:       401d4ba1-4405-4ca7-a96c-c8fe8d22c3bf
:DRILL_LAST_INTERVAL: 228.9343
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

#+begin_src haskell
fmap f . fmap g = fmap (f . g)
#+end_src

/*/ - functor axiom that allows to greatly simplify computations.

**** <<<=$>=>>> :drill:
:properties:
:ID:       b2e2a3bf-d31c-40cb-a7da-9f389190a773
:end:

Get & set a value inside Functor.

**** <<<Multifunctor>>> :drill:
SCHT: <2020-03-16 Mon>
:properties:
:ID:       3419635e-4b4a-4193-b50c-0e6ac3bf269d
:DRILL_LAST_INTERVAL: 24.6825
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:48]
:end:

Generalizes the concept of functor between categories, canonical morphisms between multicategories.

Works over /N/ type arguments instead of one.

To put simply - accepts multiple argumets, from that informatioin constructs source product category (Cartesian product) of categories, and is a functor from product category to target category.

To put even simplier - functor that takes as an argument the product of types.

In Haskell there is only one category, Hask, so in Haskell /*/ is still \( (Hask \times Hask) \rightarrow Hask \Rightarrow | (Hask \times Hask) \equiv Hask | \Rightarrow Hask \rightarrow Hask \) endofunctor.

Any product or sum in a Cartesian category is a /*/.

Code definition:
#+begin_src haskell
class Bifunctor f
 where
  bimap :: (a -> a') -> (b -> b') -> f a a' -> f a a'
  bimap f g = first f . second g
  first :: (a -> a') -> f a b -> f a' b
  first f = bimap f id
  second :: (b -> b') -> f a b -> f a b'
  second = bimap id
#+end_src

***** /*/
<<<Bifunctor>>>

**** /*/

<<<=<$=>>>

*** <<<Hask category>>> :drill:
:properties:
:ID:       dc1a0e79-c4bc-4c46-a9d7-84bb4f1d6a2e
:end:

Category of Haskell where objects are types and morphisms are functions.

It is a hypothetical category at the moment, since undefined and bottom values break the theory, is not Cartesian closed, it does not have sums, products, or initial object, =()= is not a terminal object, monad identities fail for almost all instances of the Monad class.

That is why Haskell developers think in subset of Haskell where types do not have bottom values. This only includes functions that terminate, and typically only finite values. The corresponding category has the expected initial and terminal objects, sums and products, and instances of Functor and Monad really are endofunctors and monads.

Hask contains subcategories, like Lst containing only list types.

Haskell and Category concepts:
  * Things that take a type and return another type are type constructors.
  * Things that take a function and return another function are higher-order functions.

**** /*/

<<<Hask>>>

*** <<<Magma>>> :drill:
:properties:
:ID:       c40ac83b-c730-4de5-915d-04d76c88398c
:end:

Set with a binary operation which form a closure.

**** <<<Mag category>>> :drill:
:properties:
:ID:       f9b01a3c-7f8c-43da-94d0-83cca1158686
:end:

The category of magmas, denoted \( Mag \), has as objects - sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).

***** /*/

<<<MAG>>>
<<<Magma category>>>
<<<Category of magmas>>>

**** <<<Semigroup>>> :drill:
SCHT: <2020-10-01 Thu>
:properties:
:ID:       7e67196b-643c-4726-8a17-6207826764bb
:DRILL_LAST_INTERVAL: 261.4179
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:56]
:end:

Magma with associative property of operation.

Defined in Haskell as:
#+begin_src haskell
class Semigroup a where
(<>) :: a -> a -> a
#+end_src

***** /*/

<<<Semigroups>>>

***** <<<Monoid>>> :drill:
SCHT: <2020-08-06 Thu>
:properties:
:ID:       6593c8fb-adda-488b-b86f-9544f62868eb
:DRILL_LAST_INTERVAL: 225.3206
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:39]
:end:

Semigroup with identity element. Category with a one object.

Ideally fits as an accumulation class.

#+begin_src haskell
class Monoid m where
mempty :: m
mappend :: m -> m -> m
mappend = (<>)
mconcat :: [m] -> m
mconcat = foldr mappend mempty
#+end_src

/*/ can be simplified to category with a single object, remember that monoid operation is a composition of morphisms operation in category.
For example to represent the whole non-negative integers with the one object and morphism "\( 1 \)" is absolutely enough, composition operation is "\( + \)".

#+begin_src haskell
import Data.Monoid
do
  show (mempty :: Num a => Sum a)
  -- "Sum {getSum = 0}"
  show $ Sum 1
  -- "Sum {getSum = 1}"
  show $ (Sum 1) <> (Sum 1) <> (Sum 1)
  -- "Sum {getSum = 3}"
  -- ...
#+end_src

Also backwards - any single-object category is a monoid. Category has an identity requirement and associativity of composition requirement, which makes it a free monoid. 

****** /*/

<<<Monoidal>>>
<<<Monoids>>>

****** <<<Monoid laws>>> :drill:
:properties:
:ID:       031cdf43-093d-4959-ac8b-f3e2ad35e7db
:end:

******* <<<Monoid left identity law>>> :drill:
SCHT: <2020-10-11 Sun>
:properties:
:ID:       ab71d331-f6f3-4edc-b734-c05c2df9630a
:DRILL_LAST_INTERVAL: 270.5287
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:58]
:end:

#+begin_src haskell
mempty <> x = x
#+end_src

******* <<<Monoid right identity law>>> :drill:
:properties:
:ID:       d048e3ea-ef53-4e33-ae78-88a60a07bacb
:end:

#+begin_src haskell
x <> mempty = x
#+end_src

******* <<<Monoid associativity law>>> :drill:
:properties:
:ID:       bd721cde-f8be-45a8-b098-6085d5254e2b
:end:

#+begin_src haskell
x <> mempty = x (y <> z) = (x <> y) <> z
mconcat = foldr (mempty <>)
#+end_src

Everything associative can be =mappend=.

****** <<<Commutative monoid>>> :drill:
SCHT: <2020-10-08 Thu>
:properties:
:ID:       ece84bf0-fff2-4bda-968c-473c7d7c959e
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

Operation that forms structure has commutativity property:
\( x \circ y = y \circ x \)

Opens a big abilities in concurrent and distributed processing.

******* /*/

<<<Abelian monoid>>>

****** <<<Group>>> :drill:
SCHT: <2020-07-04 Sat>
:properties:
:ID:       95a42c18-683b-4489-a2e9-e891e3fd9958
:DRILL_LAST_INTERVAL: 117.1166
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:58]
:end:

Monoid that has inverse for every element.

******* /*/

<<<Groups>>>

******* <<<Commutative group>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       778e3114-4600-4a39-a6d3-4f9955c61d66
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:25]
:end:

Commutative monoid that is a group.

******** /*/

<<<Abelian group>>>

******** <<<Ring>>> :drill:
SCHT: <2020-06-17 Wed>
:properties:
:ID:       437c3602-cfc2-4cd1-bdba-be9e0db9c8f8
:DRILL_LAST_INTERVAL: 175.3075
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:23]
:end:

Commutative group under + & monoid under \times, + \times connected by distributive property.

+ and \times are generalized binary operations of addition and multiplication. \times has no requirement for commutativity.

Example: set of same size square matricies of numbers with matrix operations form a ring.

********* /*/

<<<Rings>>>

*** <<<Morphism>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       8d0a8700-c48a-4195-8bd2-52a1b3866d76
:DRILL_LAST_INTERVAL: 109.8827
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.4
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:33]
:end:

μορφή /morphe/ form
Arrow between two objects inside a category.

Morphism can be anything.

Morphism is a generalization (\( f(x*y) \equiv f(x) \diamond f(y) \)) of homomorphism (\( f(x*y) \equiv f(x) * f(y) \)).
Since general morphisms not so much often ment and discussed - under morphism people almost always really mean the meaning of homomorphism-like properties, hense they discuss the algebraic structures (types) and homomorphisms between them.

In most usage, on a level under uder the objects: /*/ is most often means a map (relation) that translates from one mathematical structure (that source object represents) to another (that target object represents) (that is called (somewhat, somehow) "structure-preserving", but that phrase still means that translation can be lossy and irrevertable, so it is only bear reassemblence of preservation), and in the end the morphism can be anything and not hold to this conditions.

Morphism needs to correspond to function requirements to be it.

**** /*/

<<<Morphisms>>>
<<<Arrow>>>
<<<Arrows>>>

**** <<<Homomorphism>>> :drill:
SCHT: <2020-05-12 Tue>
:properties:
:ID:       f2e565b1-80d9-4d83-96c7-ba3e17440b75
:DRILL_LAST_INTERVAL: 139.0649
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.48
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

ὁμός /homos/ same (was chosen becouse of initial Anglish mistranslation to "similar")
μορφή /morphe/ form
similar form

/*/ map between two algebraic structures of the same type, operation-preserving.

\( f_{x \to y} = f(a \star b) = f(a) \diamond f(b) \),
where \( x,\ y \) are sets with additonal algebraic structure that includes \( \star, \diamond \) accordingly; \( a,\ b \) are elements of set \( x \).

/*/ sends identity morphisms to identity morphisms and inverses to inverses.

The concept of /*/ has been generalized under the name of morphism to many structures that either do not have an underlying set, or are not algebraic.

***** /*/

<<<Homomorphic>>>

**** <<<Identity morphism>>> :drill:
:properties:
:ID:       8581e216-8d9d-479f-a58d-bd04882b5131
:end:

Identity morphism - or simply identity: \( x \in C : \; id_{x}=1_{x} : x \to x \)
Composed with other morphism gives same morphism.

Corresponds to Reflexivity and Automorphism.

***** <<<Identity>>> :drill:
SCHT: <2020-04-25 Sat>
:properties:
:ID:       ed19af1f-09b7-43a0-82d2-ab30e198ae54
:DRILL_LAST_INTERVAL: 47.3759
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.556
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:08]
:end:

Identity only possible with morphism. See Identity morphism.

There is also distinct Zero value.

****** <<<Two-sided identity of a predicate>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       6f4649d2-e99e-4424-b575-0c2121a7569c
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

\( P(e,a)=P(a,e)=a \ | \ \exists e \in S, \forall a \in S \)
\( P() \) is commutative.

Predicate

****** <<<Left identity of a predicate>>> :drill:
SCHT: <2020-10-24 Sat>
:properties:
:ID:       1f08ecdc-8177-4f95-98c6-0c8858c54bf0
:DRILL_LAST_INTERVAL: 228.9343
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:58]
:end:

\( \exists e \in S, \forall a \in S : \; P(e,a)=a \)

Predicate

****** <<<Right identity of a predicate>>> :drill:
SCHT: <2020-10-10 Sat>
:properties:
:ID:       3ed093c4-db04-4e82-91b4-b01398b39e84
:DRILL_LAST_INTERVAL: 261.4179
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-23 Thu 22:57]
:end:

\(  P(a,e)=a \; | \; \exists e \in S, \forall a \in S \)

Predicate

***** <<<Identity function>>> :drill:
:properties:
:ID:       c687793c-ad12-435b-8326-9c335ebbf9ea
:end:

Return itself.
(\ x.x)
#+begin_src haskell
id :: a -> a
#+end_src

**** <<<Monomorphism>>> :drill:
:properties:
:ID:       18290d34-893c-42f0-bf4a-bb31f5e97711
:end:

μονο /mono/ only
μορφή /morphe/ form

Maps one to one (uniquely), so invertable (always has inverse morphism), so preserves the information/structure.
Domain can be equal or less to the codomain.

\( f^{X \to Y}, \ \forall x \in X \, \exists! y=f(x) \vDash f(x) \equiv f_{mono}(x) \) - from homomorphism context
\( f_{mono} \circ g1 = f_{mono} \circ g2 \ \vDash \ g1 \equiv g2 \) - from general morphism context
Thus /*/ is left canselable.

If /*/ is a function - it is injective. Initial set of /f/ is fully uniquely mapped onto the image of /f/.

***** /*/

<<<Monomorphic>>>
<<<Monomorphisms>>>

**** <<<Epimorphism>>> :drill:
SCHT: <2020-04-08 Wed>
:properties:
:ID:       3729d963-3775-4715-99d7-d14bc30750c0
:DRILL_LAST_INTERVAL: 131.4741
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:44]
:end:

επι /epi/ on, over
μορφή /morphe/ form

/*/ is right canselable morphism.
\( f^{X \to Y}, \forall y \in Y \, \exists f(x) \vDash f(x) \equiv f_{epi}(x) \) - from homomorphism context
\( g_1 \circ f_{epi} = g_2 \circ f_{epi} \Rightarrow \; g_1 \equiv g_2 \) - from general morphism context

In Set category if /*/ is a function - it is surjective (image of it fully uses codomain)
Codomain is a called a projection of the domain.

/*/ fully maps into the target.

***** /*/

<<<Epimorphic>>>
<<<Epimorphisms>>>

**** <<<Isomorphism>>> :drill:
:properties:
:ID:       4a0635c3-9512-443a-8497-3c259032de55
:end:

ἴσος /isos/ equal
μορφή /morphe/ form

Not equal, but equal for current intents and purposes.
Morphism that has inverse.
Almost equal, but not quite: =(Integer, Bool)= & =(Bool, Integer)= - but can be transformed losslessly into one another.

Bijective homomorphism is also isomorphism.

\( f^{-1, b \to a} \circ f^{a \to b} \equiv 1^a, \; f^{a \to b} \circ f^{-1, b \to a} \equiv 1^b \)

2 reasons for non-isomorphism:
  * function at least ones collapses a values of domain into one value in codomain
  * image (of a function in codomain) does not fill-in codomain. Then isomorphism can exists for image but not whole codomain.

Categories are isomorphic if there \( R \circ L = ID \)

***** /*/

<<<Isomorphic>>>
<<<Isomorphisms>>>

***** <<<Lax>>> :drill:
:PROPERTIES:
:ID:       9b9057db-929d-4239-adf9-87c3ae5ee0c5
:END:

Holds up to isomorphism.
(upon the transformation can be used as the same)

**** <<<Endomorphism>>> :drill:
SCHT: <2020-04-20 Mon>
:properties:
:ID:       2fd058e4-4b8a-451e-9760-0275b2741331
:DRILL_LAST_INTERVAL: 141.5502
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:13]
:end:

ενδο /endo/ internal
μορφή /morphe/ form

Arrow from object to itself.
Endomorphism forms a monoid (object exists and category requirements already in place).

***** <<<Automorphism>>> :drill:
SCHT: <2020-04-10 Fri>
:properties:
:ID:       fc880a3b-0339-4a6f-bffc-5d6c4c4eb1ae
:DRILL_LAST_INTERVAL: 32.146
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.364
:DRILL_EASE: 2.0
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

\alpha\upsilon\tau\omicron /auto/ self
μορφή /form/ form

Isomorphic endomorphism.

Corresponds to identity, reflexivity, permutation.

****** /*/

<<<Automorphic>>>
<<<Automorphisms>>>

***** /*/

<<<Endomorphic>>>
<<<Endomorphisms>>>

**** <<<Catamorphism>>> :drill:
SCHT: <2020-06-24 Wed>
:properties:
:ID:       3af3d5fd-449a-45e7-ac99-0cca150f0523
:DRILL_LAST_INTERVAL: 135.7197
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:03]
:end:

κατά /kata/ downward
μορφή /morphe/ form

Unique arrow from an initial algebra structure into different algebra structure.

/*/ in FP is a generalization folding, deconstruction of a data structure into more primitive data structure using a functor F-algebra structure. 

/*/ reduces the structure to a lower level structure.
/*/ creates a projection of a structure to a lower level structure.

***** /*/

<<<Catamorphic>>>
<<<Catamorphisms>>>

***** <<<Catamorphism law>>> :drill:
:properties:
:ID:       a1502d89-017c-41ce-ab89-a8b56f93489b
:end:

#+caption: Catamorphism laws in Haskell
#+name: tab--catamorphism-law-in-haskell
| Rule name    | Haskell                                                        |
|--------------+----------------------------------------------------------------|
| cata-cancel  | =cata phi . InF = phi . fmap (cata phi)=                         |
| cata-refl    | =cata InF = id=                                                  |
| cata-fusion  | =f . phi = phi . fmap f => f . cata phi = cata phi=               |
| cata-compose | =eps :: f :~> g => cata phi . cata (In . eps) = cata (phi . eps)= |

****** <<<Hylomorphism>>> :drill:
:properties:
:ID:       05e166e2-23f3-4e1a-9e6e-fd9ce910b785
:end:

catamorphism \( \circ \) anamorphism

Expanding and collapsing the structure.

******* /*/

<<<Hylomorphic>>>
<<<Hylomorphisms>>>

***** <<<Anamorphism>>> :drill:
SCHT: <2020-04-04 Sat>
:properties:
:ID:       731c7b76-f46b-478f-87c0-4c24cb3f8c5c
:DRILL_LAST_INTERVAL: 44.0524
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 2.818
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:36]
:end:

Generalizes unfold.

Dual concept to catamorphism.

Increases the structure.

Morphism from a coalgebra to the final coalgebra for that endofunctor.

Is a function that generates a sequence by repeated application of the function to its previous result.

****** /*/

<<<Anamorphic>>>
<<<Anamorphisms>>>

**** <<<Kernel>>> :drill:
SCHT: <2020-03-06 Fri>
:properties:
:ID:       44aee181-f629-4047-abf5-f2ae438f2063
:DRILL_LAST_INTERVAL: 139.8884
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 02:32]
:end:

Kernel of a homomorphism is a number that measures the degree homomorphism fails to meet injectivity (AKA be monomorphic).
It is a number of domain elements that fail injectivity:
  * elements not included into morphism
  * elements that collapse into one element in codomain
thou Kernel \( [ x | x \leftarrow 0 || x \ge 2 ] \).

Denotation:
\( \operatorname{ker}T = \{ \mathbf{v} \in V:T(\mathbf{v}) = \mathbf{0}_{W} \} \).

***** <<<Kernel homomorphism>>> :drill:
SCHT: <2020-04-28 Tue>
:properties:
:ID:       e77c8ade-6668-48e3-aeae-3bf1209e31d8
:DRILL_LAST_INTERVAL: 50.2714
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.3
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:09]
:end:

Morphism of elements from the kernel.
Complementary morphism of elements that make main morphism not monomorphic.

*** <<<Set category>>> :drill:
SCHT: <2020-03-31 Tue>
:properties:
:ID:       c6c7f178-7b69-4154-83ed-34de9b102193
:DRILL_LAST_INTERVAL: 165.4538
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 03:21]
:end:

Category in which objects are sets, morphisms are functions.

Denotation:
\( Set \)

*** <<<Natural transformation>>> :drill:
:properties:
:ID:       8591d1eb-0f0f-4f0e-b46b-05a4262646da
:end:

Roughly /*/ is:
#+begin_src haskell
trans :: F a -> G a
#+end_src
, while =a= is polymorphic variable.

Naturality condition: \( \forall \ a \ \exists \ (F \ a \to G \ a) \), or , analogous to parametric polymorphism in functions. Since /*/ in a category, stating \( \forall (F \ a \to G \ a) \)
Naturality condition means that all morphisms that take part in homotopy of source functor to target functor must exist, and that is the same, diagrams that take part in transformation, should commute, and different paths brins same result: if \( \alpha \) - natural transformation, \( \alpha_{a} \) natural transformation component - \( G \ f \circ \alpha_{a} = \alpha_{b} \circ F \ f \).
Since /*/ are just a type of parametric polymorphic function - they can compose.

/*/ (\( \overrightarrow{\eta}^{\mathcal{D}} \)) is transforming : \( \overrightarrow{\eta}^{\mathcal{D}} \circ F^{\mathcal{C \to D}} = G^{\mathcal{C \to D}} \).
/*/ abstraction creates higher-language of Category theory, allowing to talk about the composition and transformation of complex entities.

It is a process of transforming \( F^{\mathcal{C \to D}} \) into \( G^{\mathcal{C \to D}} \) using existing morphisms in target category \( \mathcal{D} \).

Since it uses morphisms - it is structure-preserving transformation of one functor into another. Iy mostly a lossy transformation. Only existing morphisms cab make it exist.

Existence of /*/ between two functors can be seen as some relation.

Can be observed to be a "morphism of functors", especially in functor category.
/*/ by \( \overrightarrow{\eta}^{\mathcal{D}}_{y^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \circ F^{\mathcal{C \to D}}(\overrightarrow{(x,y)}^{\mathcal{C}}) = G^{\mathcal{C \to D}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \circ \overrightarrow{\eta}^{\mathcal{D}}_{x^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \), often written short \( \overrightarrow{\eta}_{b} \circ F(\overrightarrow{f}) = G(\overrightarrow{f}) \circ \overrightarrow{\eta}_{a} \).
Notice that the \( \overrightarrow{\eta}^{\mathcal{D}}_{x^{\mathcal{C}}}(\overrightarrow{(x,y)}^{\mathcal{C}}) \) depends on objects&morphisms of \( \mathcal{C} \).

In words: /*/ depends on \( F \) and \( G \) functors, ability of \( D \) morphisms to do a homotopy of \( F \) to \( G \), and /*/:
  * for every object in \( \mathcal{C} \) picks natural transformation component in \( \mathcal{D} \).
  * for every morphism in \( \mathcal{C} \) picks the commuting diagram in \( \mathcal{D} \), called <<<naturality square>>>. 

Also see: Natural transformation in Haskell

Knowledge of /*/ forms a 2-category.

Can be composed
  * "vertically":

\begin{tikzcd}
a \arrow[rrrr, "F" description, bend left] \arrow[rrrr, "G" description, bend right] \arrow[rrrr, "H" description, bend right=60] &  & \Downarrow{\alpha} &  & b \\
                                                                                                                                  &  & \Downarrow{\beta}  &  &  
\end{tikzcd}

\begin{tikzcd}
a \arrow[rrrr, "F" description, bend left] \arrow[rrrr, "H" description, bend right=49] &  & \Downarrow{\beta\circ\alpha} &  & b
\end{tikzcd}


  * "horizontally" ("Godement product"):

\begin{tikzcd}
a \arrow[rr, "F_{1}" description, bend left] \arrow[rr, "G_{1}" description, bend right] & \Downarrow{\alpha} & b \arrow[rr, "F_{2}" description, bend left] \arrow[rr, "G_{2}" description, bend right] & \Downarrow{\beta} & c
\end{tikzcd}

\begin{tikzcd}
a \arrow[rr, "F_{2} \circ F_{1}" description, bend left] \arrow[rr, "G_{2} \circ G_{1}" description, bend right] & \Downarrow{\beta * \alpha} & c
\end{tikzcd}


Vertical and horizontal compositions can be done in any order, they abide the exchange law.

**** /*/

<<<Natural transformations>>>
<<<Naturality condition>>>
<<<Naturality>>>

**** <<<Natural transformation component>>> :drill:
:properties:
:ID:       d71f0216-0581-481b-a941-7974ec27ee2c
:end:

\( \overrightarrow{\eta}^{\mathcal{D}}(x) = F^{\mathcal{D}}(x) \to G^{\mathcal{D}}(x) \ | \  x \in \mathcal{C} \)

***** /*/

<<<Component of natural transformation>>>

**** <<<Natural transformation in Haskell>>> :drill:
SCHT: <2020-04-01 Wed>
:properties:
:ID:       60c3a507-2342-4bad-bd8c-f16adb4e9fbb
:DRILL_LAST_INTERVAL: 22.7451
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:02]
:end:

Family of parametric polymorphism functions between endofunctors.

In Hask is \( F \ a \to G \ a \). Can be analogued to repackaging data into another container, never modifies the object content, it only if - can delete it, because operation is lossy.

Can be sees as ortogonal to functors.

**** <<<Cat category>>> :drill:
:PROPERTIES:
:ID:       af015bd3-82ca-4dd4-95f5-314e93d6fa29
:END:

Category where:

|   | Part       | Is                                         | #      |
|---+------------+--------------------------------------------+--------|
| * | object     | category                                   | 0-cell |
| \Rightarrow | morphism   | functor                                    | 1-cell |
| \Rightarrow | 2-morphism | natural transformation, morphisms homotopy | 2-cell |

\begin{tikzcd}
a \arrow[rrrr, "F", bend left] \arrow[rrrr, "G", bend right] &  & \Downarrow{nt} &  & b
\end{tikzcd}

Is Cartesian closed category.

***** /*/
<<<Cat>>>
<<<2-category>>>

***** Bicategory :drill:
:PROPERTIES:
:ID:       61463bc0-6e2f-434b-a2fc-5595f0919fb8
:END:

2-category that is enriched and lax.

For handling relaxed associativity - introduces associator, and for identity l -eft/right unitor.

Forming from bicategories higher categories by stacking levels of abstraction of such categories - leads to explosion of special cases, differences of every level, and so overall difficulties.

Stacking groupoids (category in which are morphisms are invertable) is much more homogenous up to infinity, and forms base of the homotopy type theory.

*** <<<Category dual>>> :drill:
SCHT: <2020-04-24 Fri>
:properties:
:ID:       942d9234-d549-46a3-b051-ef1ac73244ad
:DRILL_LAST_INTERVAL: 100.7936
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:03]
:end:

Category duality behaves like a logical inverse.

Inverse \( \mathcal{C} \) = \( \mathcal{C}^{op} \) - inverts the direction of morphisms.

Composition accordingly changes to the morphisms: \( (g \circ f)^{op} = f^{op} \circ g^{op} \)

Any statement in the terms of \( \mathcal{C} \) in \( \mathcal{C}^{op} \) has the dual - the logical inverse that is true in \( \mathcal {C}^{op} \) terms.

Opposite preserves properties:
  * products: \( (\mathcal{C} \times \mathcal{D})^{op} \cong \mathcal{C}^{op} \times \mathcal{D}^{op} \)

  * functors: \( (F^{\mathcal{C} \to \mathcal{D}})^{op} \cong F^{\mathcal{C}^{op} \to \mathcal{D}^{op}} \)

  * slices: \( (\mathcal{F} \downarrow \mathcal{G})^{op} \cong (\mathcal{G}^{op} \downarrow \mathcal{F}^{op}) \)

****** /*/

<<<Opposite category>>>
<<<Opposite categories>>>
<<<Category duality>>>
<<<Duality>>>
<<<Dual category>>>
<<<Dual>>>

**** <<<Coalgebra>>> :drill:
:properties:
:ID:       a48247a2-f844-4c4e-9f40-e8cac61bb209
:end:

Structures that are dual (in the category-theoretic sense of reversing arrows) to unital associative algebras.
Every coalgebra, by vector space duality, reversing arrows - gives rise to an algebra. In finite dimensions, this duality goes in both directions. In infinite - it should be determined.

*** <<<Thin category>>> :drill:
:properties:
:ID:       130fbaa3-d9b8-43e6-8c29-b448b505d9d0
:end:

\forall Hom sets contain zero or one morphism.

\( f \equiv g \ | \ \forall x,y \ \forall f,g: x \to y \)

A proset (preordered set).

**** /*/

<<<Proset category>>>
<<<Prosetal category>>>
<<<Poset category>>>
<<<Posetal category>>>

*** <<<Commuting diagram>>> :drill:
:properties:
:ID:       ca1088d3-dae2-4621-84e0-a6ce61222e09
:end:

Establishes equality in morphisms that have same source and target.

Draws the morphisms that are:
\( f = g \Rightarrow \{f, y\}: X \to Y \)

**** /*/

<<<Diagram commutes>>>
<<<Commutes>>>

*** <<<Universal construction>>> :drill:
:properties:
:ID:       5341cb9e-0f97-4ab2-9833-2bca2c72fb18
:end:

Algorythm of constructing definitions in Category theory.
Specially good to translate properties/definitions from other theories (Set theory) to Categories.

Method:
  1. Define a pattern that you defining.
  2. Establish ranking for pattern matches.
  3. The top of ranking, the best match or set of matches - is the thing you was looking for. Matches are isomorphic for defined rules.

/*/ uses Yoneda lemma, and as such constructions are defined until isomorphism, and so isomorphic betweem each-other.

**** /*/

<<<Universal constructions>>>

*** <<<Product>>> :drill:
:properties:
:ID:       21499e97-b28f-4377-9929-ed3d5d8e24f3
:end:

Universal construction:

\begin{matrix}
&& c^{\prime} && \\
& {}^p\swarrow\phantom{{}^{p}} & {\tiny \phantom{!}}\downarrow{\tiny !} & \phantom{{}^q}\searrow^q& \\
a & \underset{\pi_a}{\leftarrow} & c & \underset{\pi_b}{\rightarrow} & b
\end{matrix}

Pattern: \( p: c \to a, \ q: c \to b \)
Ranking: \( \max{\sum^{\forall}{(!: c\prime \to c \ | \ p\prime = p \circ !, \ q\prime = q \circ !)}} \)
\( c\prime \) is another candidate.

For sets - Cartesian product.

/*/ is a pair. Corresponds to product data type in Hask (inhabited with all elements of the Cartesian product).

Dual is Coproduct.

**** /*/

<<<Products>>>

*** <<<Coproduct>>> :drill:
:properties:
:ID:       3599f721-e345-40e4-8361-be4d0898d35a
:end:

Universal constructuon:
\begin{matrix}
&& c\prime && \\
& {}^p\nearrow\phantom{{}^{p}} & {\tiny \phantom{!}}\uparrow{\tiny !} & \phantom{{}^q}\nwarrow^q& \\
a & \underset{\iota_a}{\rightarrow} & c & \underset{\iota_b}{\leftarrow} & b
\end{matrix}

Pattern: \( i: a \to c, \ j: b \to c \)
Ranking: \( \max{\sum^{\forall}{(!: c \to c\prime \ | \ i\prime = ! \circ i, \ j\prime = ! \circ j)}} \)
\( c\prime \) is another candidate.

For sets - Disjoint union.

/*/ is a set assembled from other two sets, in Haskell it is a tagged set (analogous to disjoint union).

Dual is Product.

**** /*/

<<<Coproducts>>>

*** <<<Free object>>> :drill:
:properties:
:ID:       5e1469b1-ce93-4f70-a820-2735857d3af7
:end:

General particular structure.
In which structure, properties autofollows from definition, axioms.

Also uses as a term when surcomstances of structures, rules, properties, axioms used coinside with the definition of a particular object \therefore form object of this type with the according properties and possibilities.

*** <<<Internal category>>> :drill:
:PROPERTIES:
:ID:       d0492e1d-4e50-43dc-b9f6-6c59132b0eed
:END:

Category which is includded into a bigger category.

*** <<<Hom set>>> :drill:
SCHT: <2020-07-02 Thu>
:properties:
:ID:       69d139d5-3a8d-4a07-a5b3-44778cc0ce61
:DRILL_LAST_INTERVAL: 189.7248
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:22]
:end:

All morphisms from source object to target object.

Denotation:
\( hom_{C}(X,Y) = (\forall f: X \to Y) = hom(X,Y) = C(X,Y) \)
Denotation was not standartized.

Hom sets belong to Set category.

In Set category: \( \exists! (a, b) \iff \exists! Hom \), \( \forall Hom \in \ Set \). Set category is special, Hom sets are also objects of it.

Category can include Set, and hom sets, or not.

**** /*/
<<<Hom-set>>>
<<<Hom sets>>>

**** <<<Hom-functor>>> :drill:
SCHT: <2020-03-20 Fri>
:properties:
:ID:       e2bb6ea3-2f94-47d8-b4ab-b09feb096d98
:DRILL_LAST_INTERVAL: 11.3281
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 28
:DRILL_FAILURE_COUNT: 15
:DRILL_AVERAGE_QUALITY: 2.643
:DRILL_EASE: 1.34
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

\( hom:\mathcal{C}^{op} \times \mathcal{C} \to Set \)
Functor from the product of \( \mathcal{C} \) with its opposite category to the category of sets.

Denotation variants:
\( H_A = \mathrm{Hom}(-, A) \)
\( h_A = {\cal \mathcal{C}}(-, A) \)
\( Hom(A,-): \ \mathcal{C} \to Set \)

Hom-bifunctor:
\( Hom(-,-): \ \mathcal{C}^{op} \times \mathcal{C} \to Set \)

**** <<<Exponential object>>> :drill:
:PROPERTIES:
:ID:       2ed36b60-ef0f-4ab2-bb90-8349982d76db
:END:

Generalises the notion of function set to internal object.
As also hom set to internal hom objects.

Cartesian closed (monoidal) category strictly required, as /*/ multiplicaton holds composition requirement: 

\( \circ:hom(y,z) \otimes hom(x,y) \to hom(x,z) \)

Denotation:
\( b^{a} \)

Universal construction:

\begin{tikzcd}
c \arrow[d, "u" description, dotted] & c \times a \arrow[d, "u \times 1^{a}" description, dotted] \arrow[rd] &   \\
b^{a}                                & b^{a} \times a \arrow[r, "eval" description, dotted]                  & b
\end{tikzcd}
, where in Category: \( b^{a} \) - exponential object, \times - product bifunctor, \( a \) - argument of /*/, \( b \) - result, \( c \) - candidate, \( b^{a} \equiv ( a \Rightarrow b ) \) - /*/.

/*/ \( b^{a} \) (also as \( (a \Rightarrow b) \)) represent exponentiation of cardinality of \( \forall b^{a} \) possiblities.

***** /*/
<<<Function object>>>
<<<Internal hom>>>
<<<Exponential objects>>>
<<<Hom object>>>
<<<Hom objects>>>

***** <<<Enriched category>>> :drill:
:PROPERTIES:
:ID:       821d08ed-f6b4-44a3-ba6d-9dbb6dd22252
:END:

Uses Hom objects (exponential objects), which do not belong into Set category.
Category is no longer small, now may be called large.

\( hom(x,y) \in K \).

Called: /*/ over =K= (whick holds hom objects).

****** /*/
<<<Enriched>>>
<<<Large category>>>

** <<<Data type>>> :drill:
SCHT: <2020-07-22 Wed>
:properties:
:ID:       1da15965-03f0-4cf9-a582-3df5c4deb27e
:DRILL_LAST_INTERVAL: 210.3048
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:38]
:end:

Set of values.
For type to have sence the values must share some sence, properties.

*** /*/

<<<Type>>>
<<<Types>>>
<<<Data types>>>

*** <<<Actual type>>> :drill:
SCHT: <2020-03-01 Sun>
:properties:
:ID:       1325dd6d-8944-4226-a703-e5e7ecb90838
:DRILL_LAST_INTERVAL: 139.9519
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-13 Sun 02:01]
:end:

Data type recieved by ->inferring->compiling->execution.

*** <<<Algebraic data type>>> :drill:
:properties:
:ID:       3c1de247-a95a-4cb3-ba2d-476bd69f263a
:end:

Composite type formed by combining other types.

**** /*/

<<<AlgDT>>>

*** <<<Cardinality>>> :drill:
SCHT: <2020-05-26 Tue>
:properties:
:ID:       22428179-0fdb-4723-94dc-596dd41f61c0
:DRILL_LAST_INTERVAL: 194.5828
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-13 Wed 20:50]
:end:

Number of possible implementations for a given type signature.

Disjunction, sum - adds cardinalities.
Conjunction, product - multiplies cardinalities.

**** /*/
<<<Cardinalities>>>

*** <<<Data constant>>> :drill:
:properties:
:ID:       c6fd80d7-4f2b-4c0e-a924-db0616cd126d
:end:

/*/ - constant value; nullary data constructor.

*** <<<Data constructor>>> :drill:
:properties:
:ID:       dc94bd99-113e-4025-82e8-39cd6843091b
:end:

One instance that inhabit data type.

*** <<<data declaration>>> :drill:
:properties:
:ID:       4c0b5dd7-d8e2-4394-9a38-e99bd7961130
:end:

Data type declaration is the most general and versatile form to create a new data type.
Form:
#+begin_src haskell
data [context =>] type typeVars1..n
  = con1  c1t1..i
  | ...
  | conm  cmt1..q
  [deriving]
#+end_src

*** <<<Dependent type>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       f40f1feb-3a1d-4987-b585-6d8d6080d307
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:25]
:end:

When type and values have relation between them. Type has restrictions for values, value of a type variable has a result on the type.

**** /*/

<<<Dependent types>>>

*** <<<Gen type>>> :drill:
SCHT: <2020-06-27 Sat>
:properties:
:ID:       a4d8e374-a99a-4d9a-b159-13b004c2b3ed
:DRILL_LAST_INTERVAL: 210.586
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.286
:DRILL_EASE: 2.86
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:47]
:end:

Generator. Gen type is to generate pseudo-random values for parent type. Produces a list of values that gets infinitely cycled.

*** <<<Higher-kinded data type>>> :drill:
SCHT: <2020-06-03 Wed>
:properties:
:ID:       f923ff3e-43bb-4e4a-8c55-e4f2354e3810
:DRILL_LAST_INTERVAL: 181.5069
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:24]
:end:

Any combination of * and ->

Type that take more types as arguments.

/Humbly really a function/

**** /*/

<<<Higher-kinded data types>>>

*** <<<newtype declaration>>> :drill:
SCHT: <2020-04-12 Sun>
:properties:
:ID:       f9bbca43-6672-48e8-8d1c-af323786efc2
:DRILL_LAST_INTERVAL: 140.3838
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:24]
:end:

Create a new type from old type by attaching a new constructor, allowing type class instance declaration.
#+begin_src haskell
newtype FirstName = FirstName String
#+end_src

Data will have exactly the same representation at runtime, as the type that is wrapped.

#+begin_src haskell
newtype Book = Book (Int, Int)
#+end_src
#+begin_src text
      (,)
      / \
Integer Integer
#+end_src

*** <<<Principal type>>> :drill:
SCHT: <2020-06-20 Sat>
:properties:
:ID:       55ec2cac-10dc-4a09-a795-4e99c7e5aaed
:DRILL_LAST_INTERVAL: 203.1819
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:01]
:end:

The most generic data type that still typechecks.

*** <<<Product data type>>> :drill:
SCHT: <2020-04-13 Mon>
:properties:
:ID:       dcca9aba-08e0-4616-8bec-b803bf67f066
:DRILL_LAST_INTERVAL: 140.2908
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:18]
:end:

Is an algebraic data type respesentation of a product construction.
Formed by logical conjunction (=AND=, '=* *=').

Haskell forms:
#+begin_src haskell
-- 1. As a tuple (the uncurried & most true-form)
(T1, T2)

-- 2. Curried form, data constructor that takes two types
C T1 T2

-- 3. Using record syntax. =r# <inhabitant>= would return the respective =T#=.
C { r1 :: T1
  , r2 :: T2
  }
#+end_src

**** /*/

<<<Product type>>>

**** <<<Sequence>>> :drill:
:PROPERTIES:
:ID:       ce72c132-c2e8-4d14-bac6-4b399735c7fa
:END:

Enumerated (ordered) set.

Denotation:
#+begin_src haskell
()
( , )
( , , )
( , , ... )
#+end_src

More general mathematical denotation was not established, variants:
\( (n)_{n \in \mathbb{N}} \)
\( \omega \to X \)
\( \{ i:Ord \ | \ i < \alpha \} \)

In Haskell: Data type that stores multiple ordered values withing a single value.

#+caption: Sequence constructor naming by arity
#+name: tab--sequence-names
| Name                   | Arity | Denotation |
|------------------------+-------+------------|
| Unit, empty            |     0 | =()=         |
| Singleton              |     1 | =(_)=        |
| <<<Tuple>>>, pair, <<<two-tuple>>> |     2 | =( , )=      |
| <<<Triple>>>, three-tuple    |     3 | =( , , )=    |
| Sequence         |     N | =( , , ...)= |

***** /*/

<<<Sequences>>>
<<<Tuples>>>
<<<Ordered pair>>>
<<<Ordered triple>>>

***** <<<List>>> :drill:
:properties:
:ID:       935629ed-4dee-43ef-9eff-51de168656d7
:end:

The same type objects sequence.

Denotation:
#+begin_src haskell
[]
[ , ]
[ , , ]
[ , , ... ]
#+end_src

Haskell definition:
#+begin_src haskell
data [] a = [] | a : [a]
#+end_src

Definition is self-referrential (self-recursive), can be seen as anamorphism (unfold) of the =[]= (empty list, memory cell which is container of particular type) and =:= (cons operation, pointer). As such - can create non-terminating data type (and computation), in other words - infinite.

*** <<<Proxy type>>> :drill:
:properties:
:ID:       a895477f-99de-4a09-bc9d-dc2c86e0a0af
:end:

Proxy type holds no data, but has a phantom parameter of arbitrary type (or even kind). Able to provide type information, even though has no value of that type (or it can be may too costly to create one).
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- a has kind `Type`
let proxy2 = (ProxyValue :: Proxy List) -- a has kind `Type -> Type`
#+end_src

*** <<<Static typing>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       3100b260-2b5c-40a7-bc27-2dc6e0f8f3c5
:DRILL_LAST_INTERVAL: 89.9157
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:32]
:end:

Typechecking takes place at compile level.

*** <<<Structural type>>> :drill:
:properties:
:ID:       9fbc8692-d766-4b0b-bb07-76cb11b9aea8
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 3
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-06-05 Wed 14:24]
:end:

Mathematical type. They form into structural type system.

**** /*/

<<<Structural>>>

*** <<<Structural type system>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       37dc5166-6ad1-468d-a3c2-d4144ac5bb83
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:46]
:end:

Strict global hierarchy and relationships of types and their properties.
Haskell type system is /*/.
In most languages typing is name-based, not structural.

**** /*/

<<<Structural typing>>>

*** <<<Sum data type>>> :drill:
SCHT: <2020-04-08 Wed>
:properties:
:ID:       debb1f7b-bdbf-4984-8d92-ee34b63dd5dc
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 22:52]
:end:

Algebraic data type formed by logical disjunction (OR '|').

*** <<<Type alias>>> :drill:
SCHT: <2021-01-02 Sat>
:properties:
:ID:       35a84a4d-afa8-44b1-aaf4-8fa258f5220c
:DRILL_LAST_INTERVAL: 316.8159
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:10]
:end:

Create new type constructor, and use all data structure of the base type.

*** <<<Type class>>> :drill:
SCHT: <2020-07-19 Sun>
:properties:
:ID:       41fe6fb3-8069-40d4-ac21-1e2995e652be
:DRILL_LAST_INTERVAL: 233.4928
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:43]
:end:

Type system construct that adds a support of ad hoc polymorphism.

Type class makes a nice way for defining behaviour, properties over many types/objects at once.

**** /*/

<<<Type classes>>>
<<<Typeclass>>>
<<<Typeclasses>>>

**** <<<Arbitrary type class>>> :drill:
SCHT: <2020-10-11 Sun>
:properties:
:ID:       1bda8aab-a08c-4d7b-bd08-0b1a6f559a33
:DRILL_LAST_INTERVAL: 270.5287
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:57]
:end:

Type class of QuickCheck.Arbitrary (that is reexported by QuickCheck) for creating a generator/distribution of values.
Useful function is arbitrary - that autogenerates values.

***** <<<Arbitrary function>>> :drill:
:properties:
:ID:       31fe10b3-340e-489a-ab65-a4532a005d0a
:end:

Depends on type and generates values of that type.

**** <<<CoArbitrary type class>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       a8ad8f53-2ad9-414d-8c6b-8df9d0cac80e
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:25]
:end:

Pseudogenerates a function basing on resulting type.
#+begin_src haskell
coarbitrary :: CoArbitrary a => a -> Gen b -> Gen b
#+end_src

***** /*/

<<<CoArbitrary>>>

**** <<<Typeable type class>>> :drill:
:properties:
:ID:       7408b1c4-78e9-4901-abbc-c8cead60031f
:end:

Allows dynamic type checking in Haskell for a type.
Shift a typechecking of type from compile time to runtime.
/*/ type gets wrapped in the universal type, that shifts the type checks to runtime.

Also allows:
  * Get the type of something at runtime (ex. print the type of something =typeOf=).
  * Compare the types.
  * Reifying functions from polymorphic type to conrete (for functions like =:: Typeable a => a -> String=).

***** /*/

<<<Typeable>>>

**** <<<Type class inheritance>>> :drill:
:properties:
:ID:       d41bdd5c-5a64-4ab8-8201-8c9ae3437a61
:end:

Type class has a superclass.

**** <<<Derived instance>>> :drill:
SCHT: <2020-07-22 Wed>
:properties:
:ID:       7294eaf7-4ff8-41c8-a6a9-c9060b5edfb9
:DRILL_LAST_INTERVAL: 234.5372
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:17]
:end:

Type class instances sometimes can be automatically derived from the parent types.

Type classes such as Eq, Enum, Ord, Show can have instances generated based on definition of data type.

P.S.

Language options:
  * DeriveAnyClass
  * DeriveDataTypeable
  * DeriveFoldable
  * DeriveFunctor
  * DeriveGeneric
  * DeriveLift
  * DeriveTraversable
  * DerivingStrategies
  * DerivingVia
  * GeneralisedNewtypeDeriving
  * StandaloneDeriving

***** /*/

<<<Derived>>>
<<<Deriving>>>

*** <<<Type constant>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       06ae5a19-fd5f-485c-b7da-c3027c76d523
:DRILL_LAST_INTERVAL: 24.0645
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 13
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.308
:DRILL_EASE: 2.48
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:47]
:end:

Nullary type constructor.

*** <<<Type constructor>>> :drill:
:properties:
:ID:       9b49b7ac-d596-45c5-a551-cf2f9b3d6cb3
:end:

Name of the data type.

Constructor that takes type as an argument and produces new type.


*** <<<type declaration>>> :drill:
SCHT: <2020-09-12 Sat>
:properties:
:ID:       9ab3591b-b3b1-464c-856b-0e3ed4834b33
:DRILL_LAST_INTERVAL: 241.6625
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:59]
:end:

Synonim for existing type. Uses the same data constructor.
#+begin_src haskell
type FirstName = String
#+end_src
Used to distinct one entities from other entities, while they have the same type.
Also main type functions can operate on a new type.

*** <<<Typed hole>>> :drill:
SCHT: <2020-08-07 Fri>
:properties:
:ID:       54480f81-42f0-4545-bfa6-93e56eba36ae
:DRILL_LAST_INTERVAL: 225.56
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:36]
:end:

/*/ - is a =_= or =_name= in the expression. On evaluation GHC would show the derived type information which should be in place of the /*/. That information helps to fill in the gap.

**** /*/

<<<Typed holes>>>

*** <<<Type inference>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       6e24ecce-be5d-4fcc-b167-649f710d1be8
:DRILL_LAST_INTERVAL: 90.2063
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:34]
:end:

Automatic data type detection for expression.

**** /*/

<<<Inferring>>>
<<<Infer>>>
<<<Infers>>>
<<<Inferred>>>

*** <<<Type class instance>>> :drill:
SCHT: <2020-03-27 Fri>
:properties:
:ID:       2408c5a2-39ba-4732-a4b2-347e87c268d6
:DRILL_LAST_INTERVAL: 123.9772
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.6
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:35]
:end:

Block of implementations of functions, based on unique type class->type pairing.

*** <<<Type rank>>> :drill:
:properties:
:ID:       512cf517-eacf-4d39-9d7c-8ec840d9a384
:end:

Weak ordering of types.

The rank of polymorphic type shows at what level of nesting =forall= quantifier appears.
Count-in only quantifiers that appear to the left of arrows.
#+begin_src haskell
f1 :: forall a b. a -> b -> a    ==    fi :: a -> b -> c
g1 :: forall a b. (Ord a, Eq b) => a -> b -> a    ==    g1 :: (Ord a, Eq b) => a -> b -> a
#+end_src
f1, g1 - rank-1 types. Haskell itself implicitly adds universal quantification.

#+begin_src haskell
f2 :: (forall a. a->a) -> Int -> Int
g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int
#+end_src
f2, g2 - rank-2 types. Quantificator is on the left side of a \to. Quantificator shows that type on the left can be overloaded.

Type inference in Rank-2 is possible, but not higher.

#+begin_src haskell
f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool
#+end_src
f3 - rannk3-type. Has rank-2 types on the left of a \to.

#+begin_src haskell
f :: Int -> (forall a. a -> a)
g :: Int -> Ord a => a -> a
#+end_src
f, g are rank 1. Quantifier appears to the right of an arrow, not to the left. These types are not Haskell-98. They are supported in RankNTypes.


**** /*/

<<<Type ranks>>>
<<<Rank type>>>
<<<Rank types>>>
<<<Rank-1 type>>>
<<<Rank-1 types>>>
<<<Rank-2 type>>>
<<<Rank-2 types>>>
<<<Rank-3 type>>>
<<<Rank-3 types>>>

*** <<<Type variable>>> :drill:
:properties:
:ID:       6f31712e-d46b-4474-bd68-6b3bc2c90309
:end:

Refer to an unspecified type in Haskell type signature.

*** <<<Unlifted type>>> :drill:
SCHT: <2020-07-27 Mon>
:properties:
:ID:       071c758f-9a93-4769-a7f0-aaa02652e57f
:DRILL_LAST_INTERVAL: 195.1208
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.714
:DRILL_EASE: 2.38
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:59]
:end:

Type that directly exist on the hardware. The type abstraction can be completely removed.
With unlifted types Haskel type system directly manages data in the hardware.

**** /*/

<<<Unlifted types>>>

*** <<<Linear type>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       eda588af-3ef5-43a8-8f06-6a6f2f556036
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Type system and algebra that also track the multiplicity of data.
There are 3 general linear type groups:
 * 0 - exists only at type level and is not allowed to be used at value level. Aka =s= in ST-Trick.
 * 1 - data that is not duplicated
 * 1< - all other data, that can be duplicated multiple times.

**** /*/

<<<Linear types>>>

*** <<<NonEmpty list data type>>> :drill:
:properties:
:ID:       809c682b-457e-47df-bdfd-92302d3c42da
:end:

Data.List.NonEmpty
Has a Semigroup instance but can't have a Monoid instance. It never can be an empty list.

#+begin_src haskell
data NonEmpty a = a :| [a]
  deriving (Eq, Ord, Show)
#+end_src

:| - an infix data costructor that takes two (type) arguments. In other words :| returns a product type of left and right

*** <<<Session type>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       4554aa14-760c-41f0-a9fc-69cc3f7fa66a
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.75
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:46]
:end:

/*/ - allows to check that behaviour conforms to the protocol.

So far very complex, not very productive (or well-established) topic.

*** <<<Binary tree>>> :drill:
SCHT: <2020-02-27 Thu>
:properties:
:ID:       8efc93b6-3518-40e7-9143-eb695b267bd4
:DRILL_LAST_INTERVAL: 89.8047
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:43]
:end:

#+begin_src haskell
data BinaryTree a
  = [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
#+end_src

*** <<<Bottom value>>> :drill:
SCHT: <2020-03-27 Fri>
:properties:
:ID:       6a1419f1-74f8-4cab-9f50-6dd93c2b47bd
:DRILL_LAST_INTERVAL: 161.39
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 02:34]
:end:

A =_= non-value in the type or pattern match expression. Placeholder for enything.

#+begin_src haskell
-- _ fits *.
#+end_src

**** /*/

<<<Bottom>>>
<<<Bottom values>>>

*** <<<Bound>>> :drill:
SCHT: <2020-03-31 Tue>
:properties:
:ID:       31ef00a3-6d1e-4ee4-a0da-eac26238aace
:DRILL_LAST_INTERVAL: 165.4538
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 02:42]
:end:

Haskell /*/ type class means to have lowest value & highest value, so a bounded range of values.

**** /*/

<<<Bounded>>>

*** <<<Constructor>>> :drill:
SCHT: <2020-10-08 Thu>
:properties:
:ID:       73f88452-54ff-4192-83fc-0681f0407e9a
:DRILL_LAST_INTERVAL: 268.496
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

1. Type constructor
2. Data constructor

Also see: Constant

**** /*/

<<<Constructors>>>

*** <<<Context>>> :drill:
SCHT: <2020-08-07 Fri>
:properties:
:ID:       c7212fc4-2c44-4cc0-b57a-76e9ba194ac3
:DRILL_LAST_INTERVAL: 225.5602
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:38]
:end:

Type constraints for polymorphic variables.
Written before the main type signature, denoted:
#+begin_src haskell
TypeClass a => ...
#+end_src

**** /*/

<<<Contexts>>>

*** <<<Inhabit>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       3d5a5fec-312b-47a2-bcb7-8d87f6a2baf3
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:27]
:end:

Values that is a component of data type set.

*** <<<Maybe>>> :drill:
:PROPERTIES:
:ID:       0ea257ed-8b3e-49a3-9aae-400156d62955
:END:

#+begin_src haskell
data Maybe
  = Nothing
  | Just a
#+end_src

Does not represent the information why =Nothing= happened.
For error - use Either.
Do not propagate /*/.

Handle /*/ locally to where it is produced. =Nothing= does not hold useful info for debugging & short-circuits the processes. Do not expect code type being bug-free, do not return =Maybe= to end user since it would be impossible to debug, return something that preserves error information.

***** /*/

<<<Nodes>>>

*** <<<Expected type>>> :drill:
SCHT: <2020-08-11 Tue>
:properties:
:ID:       925824e3-ed7f-4e2f-ab3a-dd4700b0291c
:DRILL_LAST_INTERVAL: 209.7683
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:55]
:end:

Data type inferred from the text of the code.

*** <<<ADT>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       9fdd9acf-b98d-469d-b34f-c4c007177135
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:48]
:end:

1. Abstract data type
2. Algebraic data type

*** <<<Concrete type>>> :drill:
SCHT: <2020-07-22 Wed>
:properties:
:ID:       736674fb-45a3-4539-8774-7ccf419b5487
:DRILL_LAST_INTERVAL: 210.3048
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

Fully resolved, definitive, non-polymorphic type.

*** <<<Type punning>>> :drill:
:properties:
:ID:       4dd36365-da34-489b-bd72-bf327bcb34b6
:end:

When type constructor and data constructor have the same name.

Theoretically if person knows the rules - /*/ can be solved, because in Haskell type and data declaration have different places of use.

*** <<<Kind>>> :drill:
:properties:
:ID:       56fd7e68-49b4-496f-bc0b-bcdd8ee3fa57
:end:

Kind -> Type -> Data

**** /*/

<<<Kinds>>>

*** <<<IO>>> :drill:
SCHT: <2020-05-20 Wed>
:properties:
:ID:       40e4a54b-c1c7-41fc-ac84-d3f167eb320f
:DRILL_LAST_INTERVAL: 171.6999
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:17]
:end:

Type for values whose evaluations has a posibility to cause side effects or return unpredictable result.
Haskell standard uses monad for constructing and transforming IO actions.
IO action can be evaluated multiple times.

IO data type has unpure imperative actions inside. Haskell is pure Lambda calculus, and unpure IO integrates in the Haskell purely (type system abstracts IO unpurity inside IO data type).

IO sequences effect computation one after another in order of needed computation, or occurence:

#+begin_src haskell
twoBinds :: IO ()
twoBinds =
  putStrLn "First:" >>
  getLine >>=
  \a ->
  putStrLn "Second:" >>
  getLine >>=
  \b ->
  putStrLn ("\nFirst: "
    ++ a ++ ".\nSecond "
    ++ b ++ ".")
main = twoBinds
#+end_src

Sequencing is achieved by compilation of effects performing only while they recieve the sugared-in & passed around the =RealWorld= fake type value, that value in the every computation gets the new "value" and then passed to the next requestes computation. But special thing is about this parameter, this =RealWorld= type value passed, but never looked at. GHC realizes, since value is never used, - it means value and type can be equated to =()= and moreover reduced from the code, and sequencing stays.

** <<<Expression>>> :drill:
:properties:
:ID:       6ff3b474-8f28-4eb9-975a-312d37521cc6
:end:

Finite combination of symbols that is well-formed according to context-free grammar.

Generally meaningless. Meaning gets derived from an /*/ & context (and/or content words) by congruency with knowledge & expirience.

*** /*/

<<<Expressions>>>

*** <<<Closed-form expression>>> :drill:
SCHT: <2020-03-19 Thu>
:properties:
:ID:       4fe26c88-61dc-4a5c-b31e-aa91d5a9afd0
:DRILL_LAST_INTERVAL: 105.6944
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 2.909
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:26]
:end:

/*/ - mathematical expression that can be evaluated in a finite number of operations.

May contain:
  * constants
  * variables
  * operations (e.g., + − \times \div)
  * functions (e.g., nth root, exponent, logarithm, trigonometric functions, and inverse hyperbolic functions), but usually no limit.

*** <<<RHS>>> :drill:
:properties:
:ID:       8638f0a1-1228-4196-b7f3-0c5db5c13028
:end:

Right-hand side of the expression.

*** <<<LHS>>> :drill:
:properties:
:ID:       060e0611-e893-46f5-b133-c020738fdf96
:end:

Left-hand side of the expression.

*** <<<Redex>>> :drill:
SCHT: <2020-07-11 Sat>
:properties:
:ID:       3d5326a4-74a7-433d-860a-2590072bb61d
:DRILL_LAST_INTERVAL: 224.5541
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:08]
:end:

Reducible expression.

*** <<<Concatenate>>> :drill:
SCHT: <2020-10-26 Mon>
:properties:
:ID:       fd27911c-bf33-4510-91ff-afa1d4e7d2e1
:DRILL_LAST_INTERVAL: 230.7011
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

Link together sequences, expressions.

*** <<<Alpha equivalence>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       83ea3e34-0c72-4976-abaa-875767736cea
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Equivalence of a processes in expressions. If expressions have according parameters different, but the internal processes are literally the same process.

*** <<<Ground expression>>> :drill:
:properties:
:ID:       5030cc64-34d8-49d8-896d-fa6e4aeea4ac
:end:

Expression that does not contain any free variables.

**** /*/

<<<Ground formula>>>

*** <<<Variable>>> :drill:
:properties:
:ID:       1362e457-cca3-44c3-b5a4-24111d56d71c
:end:

A name for expression.

You probably would hear saying: =Haskell has immutable "variables"= (term used in imperative programming sence). Logically we see statement nonsensical in meaning, "variables" (something that has change as a defining propery) are not changing, aka, nonsence. It is due to programmers tend to speak in terms of imperative programming. Read the saying as: =Haskell has immutable values=. In haskell values (due to value semantics (see "Value")) are immutable, and Haskell expressions are functions (that are referentially transparent - meaning itself immutable) are also values (hense "functional programming" - functions are first-class values), and since values bind to /*/, people are wrongly mix-up terms and say their names (according "/*")/ are immutable (inside scope area immutable value is binded in).

As you see in the code - Haskell variables (same names) hold different value at different time. Variables are reused, meaning "names are reused, binded to different values on scope changes/cycles, can be shadowed, and can have different values inside. But all values that Haskell holds - are, by the design of language, are treated immutable, any transformations Haskell resolves by creating new values, and frees the space by freeing-up from unneeded values.

**** /*/

<<<Variables>>>

*** <<<Phrase>>> :drill:
SCHT: <2020-04-27 Mon>
:properties:
:ID:       a23fe978-1afc-4fc9-8dda-6bb49b9554a3
:DRILL_LAST_INTERVAL: 49.3773
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.455
:DRILL_EASE: 2.38
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

Composable expression.

** <<<Function>>> :drill:
SCHT: <2020-03-10 Tue>
:properties:
:ID:       e86b0dde-ef8f-447e-a966-7553784aab54
:DRILL_LAST_INTERVAL: 31.0268
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:01]
:end:

Full dependency of one quantity from another quantity.

Denotation:
\( y = f(x) \)
\( f: X \to Y \),
where \( X \) is domain, \( Y \) is codomain.

Directionality and property of invariability emerge from one another.
#+begin_src haskell
-- domain func codomain
   *      ->   *
#+end_src

\( y(x) = (zx^{2} + bx + 3 \ | \ b = 5) \)
^ ^    ^^    ^   ^
| |    ||     \\( \textsubscript{Var} \)\\( \textsubscript{Constant} \)
| |    | \\( \textsubscript{Bound variable} \)
| |     \\( \textsubscript{Free variable} \)
|  \\( \textsubscript{Parameter} \)
 \\( \textsubscript{Name of the function} \)

Lambda abstraction is a function.
Function is a mathematical operation.

Function = Total function = Pure function. Function theoretically can be to memoized.

Also see:
Partial function
Inverse function - often partially exists (partial function).

*** /*/

<<<Functions>>>
<<<Bound variable>>>

*** <<<Arity>>> :drill:
SCHT: <2020-08-07 Fri>
:properties:
:ID:       fa4caa07-eea5-4082-aaed-92abb820e768
:DRILL_LAST_INTERVAL: 225.56
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:33]
:end:

Number of parameters of the function.
  * nullary - f()
  * unary   - f(x)
  * binary  - f(x,y)
  * ternary - f(x,y,z)
  * n-ary   - f(x,y,z..)

*** <<<Bijection>>> :drill:
SCHT: <2020-03-19 Thu>
:properties:
:ID:       8366200a-a8ed-4c7b-baec-eb957d9f3d64
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:09]
:end:

Function is a complete one-to-one pairing of elements of domain and codomain (image).
It means function both surjective (so image == codomain) and injective (every domain element has unique correspondence to the image element).

For bijection inverse always exists.

Bijective operation holds the equivalence of domain and codomain.

Denotation:
#+begin_src text
⤖
>->>
f : X ⤖ Y
#+end_src
LaTeX needed to combine symbols:
\( \newcommand*{\twoheadrghtarrowtail}{\mathrel{\rightarrowtail\kern-1.9ex\twoheadrightarrow}} f : X \twoheadrghtarrowtail Y \)

Corersponds to isomorphism.

**** /*/

<<<Bijective>>>
<<<Bijective function>>>

*** <<<Combinator>>> :drill:
:properties:
:ID:       bf7ce908-9d5d-4a00-ab02-e7b33edd2c76
:end:

Function without free variables.
Higher-order function that uses only function application and other combinators.

#+begin_src haskell
\a -> a
\ a b -> a b
\f g x -> f (g x)
\f g x y -> f (g x y)
#+end_src

Not combinators:
#+begin_src haskell
\ xs -> sum xs
#+end_src
Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.

**** <<<\Psi-combinator>>> :drill:
SCHT: <2020-07-27 Mon>
:properties:
:ID:       dd833dc5-91f9-4bec-aa5a-e292dfb387d8
:DRILL_LAST_INTERVAL: 235.4952
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-05 Thu 01:04]
:end:

Transforms two of the same type, applying same mediate transformation, and then transforming those into the result.
#+begin_src haskell
import Data.Function (on)
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
#+end_src

#+begin_src text
--\
   * ---
--/
#+end_src

***** /*/

<<<Psi-combinator>>>
<<<On-combinator>>>

*** <<<Function application>>> :drill:
SCHT: <2020-06-22 Mon>
:properties:
:ID:       630790f7-377f-463e-8058-792502dbcc88
:DRILL_LAST_INTERVAL: 200.3048
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-05 Thu 01:05]
:end:

/*/ - bind the argument to the parameter of a function, and do a beta-reduction.

**** /*/

<<<Apply>>>
<<<Applied>>>
<<<Applying>>>
<<<Application>>>

*** <<<Function body>>> :drill:
:properties:
:ID:       8c0947a8-56ae-49de-b3a8-ab87beab0bd6
:end:

Expression that haracterizes the process.

*** <<<Function composition>>> :drill:
:properties:
:ID:       e609101f-4f65-4f58-b997-2fe44c52c6d9
:end:

#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
#+end_src

In Haskell inline composition requires:
#+begin_src haskell
h.g.f $ i
#+end_src

**** /*/

<<<Composition>>>
<<<Compose>>>
<<<Composed>>>

*** <<<Function head>>> :drill:
SCHT: <2020-08-02 Sun>
:properties:
:ID:       6eb9d501-0dda-4a9e-b3e1-e35fb84d31b8
:DRILL_LAST_INTERVAL: 162.9166
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:15]
:end:

Is a part with name of the function and it's paramenters.
AKA: \( f(x) \)

*** <<<Function range>>> :drill:
:properties:
:ID:       15fbd0e9-f327-4065-872e-23713f79ec12
:end:

The range of a function refers to either the codomain or the image of the function, depending upon usage. Modern usage almost always uses range to mean image.
So, see Function image.

*** <<<Higher-order function>>> :drill:
SCHT: <2020-09-17 Thu>
:properties:
:ID:       61a40480-45d2-4632-9948-986eecd8b7cb
:DRILL_LAST_INTERVAL: 192.3791
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 23:21]
:end:

Function that has arity > 1.

----

HOF is:
  * function that accepts function as a parameter
  * function that has more then one parameter.

Application of an argument to /*/ produces a function that has =arity - 1=.

**** /*/

<<<HOF>>>

**** <<<Fold>>> :drill:
SCHT: <2020-05-18 Mon>
:properties:
:ID:       9513b166-74df-4a9f-b7da-d03f84ca2cfc
:DRILL_LAST_INTERVAL: 166.0782
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:13]
:end:

Catamorphism of a structure to a lower type of structure. Often to a single value.

/*/ is a higher-order function that takes a function which operates with both main structure and accumulator structure, /*/ applies units of data structure to a function wich works with accumulator. Upoun traversing the whole structure - the accumulator is returned.

*** <<<Injection>>> :drill:
:properties:
:ID:       c1f2a44b-8b24-47b8-8e23-304ad4fc536a
:end:

Function one-to-one injects from domain into codomain.

Keeps distinct pairing of elements of domain and image.
Every element in image coresponds to one element in domain.

\( \forall a,b \in X, \; f(a)=f(b) \Rightarrow a=b \)

\( \exists (inverse \ function) \ | \ \forall (injective \ function) \)

Denotion:
#+begin_src text
↣
>->
f : X ↣ Y
#+end_src
$f : X \rightarrowtail Y$

Corresponds to Monomorphism.

**** /*/

<<<Injective>>>
<<<Injective function>>>
<<<Injectivity>>>

*** <<<Partial function>>> :drill:
SCHT: <2020-05-03 Sun>
:properties:
:ID:       d8d7edc3-b943-4afa-8832-ddb2ef2a386d
:DRILL_LAST_INTERVAL: 154.6526
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:14]
:end:

One that does not cover all domain.
Unsafe and causes trouble.

*** <<<Purity>>> :drill:
SCHT: <2020-08-01 Sat>
:properties:
:ID:       5c84fbd6-2c97-464f-9431-965dd8c91aef
:DRILL_LAST_INTERVAL: 217.5392
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-27 Fri 13:08]
:end:

/*/ means properly abstracted.

If the contrary - abstraction is unpure.

Also see: pure function.

**** /*/

<<<Pure>>>

*** <<<Pure function>>>

Function that is pure \( \equiv \) referentially transparent function.

*** <<<Sectioning>>> :drill:
SCHT: <2020-05-31 Sun>
:properties:
:ID:       c8cadab6-16e6-4d0e-9b79-6e3b56dcbd8e
:DRILL_LAST_INTERVAL: 188.7495
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:27]
:end:

Writing function in a parentheses. Allows to pass around partially applied functions.

*** <<<Surjection>>> :drill:
SCHT: <2020-03-07 Sat>
:properties:
:ID:       56270a1d-ef0e-4986-a1ff-04606b37ccb7
:DRILL_LAST_INTERVAL: 104.2695
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.286
:DRILL_EASE: 2.86
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:25]
:end:

Function uses codomain fully.

\( \forall y \in Y, \exists x \in X \)

Denotation:
\( f : X \twoheadrightarrow Y \)

Corresponds to Epimorphism.

**** /*/

<<<Surjective>>>
<<<Surjective function>>>

*** <<<Unsafe function>>> :drill:
SCHT: <2020-03-29 Sun>
:properties:
:ID:       b48b82e3-f86c-4360-a568-727c2500d06c
:DRILL_LAST_INTERVAL: 125.5079
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:30]
:end:

Function that does not cover at least one edge case.

**** /*/

<<<Unsafe>>>

*** <<<Variadic>>> :drill:
SCHT: <2020-07-21 Tue>
:properties:
:ID:       b6592f9f-3718-4f2f-9423-06b590e6b84d
:DRILL_LAST_INTERVAL: 208.7241
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:40]
:end:

/*/ - having variable arity (often up to indefinite).

*** <<<Domain>>> :drill:
:properties:
:ID:       61416c64-6cbf-4af4-9428-ad6f79e76701
:end:

Source set of a function.
\( X \) in \( X \to Y \).

*** <<<Codomain>>> :drill:
SCHT: <2020-07-07 Tue>
:properties:
:ID:       f8603032-30f1-4074-80b5-0f6f49428241
:DRILL_LAST_INTERVAL: 224.8335
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:16]
:end:

\( Y \) in $X \to Y$.
Codomain - target set of a function.

*** <<<Open formula>>> :drill:
SCHT: <2020-03-06 Fri>
:properties:
:ID:       dc5f353b-84dc-4bce-85e2-eaa56f18401f
:DRILL_LAST_INTERVAL: 27.3014
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.889
:DRILL_EASE: 2.72
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:00]
:end:

Logical function that has arity and produces proposition.

*** <<<Recursion>>> :drill:
SCHT: <2020-03-01 Sun>
:properties:
:ID:       2e2d87ae-d918-47fc-b810-f95366fe4039
:DRILL_LAST_INTERVAL: 63.6233
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-28 Sat 17:27]
:end:

Repeated function application when sometimes same function gets called.

Allows computation that may require indefinite amount of work.

**** /*/

<<<Recursive>>>

**** <<<Base case>>> :drill:
SCHT: <2020-06-21 Sun>
:properties:
:ID:       be130896-9bec-4276-9a7b-41cfb9f3b6dd
:DRILL_LAST_INTERVAL: 210.1351
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:33]
:end:

A part of a recursive function that trivially produces result.

**** <<<Tail recursion>>> :drill:
:properties:
:ID:       62dd2851-710e-4035-9890-6af1c17e6305
:end:

Tail calls are recursive invocantions of itself.

**** <<<Polymorphic recursion>>> :drill:
:properties:
:ID:       11fd02fd-e0b7-4e41-aad9-6881c980207d
:end:

Type of the parameter changes in recursive invocations of function.

Is always a higher-ranked type.

***** /*/

<<<Milner–Mycroft typability>>>
<<<Milner–Mycroft calculus>>>

*** <<<Free variable>>> :drill:
SCHT: <2020-07-28 Tue>
:properties:
:ID:       e6e68077-da2a-41d1-aed4-c033f7a97abe
:DRILL_LAST_INTERVAL: 241.6651
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:41]
:end:

Variable in the fuction that is not bound by the head.
Until there are /* -/ function stays partially applied.

*** <<<Closure>>> :drill:
SCHT: <2020-05-23 Sat>
:properties:
:ID:       c20b75e8-cd85-4f41-84c2-660ffdb963dd
:DRILL_LAST_INTERVAL: 181.4899
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:24]
:end:

\( f(x) = f^{\mathcal{X \to X}} \ | \ \forall x \in \mathcal{X} \), \( \mathcal{X} \) is closed under \( f \), it is a trivial case when operation is legitimate for all values of the domain.

Operation on members of the domain always produces a members of the domain. The domain is closed under the operation.

In the case when there is a domain values for which operation is not legitimate/not exists:

\( f(x) = f^{\mathcal{V \to X}} \ | \ \mathcal{V \in X}, \forall x \in \mathcal{V} \), \( \mathcal{X} \) is closed under \( f \).

**** /*/

<<<Closed>>>

*** <<<Parameter>>> :drill:
SCHT: <2020-06-28 Sun>
:properties:
:ID:       737527a3-4fcf-4499-9d27-6fab664d9da0
:DRILL_LAST_INTERVAL: 185.8455
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:26]
:end:

παρά /para/ subsidiary
μέτρον /metron/ measure

Named varible of a function.

Argument is a supplied value to a function parameter.

Parameter (formal parameter) is an irrefutable pattern, and implemeted that way in Haskell.

**** /*/

<<<Parameters>>>
<<<Formal parameter>>>
<<<Formal parameters>>>

*** <<<Partial application>>> :drill:
:properties:
:ID:       3ec44a13-f6e9-4ba4-b0af-1c12b8017775
:end:

Part of function parameters applied.

**** /*/

<<<Partially applied>>>

*** <<<Well-formed formula>>> :drill:
:properties:
:ID:       714fb9d5-19c8-44ba-9927-eccce436a1f3
:end:

Expression, logical function that is/can produce a proposition.

**** /*/
<<<Well formed formula>>>
<<<WFF>>>
<<<wff>>>
<<<WFFS>>>
<<<wffs>>>

** <<<Homotopy>>> :drill:
:properties:
:ID:       4b3fc811-290c-4462-aaa6-208134e9e591
:end:

ὁμός homós same

One can be "continuously deformed" into the other.

For example - functions, functors.
Natural transformation is a homotopy of functors.

*** /*/

<<<Homotopies>>>
<<<Homotopic>>>

** <<<Lambda calculus>>> :drill:
:properties:
:ID:       f484ba96-5cb1-45d2-9265-25130f62361c
:end:

Universal model of computation. Which means /*/ can implement any Turing machine.
Based on function abstraction and application by substituting variables and binding values.

/*/ has lambda terms:
   * variable (\( x \))
   * application (\( (ts) \))
   * abstraction (lambda function) (\( (\lambda x . t) \))

*** /*/

<<<Lambda term>>>
<<<Lambda terms>>>
<<<Lambda variable>>>
<<<Lambda variables>>>

*** <<<Lambda cube>>> :drill:
SCHT: <2020-04-03 Fri>
:properties:
:ID:       9ecad208-0bba-4d09-8906-5f5f76777182
:DRILL_LAST_INTERVAL: 25.2329
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 2.9
:DRILL_EASE: 1.8
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:55]
:end:

λ-cube shows the 3 dimentions of generalizations from simply typed Lambda calculus to Calculus of constructions.

---

#+captions: \lambda-cube: degrees of generalizaitions of the type systems
#+name: diag--lambda-cube-axis
\begin{tikzcd}
{Polymorphic \ types} \\
& {Type \ opertations} \\
0 \arrow[uu] \arrow[ur] \arrow[rr] & & {Dependent \ types} \\
\end{tikzcd}

#+captions: The \lambda-cube. The generalization of type systems: from \lambda-Calculus to Calculus of Constructions
#+name: diag--lambda-cube
\begin{tikzcd}[row sep=scriptsize,column sep=scriptsize]
& \lambda \omega \arrow[rr] \arrow[from=dd] & & \lambda C \\
\lambda 2 \arrow[ur] \arrow[rr, crossing over] & & \lambda P 2 \arrow[ur] \\
& \lambda \underline{\omega} \arrow[rr] & & \lambda P \underline{\omega} \arrow[uu] \\
\lambda \arrow[rr] \arrow[uu] \arrow[ur] & & \lambda P \arrow[uu, crossing over] \arrow[ur] \\
\end{tikzcd}

Each dimension of the cube corresponds to extensions (a new type of relation of objects depending on objects):

#+captions: Three degrees of type systems generalizations
#+name: tab--lambda-calculus-generalizations
| Denotation | Name              | Programming                               | New type of relations    |
|------------+-------------------+-------------------------------------------+--------------------------|
| 2          | Polymorphic types | First-class polymorphism of types         | Terms depending on types |
| \omega          | Type operation    | Type class, type families                 | Types depending on types |
| P          | Dependent types   | Higher-rank polymorphism, dependent types | Types depending on terms |

#+captions: \lambda-cube: Names of the type systems
#+name: tab--lambda-calculus-names
| Denotation             | Logical system                             |
|------------------------+--------------------------------------------|
| \( \lambda\to \)               | (First Order) Propositional Calculus       |
| \( \lambda2 \)               | Second Order Propositional Caculus         |
| \( \lambda\omega \)               | Weakly Higher Order Propositional Calculus |
| \( \lambda \underline{\omega} \)  | Higher Order Propositional Calculus        |
| \( \lambda P \)              | (First Order) Predicate Logic              |
| \( \lambda P 2 \)            | Second Order Predicate Calculus            |
| \( \lambda P \undeline{\omega} \) | Weak Higher Order Predicate Calculus       |
| \( \lambda C \)              | Calculus of Constructions                  |

**** /*/

<<<λ-cube>>>
<<<\lambda-cube>>>

*** <<<Lambda function>>> :drill:
:properties:
:ID:       857ef4b3-f3e6-4065-aac4-fd3607ed5284
:end:

Function of Lambda calculus.
\( \lambda x y.x^2 + y^3 \)
 ^^ ^    ^
 || |     \__variable
 ||  \__variable
 || (_____)
 ||     \___BODY
 ||
 | \__parameter
  \___parameter
(___)
   \____HEAD

**** /*/

<<<Lambda abstraction>>>

**** <<<Anonymous lambda function>>> :drill:
:properties:
:ID:       c3a9e8dd-b5e9-44ff-88c5-e83d00330964
:end:

Lambda function that is not binded to any name.

***** /*/

<<<Anonymous lambda function>>>

**** <<<Uncurry>>> :drill:
:properties:
:ID:       c24534d9-0a6b-4e76-9925-bc25496bbfdd
:end:

Replace sequenced lambda functions into single function taking sequence/product of values as argument.

*** <<<\beta-reduction>>> :drill:
SCHT: <2020-05-21 Thu>
:properties:
:ID:       09ff04bc-e52b-47e9-9a9e-a23bd437fb75
:DRILL_LAST_INTERVAL: 169.2439
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:15]
:end:

Equation of a parameter to a bound variable, then reducing parameter from the head.

**** /*/

<<<\beta reduction>>>
<<<Beta-reduction>>>
<<<Beta reduction>>>

**** <<<\beta-normal form>>> :drill:
SCHT: <2020-05-10 Sun>
:properties:
:ID:       56b65c7e-f063-4614-b2c7-916ff446ab80
:DRILL_LAST_INTERVAL: 163.321
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:08]
:end:

No beta reduction is possible.

***** /*/

<<<\beta normal from>>>
<<<Beta normal form>>>
<<<Beta-normal form>>>

*** <<<Calculus of constructions>>> :drill:
SCHT: <2020-05-09 Sat>
:properties:
:ID:       6c93585b-5ba5-4a38-ae39-2f7dc718390b
:DRILL_LAST_INTERVAL: 60.7183
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:10]
:end:

Extends the Curry–Howard correspondence to the proofs in the full intuitionistic predicate calculus (includes proofs of quantified statements).
Type theory, typed programming language, and constructivism (phylosophy) foundation for mathematics.
Directly relates to Coq programming language.

**** /*/

<<<<<<CoC>>>>>>

*** <<<Curry–Howard correspondence>>> :drill:
SCHT: <2020-08-08 Sat>
:properties:
:ID:       8b3e318d-242b-41ad-a16c-20d950177f5d
:DRILL_LAST_INTERVAL: 169.2382
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:15]
:end:

Equivalence of {First-order logic, computer programming, Category theory}. They represent each-other, possible in one - possible in the other, so all the definitions and theorems have analogues in other two.

Gives a ground to the equivalence of computer programs and mathematical proofs.

Lambek added analogue to Cartesian closed category, which can be used to model logic and type theory.

#+caption: Table of basic correspondence
#+name: tab--table-of-basic-correspondence
| Logic | Type                    | Category  |
|-------+-------------------------+-----------|
| True  | () (any inhabited type) | Terminal  |
| False | Void                    | Initial   |
| a \land b | (a, b)                  | a \times b     |
| a \lor b | Either a b              | a /     b |
| a \Rightarrow b | a \to b                   | b^{a}        |

**** /*/

<<<Curry–Howard isomorphism>>>
<<<Curry-Howard-Lambek>>>

*** <<<Currying>>> :drill:
SCHT: <2020-03-12 Thu>
:properties:
:ID:       4f8d7c52-f114-40ad-869e-e1ab4fdafc37
:DRILL_LAST_INTERVAL: 33.0946
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.286
:DRILL_EASE: 2.86
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:01]
:end:

Translating the evaluation of a multiple argument function (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument.

**** /*/

<<<Curry>>>

*** <<<Hindley–Milner type system>>> :drill:
SCHT: <2020-06-24 Wed>
:properties:
:ID:       67b414eb-6659-455f-bbb5-cb507c643567
:DRILL_LAST_INTERVAL: 152.4691
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 1.94
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-23 Thu 23:06]
:end:

Classical type system for the Lambda calculus with Parametric polymorphism and Type inference. Types marked as polymorphic variables, which enables type inference over the code.

**** /*/

<<<Hindley-Milner>>>
<<<Damas-Milner>>>
<<<Damas–Hindley–Milner>>>

*** <<<Reduction>>> :drill:
SCHT: <2020-07-22 Wed>
:properties:
:ID:       11776f99-f2e5-46fd-a566-8e08060fd7f0
:DRILL_LAST_INTERVAL: 153.0287
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:31]
:end:

Take out something from a structure, make simplier.

See Beta reduction

**** /*/

<<<Reducible>>>

*** <<<\beta-\eta normal form>>> :drill:
SCHT: <2020-05-26 Tue>
:properties:
:ID:       0240a6dc-9667-4558-b138-3423930eafe6
:DRILL_LAST_INTERVAL: 242.2089
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.25
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-09-27 Fri 20:06]
:end:

All \beta-reduction and \eta-abstraction are done in the expression.

**** /*/

<<<beta-eta normal form>>>
<<<beta eta normal form>>>

*** <<<\eta-abstraction>>> :drill:
SCHT: <2020-06-23 Tue>
:properties:
:ID:       c385db49-d92d-4b80-85b9-ecd8b786671e
:DRILL_LAST_INTERVAL: 180.6805
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:38]
:end:

\( (\lambda x.Mx) \xleftarrow[\eta]{} M \)

#+begin_src haskell
\ x -> g . f $ x
\ x -> g . f     --eta-abstraction
#+end_src

**** /*/

<<<\eta-reduction>>>
<<<\eta-conversion>>>
<<<\eta abstraction>>>
<<<\eta reduction>>>
<<<\eta conversion>>>
<<<eta-abstraction>>>
<<<eta-reduction>>>
<<<eta-conversion>>>
<<<eta abstraction>>>
<<<eta reduction>>>
<<<eta conversion>>>

*** <<<Lambda expression>>>
See Lambda calculus (Lambda terms) and Expression. In majority cases meaning some Lambda function.

** <<<Operation>>> :drill:
SCHT: <2020-06-07 Sun>
:properties:
:ID:       10f782ae-17e5-434e-8d2e-ee8ee3f9b530
:DRILL_LAST_INTERVAL: 195.0324
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:18]
:end:

Calculation into output value. Can have zero & more inputs.

*** <<<Constant>>> :drill:
:properties:
:ID:       15c1200e-1ba8-47b1-816a-c88be1134edf
:end:

Nullary operation.

Also see: Type constant.

*** <<<Binary operation>>> :drill:
SCHT: <2020-05-25 Mon>
:properties:
:ID:       f7cf1edb-834b-4505-874b-c7e8acc6d547
:DRILL_LAST_INTERVAL: 241.1306
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-09-27 Fri 19:57]
:end:

\( \forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S \)

**** /*/

<<<Binary operations>>>

*** <<<Operator>>> :drill:
SCHT: <2020-10-10 Sat>
:properties:
:ID:       ad158f22-64c6-44c6-b140-4fc5c2b065f7
:DRILL_LAST_INTERVAL: 269.6572
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

Denotation symbol/name for the operation.

**** <<<Shift operator>>> :drill:
:properties:
:ID:       48503777-55e0-4c6e-8675-f220bb2c11c8
:end:

Shift operator defined by Lagrange through Differential operator.
\( T^{t} \, = \, e^{t{\frac{d}{dx}}} \)

***** /*/

Shift

**** <<<Differential operator>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       1ffad9d0-5207-422f-b979-8118bbcba152
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

Denotation.
\( \frac{d}{dx}, \, D, \, D_{x}, \, \partial_{x}. \)
Last one is partial.

\( e^{t{\frac{d}{dx}}} \) - Shift operator.

***** /*/

<<<Differential>>>

*** <<<Infix>>> :drill:
SCHT: <2020-08-06 Thu>
:properties:
:ID:       6de70cc8-f8a0-461f-ae1a-0a8ead07799b
:DRILL_LAST_INTERVAL: 249.5633
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:14]
:end:

Form of writing of operator or function in-between variables for application.

For priorities see Fixity.

*** <<<Fixity>>> :drill:
SCHT: <2020-03-14 Sat>
:properties:
:ID:       b8e36421-2fbb-4c67-881d-e40e105f73c1
:DRILL_LAST_INTERVAL: 22.7088
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.667
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:22]
:end:

Declares the presedence of action of a function/operator.

Funciton application has presedence higher then all infix operators/functions (virtually giving it a priority 10).

#+caption: Haskell operators priority and fixity association
#+name: tab--haskell-operator-priority-fixity-association
|  P | L        | Non                 | R          |
|----+----------+---------------------+------------|
| 10 |          |                     | F.A.       |
|  9 | !!       |                     | .          |
|  8 |          |                     | ^ ^^ **    |
|  7 | */ div   |                     |            |
|  6 | +-       |                     |            |
|  5 |          |                     | : , ++     |
|  4 |          | <comparison> elem   |            |
|  3 |          |                     | &&         |
|  2 |          |                     | OR         |
|  1 |          |                     |            |
|  0 |          |                     | $ $! seq   |

**** /*/

<<<Infixl>>>
<<<Infixr>>>
<<<Priority>>>
<<<Precedence>>>

*** <<<Zero>>> :drill:
SCHT: <2020-07-18 Sat>
:properties:
:ID:       403807c4-a2de-47ca-bdee-96b8b47994c2
:DRILL_LAST_INTERVAL: 232.4135
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:08]
:end:

/*/ is the value with which operation always yelds Zero value.
\( zero, n \in C : \forall n, zero*n=zero \)

/*/ is distinct from Identity value.

*** <<<Bind>>> :drill:
SCHT: <2020-03-05 Thu>
:properties:
:ID:       2e4ac590-3b8a-4c70-9229-a83d30f6b149
:DRILL_LAST_INTERVAL: 143.9066
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-13 Sun 02:01]
:end:

Establishing equality between two objects.

Most often:
  * equating variable to a value.
  * equating parameter of a function to an argument (variable/value/function). This term often is equated to applying argument to a function, which includes \beta-reduction.

**** /*/

<<<Binds>>>
<<<Binding>>>
<<<Bindings>>>

*** <<<Declaration>>> :drill:
SCHT: <2020-04-29 Wed>
:properties:
:ID:       461111ea-4124-427f-bfc6-f83212a07951
:DRILL_LAST_INTERVAL: 168.22
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-13 Wed 19:09]
:end:

Binding name to expression.

*** <<<Dispatch>>> :drill:
SCHT: <2020-05-11 Mon>
:properties:
:ID:       aba69f2c-bd70-46eb-9cd3-a215fdd37737
:DRILL_LAST_INTERVAL: 62.8408
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:10]
:end:

Sort-out & send.

*** <<<Evaluation>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       1b2053a3-24c8-47fe-a3a0-3974c6a3472a
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:55]
:end:

For FP see Bind.

** <<<Permutation>>> :drill:
SCHT: <2020-07-09 Thu>
:properties:
:ID:       af01cb45-6b61-4b9f-bac6-390a2ec82a5c
:DRILL_LAST_INTERVAL: 121.6109
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.168
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

Bijective function from domain to itself.

Domain & permutation functions & function composition form a group.

** <<<Point-free>>> :drill:
SCHT: <2020-05-25 Mon>
:properties:
:ID:       4a6fc5de-f277-4bb9-afd0-6dcb3698b317
:DRILL_LAST_INTERVAL: 181.5072
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.143
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:20]
:end:

Paradigm where function only describes the morphism itself.

Process of converting function to point-free.
If brackets /()/ can be changed to /$/ then $ equal to composition:
#+begin_src haskell
\ x -> g (f x)
\ x -> g $ f x
\ x -> g . f $ x
\ x -> g . f     --eta-abstraction

\ x1 x2 -> g (f x1 x2)
\ x1 x2 -> g $ f x1 x2
\ x1 x2 -> g . f x1 $ x2
\ x1    -> g . f x1
#+end_src

*** /*/

<<<Pointfree>>>
<<<Tacit>>>
<<<Tacit programming>>>

*** <<<Blackbird>>> :drill:
SCHT: <2020-12-22 Tue>
:properties:
:ID:       76123e3b-3042-4112-beaf-7f281c13e58a
:DRILL_LAST_INTERVAL: 306.1258
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.715
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:12]
:end:

#+begin_src haskell
(.).(.) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
#+end_src

Composition of compositions =(.).(.)=. Allows to compose-in a binary function =f1(c) (.).(.) f2(a,b)=.
#+begin_src haskell
\ f g x y -> f (g x y)
#+end_src

**** /*/

<<<.) .>>>
<<<(.).(.)>>>
<<<Composition of compositions>>>

*** <<<Swing>>> :drill:
SCHT: <2020-04-29 Wed>
:properties:
:ID:       1d5d1b4c-2390-4ebd-b79c-23ed3deec10e
:DRILL_LAST_INTERVAL: 151.1065
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:15]
:end:

#+begin_src haskell
swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
swing = flip . (. flip id)
swing f = flip (f . runCont . return)
swing f c a = f ($ a) c
#+end_src

*** <<<Squish>>> :drill:
:properties:
:ID:       4813e27d-4ac4-415f-95c5-323b605c1de6
:end:

#+begin_src haskell
f >>= a . b . c =<< g
#+end_src

** <<<Polymorphism>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       83a22f3c-9140-490c-9390-85319566a443
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

πολύς /polús/ many

At once several forms.

In Haskell - abstract over data types.

/*/ types:

*** /*/

<<<Polymorphic>>>

*** <<<Levity polymorphism>>> :drill:
SCHT: <2020-04-01 Wed>
:properties:
:ID:       cba719c7-40cf-4fbe-841f-b52909f552b7
:DRILL_LAST_INTERVAL: 22.7451
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:07]
:end:

Extending polymorphism to work with unlifted and lifted types.

*** <<<Parametric polymorphism>>> :drill:
:properties:
:ID:       0f4d5c48-f692-4a1f-8368-b0dab65f6d2f
:end:

Abstracting over data types by parameter.

/In most languages named as 'Generics' (generic programming)./

Types:

**** <<<Rank-1 polymorphism>>> :drill:
SCHT: <2020-04-12 Sun>
:properties:
:ID:       5fc7f989-ce41-4150-8301-3328b30fd206
:DRILL_LAST_INTERVAL: 34.4677
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.142
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:56]
:end:

Parametric polymorphism in rank-1 types by type variables.

***** /*/

<<<Prenex>>>
<<<Prenex polymorpism>>>

**** <<<Let-bound polymorphism>>> :drill:
SCHT: <2020-03-31 Tue>
:properties:
:ID:       f415a2f4-8f66-483d-9b75-70b3e5fe4b89
:DRILL_LAST_INTERVAL: 21.9723
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:08]
:end:

It is property chosen for Haskell type system.
Haskell is based on Hindley-Milner type system, it is let-bound.
To have strict type inference with /*/ - if =let= and =where= declarations are polymorphic - $\lambda$ declarations - should be not.

See: Good: In Haskell parameters bound by lambda declaration instantiate to only one concrete type.

**** <<<Constrained polymorphism>>> :drill:
:properties:
:ID:       ad855e03-3fc1-4875-b28c-82b85987eccb
:end:

Constrained Parametric polymorphism.

***** <<<Ad hoc polymorphism>>> :drill:
SCHT: <2020-05-18 Mon>
:properties:
:ID:       d98c11bf-35fd-46ae-803f-28df28c37a54
:DRILL_LAST_INTERVAL: 166.3114
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:19]
:end:

Artificial constrained polymorphism dependent on incoming data type.
It is interface dispatch mechanism of data types.
Achieved by creating a type class instance functions.

/Commonly known as overloading./

******* /*/

<<<Ad-hoc polymorphism>>>
<<<Ad hoc polymorphic>>>
<<<Ad-hoc polymorphic>>>
<<<Constraint>>>
<<<Constraints>>>

**** <<<Impredicative polymorphism>>> :drill:
SCHT: <2020-03-20 Fri>
:properties:
:ID:       4d1d48af-a46a-4632-88f2-fff7643f0d7e
:DRILL_LAST_INTERVAL: 107.3526
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:26]
:end:

/*/ allows type τ entities with polymorphic types that can contain type τ itself.
\( T = \forall X. X \to X : \; T \in X \vDash T \in T \)

The most powerful form of parametric polymorphism.
See: Impredicative.

This approach has Girard's paradox (type systems Russell's paradox).

***** /*/

<<<First-class polymorphism>>>

**** <<<Higher-rank polymorphism>>> :drill:
:properties:
:ID:       80de6f6a-d231-4296-9f73-4caa384e65b9
:end:

Means that polymorphic types can apper within other types (types of function).
There is a cases where higher-rank polymorphism than the a Ad hoc - is needed. For example where ad hoc polymorphism is used in constraints of several different implementations of functions, and you want to build a function on top - and use the abstract interface over these functions.
#+begin_src haskell
-- ad-hoc polymorphism
f1 :: forall a. MyType Class a => a -> String    ==    f1 :: MyType Class a => a  -> String
f1 = -- ...

-- higher-rank polymorphism
f2 :: Int -> (forall a. MyType Class a => a -> String) -> Int
f2 = -- ...
#+end_src
By moving =forall= inside the function - we can achive higher-rank polymorphism.

From: https://news.ycombinator.com/item?id=8130861
#+begin_src text
Higher-rank polymorphism is formalized using System F, and there are a few implementations of (incomplete, but decidable) type inference for it - see e.g. Daan Leijen's research page [1] about it, or my experimental implementation [2] of one of his papers. Higher-rank types also have some limited support in OCaml and Haskell.
#+end_src

Useful example aslo a ST-Trick monad.

***** /*/

<<<Rank-n polymorphism>>>

*** <<<Subtype polymorphism>>> :drill:
:properties:
:ID:       9e587f6d-08ed-406c-9bf0-3af96cb8eb49
:end:

Allows to declare usage of a Type and all of its Subtypes.
T - Type
S - Subtype of Type
<: - subtype of
\( S <: T = S \le T \)

Subtyping is:
If it can be done to T, and there is subtype S - then it also can be done to S.
\( S <:T : \; f^{T \to X} \Rightarrow f^{S \to X} \)

*** <<<Row polymorphism>>> :drill:
SCHT: <2020-03-10 Tue>
:properties:
:ID:       18e7413e-72cc-4ab6-8c9e-1591f4b00606
:DRILL_LAST_INTERVAL: 19.2482
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:19]
:end:

# NOTE: 2019-03-11: Currently WIP in https://github.com/ghc-proposals/ghc-proposals/pull/180 
Is a lot like Subtype polymorphism, but alings itself on allowence (with | r) of subtypes and types with requested properties.
#+begin_src haskell
printX :: { x :: Int | r } -> String
printX rec = show rec.x

printY :: { y :: Int | r } -> String
printY rec = show rec.y

-- type is inferred as `{x :: Int, y :: Int | r } -> String`
printBoth rec = printX rec ++ printY rec
#+end_src

*** <<<Kind polymorphism>>> :drill:
:properties:
:ID:       4658489e-5516-44d3-b9ab-06f9077657f5
:end:

Achieved using a phantom type argument in the data type declaration.
#+begin_src haskell
;;         * -> *
data Proxy a = ProxyValue
#+end_src
Then, by default the data type can be inhabited and fully work being partially defined.
But multiple instances of kind polymorphic type can be distinguished by their particular type.

Example is the Proxy type:
#+begin_src haskell
data Proxy a = ProxyValue

let proxy1 = (ProxyValue :: Proxy Int) -- * :: Proxy Int
let proxy2 = (ProxyValue :: Proxy a)   -- * -> * :: Proxy a
#+end_src

*** <<<Linearity polymorphism>>> :drill:
:properties:
:ID:       4a8f87d0-99ee-40e7-8a02-92b97540f9b4
:end:

Leverages linear types.
For exampe - if fold over a dynamic array:
  1) In basic Haskell - array would be copied at every step.
  2) Use low-level unsafe functions.
  3) With Linear type function we guarantee that the array would be used only at one place at a time.

So, if we use a function (* -o * -o -o *) in foldr - the fold will use the initial value only once.

** <<<Pragma>>> :drill:
SCHT: <2020-09-20 Sun>
:properties:
:ID:       92784b03-a83b-4599-9cd0-f2210dd5e177
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-27 Fri 12:56]
:end:

Pragma - instruction to the compiler that specifies how a compiler should process the code.
Pragma in Haskell have form:
#+begin_src haskell
{-# PRAGMA options #-}
#+end_src

*** <<<LANGUAGE pragma>>> :drill:
SCHT: <2020-09-20 Sun>
:properties:
:ID:       6f16cf30-77b4-4e31-af0a-11dd24ae48bf
:DRILL_LAST_INTERVAL: 269.6572
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

Controls what variations of the language are permitted.
It has a set of allowed options: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html, which can be supplied.

**** <<<LANGUAGE option>>>

***** /*/

<<<Language options>>>

***** Useful by default :drill:
:properties:
:ID:       29c25dae-3a88-4fe1-acf3-4ebe568da284
:end:

#+begin_src haskell
import EmptyCase
import FlexibleContexts
import FlexibleInstances
import InstanceSigs
import MultiParamTypeClasses
#+end_src

***** <<<AllowAmbiguousTypes>>> :drill:
SCHT: <2020-09-16 Wed>
:properties:
:ID:       e5aaa672-dec3-4621-8429-9b5cdcaac069
:DRILL_LAST_INTERVAL: 191.5213
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 22:52]
:end:

Allow type signatures which appear that they would result in an unusable binding.
However GHC will still check and complain about a functions that can never be called.

***** <<<ApplicativeDo>>> :drill:
:properties:
:ID:       cb3b5b66-06a8-4187-9606-631faefa7814
:end:

Enables an alternative in-depth reduction that translates the do-notation to the operators =<$>=, =<*>=, =join= as far as possible.

For GHC to pickup the patterns, the final statement must match one of these patterns exactly:

#+begin_src haskell
  pure E
  pure $ E
  return E
  return $ E
#+end_src

When the statements of do expression have dependencies between them, and ApplicativeDo cannot infer an Applicative type - GHC uses a heuristic \( O(n^2) \) algorithm to try to use <*> as much as possible. This algorithm usually finds the best solution, but in rare complex cases it might miss an opportunity. There is aslo \( O(n^3) \) algorithm that finds the optimal solution: =-foptimal-applicative-do=.

Requires =ap = <*>=, =return = pure=, which is true for the most monadic types.
  * Allows use of do-notation with types that are an instance of Applicative and Functor
  * In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.

The only way it shows up at the source level is that you can have a =do= expression with only Applicative or Functor constaint.

It is possible to see the actual translation by using =-ddump-ds=.

***** <<<ConstrainedClassMethods>>> :drill:
:properties:
:ID:       301a3741-f96c-45a7-bb14-7e342167b62d
:end:

Enable the definition of further constraints on individual class methods.

***** <<<CPP>>> :drill:
:properties:
:ID:       4209a57c-e331-4c03-9386-b08d2cfd33d7
:end:

Enable [[https://en.wikipedia.org/wiki/C_preprocessor][C preprocessor]].

***** <<<DeriveFunctor>>> :drill:
SCHT: <2020-10-20 Tue>
:properties:
:ID:       34a6dad7-515c-4b3c-afeb-da268b77c4e0
:DRILL_LAST_INTERVAL: 270.5287
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-23 Thu 22:57]
:end:

Automatic deriving of instances for the Functor type class.
For type power set functor is unique, its derivation inplementation can be autochecked.

***** <<<ExplicitForAll>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       cde4229a-165c-4dfa-a3b5-22375f7924a6
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

Allow explicit forall quantificator in places where it is implicit by Haskell.

***** <<<FlexibleContexts>>> :drill:
:properties:
:ID:       ab8dc15c-452a-4dd7-94fe-1e1c38fd0c1e
:end:

Ability to use complex constraints in class declaration contexts.
The only restriction on the context in a class declaration is that the class hierarchy must be acyclic.
#+begin_src haskell
class C a where
  op :: D b => a -> b -> b

class C a => D a where ...
#+end_src
\( C :> D \), so in C we can talk about D.

Synergizes with ConstraintKinds.

***** <<<FlexibleInstances>>> :drill:
SCHT: <2020-07-16 Thu>
:properties:
:ID:       c59f794d-5687-4b96-9fd0-7df4b650ed2a
:DRILL_LAST_INTERVAL: 146.9918
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.418
:DRILL_EASE: 2.48
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:33]
:end:

Allow type class instances types contain nested types.
#+begin_src haskell
instance C (Maybe Int) where ...
#+end_src
Implies TypeSynonymInstances.

***** <<<GeneralizedNewtypeDeriving>>> :drill:
SCHT: <2020-08-07 Fri>
:properties:
:ID:       96a23172-9aa7-4290-adfe-a18169dd4362
:DRILL_LAST_INTERVAL: 225.56
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

Enable GHC’s =newtype= cunning generalised deriving mechanism.
#+begin_src haskell
newtype Dollars = Dollars Int
  deriving (Eq, Ord, Show, Read, Enum, Num, Real, Bounded, Integral)
#+end_src
(In old Haskell-98 only Eq, Ord, Enum could been inherited.)

***** <<<ImplicitParams>>> :drill:
SCHT: <2020-07-04 Sat>
:properties:
:ID:       3ca7e2f5-0e70-474f-bb31-08186739efb1
:DRILL_LAST_INTERVAL: 192.3251
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.625
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:30]
:end:

Allow definition of functions expecting implicit parameters. In the Haskell that has static scoping of variables allows the dynamic scoping, such as in classic Lisp or ELisp.
Sure thing this one can be puzzling as hell inside Haskell.

***** <<<LambdaCase>>> :drill:
SCHT: <2020-03-19 Thu>
:properties:
:ID:       938047ce-f015-45e9-b5f8-b8e39fb456a7
:DRILL_LAST_INTERVAL: 126.7288
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-13 Wed 20:50]
:end:

Enables expressions of the form:
#+begin_src haskell
\case { p1 -> e1; ...; pN -> eN }

-- OR

\case
  p1 -> e1
  ...
  pN -> eN
#+end_src

***** <<<MultiParamTypeClasses>>> :drill:
:properties:
:ID:       5e34ea4e-cb1b-4359-968c-440f068b50ad
:end:

Implies: ConstrainedClassMethods
Enable the definitions of typeclasses with more than one parameter.
#+begin_src haskell
class Collection c a where
#+end_src

***** <<<MultiWayIf>>> :drill:
SCHT: <2020-03-14 Sat>
:properties:
:ID:       9b5af526-36f9-49e2-ae8c-ac9a5361b877
:DRILL_LAST_INTERVAL: 35.4527
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.375
:DRILL_EASE: 2.96
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:02]
:end:

Enable multi-way-if syntax.
#+begin_src haskell
if | guard1 -> code1
   | ...
   | guardN -> codeN
#+end_src

***** <<<OverloadedStrings>>> :drill:
SCHT: <2020-07-26 Sun>
:properties:
:ID:       b09019e1-34d5-40f0-b866-504f3e1e4515
:DRILL_LAST_INTERVAL: 213.8621
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

Enable overloaded string literals (string literals become desugared via the =IsString= class).

With overload, string literals has type:
#+begin_src haskell
(IsString a) => a
#+end_src

The usual string syntax can be used, e.g. =ByteString=, =Text=, and other variations of string-like types.
Now they can be used in pattern matches as =char->integer= translations. To pattern match =Eq= must be derived.

To use class =IsString= - import it from =GHC.Ext=.

***** <<<PartialTypeSignatures>>> :drill:
:properties:
:ID:       4ac887da-6e23-4028-9924-3496787aa8d0
:end:

Partial type signature containins wildcards, placeholders (=_=, =_name=).
Allows programmer to which parts of a type to annotate and which to infer. Also applies to constraint part.

As untuped expression, partly typed can not polymorphicly recurse.

-Wno-partial-type-signatures supresses infer warnings.

***** <<<RankNTypes>>> :drill:
SCHT: <2020-05-31 Sun>
:properties:
:ID:       54d784f9-d433-4ef8-a029-a6a6c6f61c18
:DRILL_LAST_INTERVAL: 157.7214
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 11:57]
:end:

Enable types of arbitrary rank.
See Type rank.

Implies ExplicitForAll.

Allows =forall= quantifier:
  * Left side of \to
  * Right side of \to
  * as argument of a constructor
  * as type of a field
  * as type of an implicit parameter
  * used in pattern type signature of lexically scoped type variables

***** <<<ScopedTypeVariables>>> :drill:
:properties:
:ID:       5311b6b7-32e9-4ba9-a3fa-43b37df5988f
:end:

By default type variables do not have a scope except inside type signatures where they are used.

When there are internall type signatures provided in the code block (=where=, =let=, etc.) they (main type description of a function and internal type descriptions) restrain one-another and become not trully polymorphic, which creates a bounding interdependency of types that GHC would complain about.

/*/ option provides the lexical scope inside the code block for type variables that have forall quantifier. Because they are now lexiacally scoped - those type variables are used across internal type signatures.

For details see: https://ocharles.org.uk/guest-posts/2014-12-20-scoped-type-variables.html

Implies ExplicitForAll.

***** <<<TupleSections>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       30ae7849-e739-4718-b031-5566e8f82a67
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Allow tuple section syntax:
#+begin_src haskell
(, True)
(, "I", , , "Love", , 1337)
#+end_src

***** <<<TypeApplications>>> :drill:
SCHT: <2020-04-03 Fri>
:properties:
:ID:       d5912c99-9c72-44ad-8577-a02f7d31671f
:DRILL_LAST_INTERVAL: 25.2548
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.2
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:09]
:end:

Allow type application syntax:
#+begin_src haskell
read @Int 5

:type pure @[]
pure @[] :: a -> [a]

:type (<*>) @[]
(<*>) @[] :: [a -> b] -> [a] -> [b]

--

instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)

λ> ($ 0) <$> generate (arbitrary @(Int -> Int))
#+end_src

***** <<<TypeSynonymInstances>>> :drill:
SCHT: <2020-06-20 Sat>
:properties:
:ID:       3989b294-f011-48c0-9998-be10bd75c541
:DRILL_LAST_INTERVAL: 178.2614
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:35]
:end:

Now type synonim can have it's own type class instances.

***** <<<UndecidableInstances>>> :drill:
:properties:
:ID:       71ac682f-292d-401a-bd61-0c28a707a950
:end:

Permit instances which may lead to type-checker non-termination.

GHC has Instance termination rules regardless of FlexibleInstances FlexibleContexts.

***** <<<ViewPatterns>>> :drill:
SCHT: <2020-03-28 Sat>
:properties:
:ID:       cbd923fc-d36c-4953-a8dc-ca370eda11f0
:DRILL_LAST_INTERVAL: 18.7966
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 14
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.072
:DRILL_EASE: 1.44
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:00]
:end:

#+begin_src haskell
foo (f1 -> Pattern1) = c1
foo (fn -> Pattern2 a b) = g1 a b
#+end_src
(/expression/ \to /pattern/): take what is came to match - apply the /expression/, then do /pattern/-match, and return what originally came to match.

Semantics:
  * /expression/ & /pattern/ share the scope, so also variables.
  * if (=(/expression/ :: t1 -> t2) && (/pattern/ :: t2)=)
      then
        (ViewPattern =(/expression/ -> /pattern/)= =:: t1=) (return what originally was recieved into pattern match)
      else
        skip

/*/ are like pattern guards that can be nested inside of other patterns.
/*/ are a convenient way to pattern-match algebraic data type.

Additional possible usage:
#+begin_src haskell
foo a (f2 a -> Pattern3 b c) = g2 b c  -- only for function definitions
foo ((f,_), f -> Pattern4) = c2  -- variables can be bount to the left in data constructors and tuples
#+end_src

***** <<<DatatypeContexts>>> :drill:
SCHT: <2020-03-26 Thu>
:properties:
:ID:       0ed5ea82-77f7-4b51-af7b-19a3f6426ec3
:DRILL_LAST_INTERVAL: 113.3327
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.556
:DRILL_EASE: 2.48
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:25]
:end:

Allow contexts in data types.
#+begin_src haskell
data Eq a => Set a = NilSet | ConsSet a (Set a)

-- NilSet :: Set a
-- ConsSet :: Eq a => a -> Set a -> Set a
#+end_src
Considered misfeature. Deprecated. Going to be removed.

***** <<<StandaloneKindSignatures>>> :drill:
:properties:
:ID:       e3ecf941-d6be-4b47-abdd-b08675bf367a
:end:

Type signatures for type-level declarations.

#+begin_src haskell
type <name_1> , ... , <name_n> :: <kind>
#+end_src

#+begin_src haskell
type MonoTagged :: Type -> Type -> Type
data MonoTagged t x = MonoTagged x

type Id :: forall k. k -> k
type family Id x where
  Id x = x

type C :: (k -> Type) -> k -> Constraint
class C a b where
  f :: a b

type TypeRep :: forall k. k -> Type
data TypeRep a where
  TyInt   :: TypeRep Int
  TyMaybe :: TypeRep Maybe
  TyApp   :: TypeRep a -> TypeRep b -> TypeRep (a b)
#+end_src

< GHC 8.10.1 - type signatures were only for term level declarations.

Extension makes signatures feature more uniformal.

Allows to set the order of quantification, order of variables in a kind. For example when using TypeApplications.

Allows to set full kind of derivable class, solving situations with GADT return kind.

****** /*/

<<<SAKS>>>
<<<Standalone kind signatures>>>

***** <<<PartialTypeSignatures>>> :drill:
:PROPERTIES:
:ID:       2e2f62a0-a6ac-4046-969c-bcb6e4ff4810
:END:

Very healpful. Helps to solve type level, helps to establish type signatures and constraints.
Allow to provide =_= in the type signatures to automatically infere-in the type information there.

Wild cards:
  * Type
  #+begin_src haskell
f :: _ -> _ -> a
  #+end_src

  * Constraint
  #+begin_src haskell
f :: _ => a -> b -> c
  #+end_src

  * Named
  #+begin_src haskell
f :: _x -> _x -> a
  #+end_src
allows to identify the same wildcard.

**** How to make a GHC LANGUAGE extension

In =libraries/ghc-boot-th/GHC/LanguageExtensions/Type.hs= add new constructor to the =Extension= type
#+begin_src haskell
data Extension
  = Cpp
  | OverlappingInstances
  ...
  | Foo
#+end_src

=/main/DynFlags.hs= extend =xFlagsDeps=:
#+begin_src haskell
xFlagsDeps = [
  flagSpec "AllowAmbiguousTypes" LangExt.AllowAmbiguousTypes,
  ...
  flagSpec "Foo"                 LangExt.Foo
]
#+end_src
It is for basic case. For testing, parser see further: https://blog.shaynefletcher.org/2019/02/adding-ghc-language-extension.html

** <<<Compositionality>>> :drill:
SCHT: <2020-06-21 Sun>
:properties:
:ID:       d8df7582-1e97-4cf9-9d0d-146ede21ad1f
:DRILL_LAST_INTERVAL: 209.6274
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:35]
:end:

Complex expression is determined by the constituent expressions and the rules used to combine them.

If the meaning fully obtainable form the parts and composition - it is full, pure compositionality.

If there exists composed idiomatic expression - it is unfull, unpure compositionality, because meaning leaks-in from the sources that are not in the composition.

*** /*/

<<<Principe of compositionality>>>
<<<Composition>>>
<<<Compositional>>>

** <<<Referential transparency>>> :drill:
SCHT: <2021-01-18 Mon>
:properties:
:ID:       b7cbd6cd-5739-431a-9eae-5922e60dff81
:DRILL_LAST_INTERVAL: 315.4885
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.571
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:56]
:end:

Given the same input return the same output.
So:
/*/ expression can be replaced with its corresponding resulting value without change for program's behavior.
/*/ functions are pure.

*** /*/

<<<Referentially transparent>>>

** <<<Semantics>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       f47d8882-a0eb-4956-9b87-56ac0c20d069
:DRILL_LAST_INTERVAL: 23.8485
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:46]
:end:

Philosophical study of meaning.
Meaning of symbols, words.

*** <<<Operational semantics>>> :drill:
SCHT: <2020-03-14 Sat>
:properties:
:ID:       df2cb6cf-0eb7-4756-945e-a08d7246245b
:DRILL_LAST_INTERVAL: 22.7693
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.25
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:22]
:end:

Constructing proofs from logical assertions and verifying/checking/asserting things about execution and procedures their properties, such as correctness, safety or security.

Good to solve in-point localized tasks.

Process of abstraction.

**** <<<Argument>>> :drill:
SCHT: <2020-03-07 Sat>
:properties:
:ID:       56fadaf0-586a-4e26-a216-c39fcca004ea
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:00]
:end:

/arguere/ to make clear, to shine

/*/ - evidence, proof, statement that results in system consequences.

***** <<<Argument of a function>>> :drill:
:properties:
:ID:       42c01d98-580d-45c6-b602-119eb92b6b42
:end:

A value binded to the function parameter. Value/topic that the fuction would process/deal with.

Also see <<<Argument>>>.

****** /*/

<<<Function argument>>>

***** <<<First-class>>> :drill:
:properties:
:ID:       b451a91d-1eb3-4c05-882f-23ea9a643a82
:end:

Means /it/:
  * Can be used as value.
  * Passed as an argument.
From 1&2 -> /it/ can include itself.

**** <<<Relation>>> :drill:
SCHT: <2020-08-12 Wed>
:properties:
:ID:       ab1fec36-4201-4970-a717-70d56aa09e1b
:DRILL_LAST_INTERVAL: 173.9763
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.286
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:30]
:end:

Relationship between two objects.
By default it is not directed and not limited.
In Set theory: some subset of a Cartesian product between sets of objects.

***** /*/

<<<Relations>>>
<<<Relationship>>>

*** <<<Denotational semantics>>> :drill:
SCHT: <2020-07-02 Thu>
:properties:
:ID:       a21dabc0-cc1e-4225-b9f1-86a14e2b7a13
:DRILL_LAST_INTERVAL: 131.7758
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 1.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:27]
:end:

Construction of objects, that describe/tag the meanings. In Haskell often abstractions that are ment (denotations), implemented directly in the code, sometimes exist over the code - allowing to reason and implement.

/*/ are composable.

Good to achive more broad approach/meaning.

Also see Abstraction.

**** <<<Abstraction>>> :drill:
SCHT: <2020-04-25 Sat>
:properties:
:ID:       7875b659-d137-41df-b146-6fb73f090a4e
:DRILL_LAST_INTERVAL: 46.8571
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.636
:DRILL_EASE: 2.38
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

abs away from, off (in absentia)
tractus draw, haul, drag

Purified generalization of process.

Forgeting the details (axiomatic semantics). Simplified approach. Out of sight - out of mind.

/*/ creates a new semantic level in which one can be absolutely precise (operational semantics).

It is a great did to name an abstraction (denotational semantics).

***** /*/

<<<Abstractions>>>
<<<Abstracting>>>
<<<Abstract>>>

***** <<<Leaky abstraction>>> :drill:
:properties:
:ID:       696ecb38-8f84-439e-8d4d-3cbb28b44c96
:end:

Abstraction that leaks details that it is supposed to abstract away.

****** /*/

<<<Leaky abstractions>>>

***** <<<Object>>> :drill:
SCHT: <2020-05-02 Sat>
:properties:
:ID:       db3c82b9-a7ed-42aa-afe0-18c71df636dc
:DRILL_LAST_INTERVAL: 71.5171
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:45]
:end:

Absolute abstraction.

Point.

Can have properties.

Often abstracts something, for example some structure, maybe mathematical.

Objects without process are in constant state.

****** /*/

<<<Structure>>>
<<<Structures>>>
<<<Objects>>>

****** <<<Arrow>>> :drill:
:PROPERTIES:
:ID:       540e4db5-274a-4c09-b886-c81fa4d4f729
:END:

Second level of absolute abstraction.

Arrow.

Can have target, can have source. Both often are objects.

Often abstracts process.

Can have properties.

Also alias in Category Theory for "morphism", thou theory emposes properties.

******* /*/
<<<Arrows>>>
<<<Process>>>

****** <<<Terminal object>>> :drill:
SCHT: <2020-03-06 Fri>
:properties:
:ID:       8d7de2b2-7609-481a-837e-9887e779446f
:DRILL_LAST_INTERVAL: 26.9152
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:00]
:end:

One that recieves unique arrow from every object.

\( \exists ! : x \to 1 \ | \ \exists 1 \in \mathcal{C}, \ \forall x \in \mathcal{C}\)

/*/ is an empty sequence =()= in Haskell.

Called a /unit/, so recieves /terminal/ or /unit/ arrow.

Dual of initial object.

Denotation:

Category theory
\( 1 \)

Haskell
#+begin_src haskell
()
#+end_src

****** <<<Initial object>>> :drill:
SCHT: <2020-03-08 Sun>
:properties:
:ID:       8d962644-6fcd-4152-b82a-fabb9ed38f6b
:DRILL_LAST_INTERVAL: 104.916
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:26]
:end:

One that emits unique arrow into every object.

\( \exists ! : \varnothing \to x \ | \ \exists \varnothing \in \mathcal{C}, \ \forall x \mathcal{C} \)

If initial object is =Void= (most frequently) - emitted arrows called absurd, because they can not be called.

Dual of terminal object.

Denotation:

Category theory:
\( \varnothing \)

Haskell:
#+begin_src haskell
Void
#+end_src

****** Value :drill:
:PROPERTIES:
:ID:       04e4ee4a-a53e-4ce6-b58c-5a315ff077d3
:END:
#  2020-02-27: NOTE: Org-mode seems to break on radio target having 'Value' value.

What object abstracts. Without any object external structure (aka identity in Category Theory). So /*/ is immutable. Such herecy is called "Value semantics" and leads such things as referential transparency, functional programming and Haskell.

(Except, when you hack Haskell with explicit low-level funсtions, and start to directly mute values - then you are on your own, Haskell paradigm does not expect that.)

******* /*/
Value semantics
Values

****** <<<Tensor>>> :drill:
SCHT: <2021-01-01 Fri>
:properties:
:ID:       e165b708-fdd2-4062-be87-b65487de4a0e
:DRILL_LAST_INTERVAL: 298.9685
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 23:02]
:end:

Object existing out of planes, thus it can translate objects from one plane into another.
/*/ can be tried to be described with knowledge existing inside planes (from projection on the plane), but representation would always be partial.

Tensor of rank 1 is a vector.

Translations with tensor can be seen as functors.

******* /*/

<<<Tensors>>>
<<<Tensorial>>>

**** <<<Ambigram>>> :drill:
SCHT: <2020-06-21 Sun>
:properties:
:ID:       bc8fb3d5-d6bf-46b3-bf5b-5955e8f05a67
:DRILL_LAST_INTERVAL: 209.6274
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:35]
:end:

ambi both
γράμμα /grámma/ written character

Object that from different points of view has the same meaning.

While this word has two contradictory diametrically opposite usages, one was chosen (more frequent).

But it has... Both.

/TODO: For merit of differentiating the meaning about different meaning referring to Tensor as object with many meanings./

**** <<<Binary>>> :drill:
SCHT: <2020-08-26 Wed>
:properties:
:ID:       f6ddbc05-f514-49e1-8906-28e67eb0866c
:DRILL_LAST_INTERVAL: 269.6572
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:16]
:end:

Two of something.

**** <<<Arbitrary>>> :drill:
:properties:
:ID:       3fd8d537-ab00-4989-bbde-5a62a34c3bfa
:end:

/arbitrarius/ uncertain

Random, any one of.

Used as: Any one with /this/ set of properties. (constraints, type, etc.).

When there is a talk about any arbitrary value - in fact it is a talk about the generalization of computations over the set of properties.

**** <<<Refutable>>> :drill:
:properties:
:ID:       3264958f-dfb9-4dcf-9f58-9a9a588d61c9
:end:

One that has an option to fail.

**** <<<Irrefutable>>> :drill:
:properties:
:ID:       75553b01-1650-40f3-b87b-2e3d2afc9dc5
:end:

One that can not fail.

**** <<<Superclass>>> :drill:
SCHT: <2020-03-07 Sat>
:properties:
:ID:       7585ab04-6e2e-4908-88c9-28cf2dc9a73e
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:00]
:end:

Broader parent class.

**** <<<Unit>>> :drill:
SCHT: <2020-06-30 Tue>
:properties:
:ID:       8c2d205c-140f-4aa6-bcd4-8563433879d9
:DRILL_LAST_INTERVAL: 168.3498
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:59]
:end:

Represents existence. Denoted as empty sequence.
#+begin_src haskell
()
#+end_src

Type =()= holds only self-representation constructor =()=, & constructor holds nothing.

Haskell code always should recieve something back, hense nothing, emptiness, void can not be theoretically addressed, practically constructed or recieved - unit in Haskell also has a role of a stub in place of emptiness, like in =IO ()=.

**** <<<Nullary>>> :drill:
:properties:
:ID:       009d9f43-81a1-4e7e-a5be-ad706a704497
:end:

Takes no entries (for example has the arity of zero).
Has the trivial domain.

**** <<<Syntax tree>>> :drill:
:PROPERTIES:
:ID:       f4312216-c6b9-461f-bf8e-ef446a5cbcc1
:END:

Tree of syntactic elements (each node denotes construct occurring in the language/source code) that represent the full particular expression/implementation (or said).

***** <<<Abstract syntax tree>>> :drill:
:PROPERTIES:
:ID:       c79cc094-a057-42b1-aa3d-05304de57c2e
:END:

"Abstract" since does not represent every detail of the syntax (ex. parentheses), but rather concentrates on structure and content.

Widely used in compilers to check the code structure for accuracy and coherence.

****** /*/

<<<AST>>>

***** <<<Concrete syntax tree>>>

An ordered, rooted syntax tree that represents the syntactic structure of a string according to some context-free grammar.

"Concrete" since (in contrast to "abstract") - concretely reflects the syntax of the input language.

****** /*/

<<<Parse tree>>>
<<<Derivation tree>>>

**** <<<Stream>>> :drill:
:properties:
:ID:       da9e4972-1cef-48f6-9878-8ec79302b759
:end:

/*/ an infinite sequence that forgets previous objects, and remembers only currently relevant objects.

\( E \ | \ X \to (X \times A + 1) \), the set (or object) of streams on A (final coalgebra \( A_{*} \) of \( E \)).

=cycle= is one of stream functions.
#+begin_src haskell
a = (cycle [Nothing, Nothing, Just "Fizz"])
b = (cycle [Nothing, Nothing, Nothing, Nothing, Just "Buzz"])
#+end_src

Can be:
  * indexed, timeless, with current object
  * timed:
  ** =[(timescale, event)]=
  ** =[(realtime, event)]=

Has amalgamation with Functional Reactive Programming.

**** <<<Linear>>> :drill:
:properties:
:ID:       a1c01464-061f-46a0-b08f-4b98d95714d0
:end:

Values consumed once or not used.

=x^2= consumes/uses =x= two times =(x*x)=.

***** /*/

<<<Linearity>>>

**** <<<Predicative>>> :drill:
SCHT: <2020-04-19 Sun>
:properties:
:ID:       aee54dbf-2387-403e-9589-f93bcb416963
:DRILL_LAST_INTERVAL: 41.1865
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.334
:DRILL_EASE: 2.34
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:56]
:end:

Non-self-referencing definition.

---

/Antonym - Impredicative./

**** <<<Quantifier>>> :drill:
SCHT: <2020-08-23 Sun>
:properties:
:ID:       ac758691-4dc3-4e6c-9f18-59793263a845
:DRILL_LAST_INTERVAL: 267.3
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:16]
:end:

Specifies the quantity of specimens.

Two most common quantifiers \( \forall \) (Forall) and \( \exists \) (Exists).
\( \exists ! \) - one and only one (exists only unique).

***** /*/

<<<Quantification>>>
<<<Quantifiers>>>
<<<Quantified>>>

***** <<<Forall quantifier>>> :drill:
SCHT: <2020-08-16 Sun>
:properties:
:ID:       922b622a-38c4-4079-a1e0-61ff010f7a10
:DRILL_LAST_INTERVAL: 160.3167
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 23:04]
:end:

Permits to not infer the type, but to use any that fits. The variant depends on the LANGUAGE option used:
  * ScopedTypeVariables
  * RankNTypes
  * ExistentialQuantification

****** /*/

<<<Forall>>>

*** <<<Axiomatic semantics>>> :drill:
SCHT: <2020-03-23 Mon>
:properties:
:ID:       18d65b73-cec0-49ed-868a-a97d73abe329
:DRILL_LAST_INTERVAL: 31.7425
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.333
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:31]
:end:

Empirical process of studying something complex by finding and analyzing true statements about it.

Good for examining interconnections.

**** <<<Property>>> :drill:
:properties:
:ID:       ead179a8-e4a5-46c1-a324-30e8e4dd15fd
:end:

Something has a property in the real world, and in theory its property corresponds to the law/laws, axioms.

In Haskell under property/law most often properties of algebraic structures.

There property testing wich does what it says.

***** /*/

<<<Properties>>>

***** <<<Associativity>>> :drill:
:properties:
:ID:       0985ce00-f1cd-441b-9d49-7c02b51298bf
:end:

Joined with common purpose.

\( P(a,P(b,c)) \equiv P(P(a,b),c) \ | \ \forall (a,b,c) \in S \),

/*/ - the operations can be grouped arbitrarily.

Property that determines how operators of the same precedence are grouped, (in computer science also in the absence of parentheses).

Etymology:
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".

In Haskell /*/ has influence on parsing when compounds have same fixity.

****** /*/

<<<Associative>>>
<<<Associative law>>>
<<<Associativity law>>>

***** <<<Left associative>>> :drill:
SCHT: <2020-05-31 Sun>
:properties:
:ID:       ccf220ac-e213-44ce-9d1b-ccd87f8b9a9a
:DRILL_LAST_INTERVAL: 100.1276
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.917
:DRILL_EASE: 2.96
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:17]
:end:

/*/ - the operations are grouped from the left.

Example:
In lambda expressions same level parts follow grouping from left to right.
\( (\lambda x . x)(\lambda y . y)z \equiv ((\lambda x . x)(\lambda y . y))z \)

****** /*/

<<<Left associativity>>>
<<<Left-associative>>>

***** <<<Right associative>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       74124ae3-4d72-48cc-856a-c0aaddbf49fc
:DRILL_LAST_INTERVAL: 90.2063
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:34]
:end:

/*/ - the operations are grouped from the right.

***** <<<Non-associative>>> :drill:
SCHT: <2020-03-29 Sun>
:properties:
:ID:       ea9d8f41-bb29-49ca-9ae7-3c1bc92d0869
:DRILL_LAST_INTERVAL: 19.9491
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

Operations can't be chained.

Often is the case when the output type is incompatible with the input type.

***** <<<Basis>>> :drill:
SCHT: <2020-08-07 Fri>
:properties:
:ID:       c880a358-f545-4e2e-9c44-7c80ca038ac1
:DRILL_LAST_INTERVAL: 225.56
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

\( \beta\alpha\sigma\iota\varsigma \) - stepping

The initial point, unreducible axioms and terms that spawn a theory.
AKA see Category theory, or Euclidian geometry basis.

****** <<<Contravariant>>> :drill:
:properties:
:ID:       d1f3dc34-f7b9-4284-b417-16b26860248a
:end:

The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis inverse-proportional for the description of a Tensors in this basisis.

Denotation:
Components for contravariant basis denoted in the upper indices:
\( V^{i} = x \)

The inverse of a covariant transformation is a contravariant transformation. Whenever a vector should be invariant under a change of basis, that is to say it should represent the same geometrical or physical object having the same magnitude and direction as before, its components must transform according to the contravariant rule.

******* /*/

<<<Contravariant cofunctor>>>
<<<Contravariant functor>>> - More inline term is Contravariant cofunctor

****** <<<Covariant>>> :drill:
SCHT: <2020-05-05 Tue>
:properties:
:ID:       90eb2e6f-8695-446f-a7e8-ccac7f47dbee
:DRILL_LAST_INTERVAL: 56.6607
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.25
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:09]
:end:

The property of basis, in which if new basis is a linear combination of the prior basis, and the change of basis proportional for a descriptions of tensors in basisis.

Denotation:
Components for covariant basis denoted in the upper indices:
\( V_{i} = x \)

******* /*/

<<<Covariant functor>>>
<<<Covariant cofunctor>>>

***** <<<Commutativity>>> :drill:
:properties:
:ID:       8d6b1e5e-a054-4757-b9a8-bb40c07d79fd
:end:

\( \forall (a,b) \in S : \; P(a,b) \equiv P(b,a) \)

****** /*/

<<<Commutative>>>
<<<Commutative law>>>

***** <<<Idempotence>>> :drill:
:properties:
:ID:       1c821458-dd2b-4112-aa32-416e27b161ba
:end:

First application gives a result. Then same operation can be applied multiple times without changing the result.
Example: Start and Stop buttons on machines.

****** /*/

<<<Idempotent>>>
<<<Idempotency>>>

***** <<<Distributive property>>> :drill:
:properties:
:ID:       6ea04559-091b-4151-b190-e97a88bb317a
:end:

Set S and two binary operators + \times:

  * \( x \times (y + z) = (x \times y) + (x \times z) \) - \times is left-distributive over +
  * \( (y + z) \times x = (y \times x) + (z \times x) \) - \times is right-distributive over +
  * left-&right-distributive - \times is distributive over +

****** /*/

<<<Distributive rule>>>
<<<Distributive axiom>>>
<<<Distributive law>>>
<<<Distributive>>>

**** <<<Effect>>> :drill:
:properties:
:ID:       3168c887-3120-40d8-ba68-2d25bae7f37f
:end:

Observable action.

**** <<<Bisimulation>>> :drill:
:PROPERTIES:
:ID:       efecab45-bf59-4193-8672-a45d06493368
:END:

When systems have exact external behaviour so for observer they are the same.

Binary relation between state transition systems that match each other's moves.

***** /*/

<<<Bisimilar>>>

*** <<<Content word>>> :drill:
SCHT: <2020-08-02 Sun>
:properties:
:ID:       2392f66d-e924-49ef-bc22-93c844f74683
:DRILL_LAST_INTERVAL: 163.7043
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:33]
:end:

Words that name objects of reality and their qualities.

*** Ancient Greek and Latin prefixes :drill:
SCHT: <2020-03-16 Mon>
:properties:
:ID:       773bbd3b-bf0f-41c2-a61b-9bb36381bd54
:DRILL_LAST_INTERVAL: 113.2344
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:27]
:end:

#+caption: Ancient Greek and Latin prefixes
#+name: tab--ancient-greek-latin-prefixes
| Meaning                 | Greek prefix      | Latin prefix         |
|-------------------------+-------------------+----------------------|
| above, excess           | hyper-            | super-, ultra-       |
| across, beyond, through | dia-              | trans-               |
| after                   |                   | post-                |
| again, back             |                   | re-                  |
| against                 | anti-             | contra-, (in-, ob-)  |
| all                     | pan               | omni-                |
| around                  | peri-             | circum-              |
| away or from            | apo-, ap-         | ab- (or de-)         |
| bad, difficult, wrong   | dys-              | mal-                 |
| before                  | pro-              | ante-, pre-          |
| between, among          |                   | inter-               |
| both                    | amphi-            | ambi-                |
| completely or very      |                   | de-, ob-             |
| down                    |                   | de-, ob-             |
| four                    | tetra-            | quad-                |
| good                    | eu-               | ben-, bene-          |
| half, partially         | hemi-             | semi-                |
| in, into                | en-               | il-, im-, in-, ir-   |
| in front of             | pro-              | pro-                 |
| inside                  | endo-             | intra-               |
| large                   | macro-            | (macro-, from Greek) |
| many                    | poly-             | multi-               |
| not*                    | a-, an-           | de-, dis-, in-, ob-  |
| on                      | epi-              |                      |
| one                     | mono-             | uni-                 |
| out of                  | ek-               | ex-, e-              |
| outside                 | ecto-, exo-       | extra-, extro-       |
| over                    | epi-              | ob- (sometimes)      |
| self                    | auto-, aut-,auth- | ego-                 |
| small                   | micro-            |                      |
| three                   | tri-              | tri-                 |
| through                 | dia-              | trans-               |
| to or toward            | epi-              | ad-, a-, ac-, as-    |
| two                     | di-               | bi-                  |
| under, insufficient     | hypo-             | sub-                 |
| with                    | sym-, syn-        | co-. com-, con-      |
| within, inside          | endo-             | intra-               |
| without                 | a-, an-           | dis- (sometimes)     |

**** /*/

<<<Greek prefix>>>
<<<Latin prefix>>>

*** <<<Idiom>>> :drill:
SCHT: <2021-01-17 Sun>
:properties:
:ID:       bc244256-751d-4205-857e-368a45580884
:DRILL_LAST_INTERVAL: 315.4885
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 22:49]
:end:

/*/ - something having a meaning that can not be derived from the conjoined meanings of /*/ constituents.
Meaning can be special for language speakers or human with particular knowledge.

/*/ can also mean applicative functor, people better stop making idiom from the term "idiom".

**** /*/

<<<Idioms>>>
<<<Idiomatic>>>

*** <<<Impredicative>>> :drill:
SCHT: <2020-03-06 Fri>
:properties:
:ID:       0f1f3bcf-df47-44de-8320-03ed8f18dc38
:DRILL_LAST_INTERVAL: 27.3014
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.125
:DRILL_EASE: 2.72
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-08 Sat 23:00]
:end:

Self-referencing definition.

---

/Antonym - Predicative./

*** <<<Context-free grammar>>> :drill:
:PROPERTIES:
:ID:       2d097ea7-25fb-4624-98fc-66d5c8711260
:END:

Type of formal grammar that is: a set of production rules that describe all possible string is a given formal language.

Term is invented by Noam Chomsky.

**** /*/

<<<CFG>>>

** <<<Set>>> :drill:
SCHT: <2021-01-02 Sat>
:properties:
:ID:       3065b5ef-e7af-41af-a46e-201ced7f3c28
:DRILL_LAST_INTERVAL: 316.8159
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.62
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:09]
:end:

Well-defined collection of distinct objects.

*** /*/

<<<Sets>>>
<<<Set theory>>>

*** <<<Closed set>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       33bc1a45-7af7-4320-ac6a-2bc785b7afd9
:DRILL_LAST_INTERVAL: 22.2548
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:21]
:end:

1) Set which complements an open set.

2) Is form of Closed-form expression. Set can be closed in under a set of operations.

*** <<<Power set>>> :drill:
SCHT: <2020-08-05 Wed>
:properties:
:ID:       fdf831a3-e05a-4bec-8849-1900ad7d9ce3
:DRILL_LAST_INTERVAL: 166.7517
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:33]
:end:

For some set \( \mathcal{S} \), the power set (\( \mathcal{P(S)} \)) is a set of all subsets of \( \mathcal{S} \), including \( \{\} \) & \( \mathcal{S} \) itself.

Denotation:
\( \mathcal{P(S)} \)

*** <<<Singleton>>> :drill:
SCHT: <2020-05-28 Thu>
:properties:
:ID:       cd966fe0-f42d-4b75-b388-85649eacc84f
:DRILL_LAST_INTERVAL: 154.8369
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 11:58]
:end:

Singleton - unit set - set with exactly one element.
Also 1-sequence.

*** <<<Russell's paradox>>> :drill:
:properties:
:ID:       65436fce-197e-40fd-8eea-a36f54a071fd
:end:

If there exists normal set of all sets - it should contain itself, which makes it abnormal.

*** <<<Cartesian product>>> :drill:
SCHT: <2020-04-06 Mon>
:properties:
:ID:       1c2c6ec3-701a-4803-a73a-7564b4ffb298
:DRILL_LAST_INTERVAL: 28.8322
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 22:50]
:end:

\( \mathcal{A} \times \mathcal{B} \equiv \sum^{\forall}{(a,b)} \ | \ \forall a \in \mathcal{A}, \forall b \in \mathcal{B} \).
Operation, returns a set of all ordered pairs \( (a, b) \)

Any function, functor is a subset of Cartesian product.

\( \sum{(elem \in (\mathcal{A} \times \mathcal{B}))}  = cardinality^{A \times B} \)

Properties:
  * not associative
  * not commutative

**** <<<Pullback>>> :drill:
:PROPERTIES:
:ID:       6c5bf63f-4c92-42c4-a8f2-de638e01effb
:END:

Subset of the cartesian product of two sets.

***** /*/
<<<Pullbacks>>>

** <<<Testing>>> :drill:
:properties:
:ID:       07ea5b8e-05ee-4824-b690-455ab4918d77
:end:

*** <<<Property testing>>>
Since property has a law, then family of that unit tests can be abstracted into the lambda function.
And tests cases come from generator.

**** <<<Function property>>>
Property corresponds to the according law.
In property testing you need to think additionally about generator and shrinking.

**** <<<Property testing type>>>

#+caption: Property testing types
#+name: tab--property-testing-type
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
|                          | Exhaustive                           | Randomized                           | Unit test (Single sample) |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|
| Whole set of values      | Exhaustive property test             | Randomised property test             | One element of a set      |
| Special subset of values | Exhaustive specialised property test | Randomised specialised property test | One element of a set      |
|--------------------------+--------------------------------------+--------------------------------------+---------------------------|

**** <<<Generator>>>
#+begin_src text
Seed
|
v
Gen A -> A
^
|
Size
#+end_src

Seed allows reproducibility.
There is anyway a need to have some seed.
Size allows setting upper bound on size of generated value. Think about infinity of list.

After failed test - shrinking tests value parts of contrexample, finds a part that still fails, and recurses shrinking.

***** /*/

<<<Generators>>>

***** Custom generator
When sertain theorem only works for a specific set of values - the according generator needs to be produced.

#+begin_src haskell
arbitrary :: Arbitrary a => Gen a
suchThat :: Gen a -> (a -> Bool) -> Gen a
elements :: [a] -> Gen a
#+end_src

**** <<<Reusing test code>>>
Often it is convinient to abstract testing of same function properties:

It can be done with (aka TestSuite combinator):
#+begin_src haskell
-- Definition
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
eqSpec :: forall a. Arbitrary a => Spec

-- Usage
{-# LANGUAGE TypeApplications #-}
spec :: Spec
spec = do
  eqSpec @Int
#+end_src

#+begin_src haskell
Eq Int
  (==) :: Int -> Int -> Bool
    is reflexive
    is symetric
    is transitive
    is equivalent to (\ a b -> not $ a /= b)
  (/=) :: Int -> Int -> Bool
    is antireflexive
    is equivalent to (\ a b -> not $ a == b)
#+end_src

***** <<<Test Commutative property>>>
Commutativity
#+begin_src haskell
:: Arbitrary a => (a -> a -> a) -> Property
#+end_src

***** <<<Test Symmetry property>>>
Symmetry
#+begin_src haskell
:: Arbitrary a => (a -> a -> Bool) -> Property
#+end_src

***** <<<Test Equivalence property>>>
Equivalence
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (a -> b) -> Property
#+end_src

***** <<<Test Inverse property>>>
#+begin_src haskell
:: (Arbitrary a, Eq b) => (a -> b) -> (b -> a) -> Property
#+end_src

**** <<<QuickCheck>>>
=Target= is a member of the Arbitrary type class.
=Target -> Bool= is something =Testable=. This properties can be complex.
Generator =arbitrary= gets the seed, and produces values of =Target=.
Function =quickCheck= runs the loop and tests that generated =Target= values always comply the property.

***** Manual automation with QuickCheck properties

#+begin_src haskell
import Test.QuickCheck
import Test.QuickCheck.Function
import Test.QuickCheck.Property.Common
import Test.QuickCheck.Property.Functor
import Test.QuickCheck.Property.Common.Internal

data Four' a b = Four' a a a b
  deriving (Eq, Show)

instance Functor (Four' a) where
  fmap f (Four' a b c d) = Four' a b c (f d)

instance (Arbitrary a, Arbitrary b) ⇒ Arbitrary (Four' a b) where
  arbitrary = do
    a1 <- arbitrary
    a2 <- arbitrary
    a3 <- arbitrary
    b <- arbitrary
    return (Four' a1 a2 a3 b)

-- Wrapper around `prop_FunctorId`
prop_AutoFunctorId :: Functor f => f a -> Equal (f a)
prop_AutoFunctorId = prop_FunctorId T

type Prop_AutoFunctorId f a
  = f a
  → Equal (f a)

-- Wrapper around `prop_AutoFunctorCompose`
prop_AutoFunctorCompose :: Functor f => Fun a1 a2 -> Fun a2 c -> f a1 -> Equal (f c)
prop_AutoFunctorCompose f1 f2 = prop_FunctorCompose (applyFun f1) (applyFun f2) T

type Prop_AutoFunctorCompose structureType origType midType resultType
  = Fun origType midType
  -> Fun midType resultType
  -> structureType origType
  -> Equal (structureType resultType)

main = do
  quickCheck $ eq $ (prop_AutoFunctorId :: Prop_AutoFunctorId (Four' ())Integer)
  quickCheck $ eq $ (prop_AutoFunctorId :: Prop_AutoFunctorId (Four' ()) (Either Bool String))
  quickCheck $ eq $ (prop_AutoFunctorCompose :: Prop_AutoFunctorCompose (Four' ()) String Integer String)
  quickCheck $ eq $ (prop_AutoFunctorCompose :: Prop_AutoFunctorCompose (Four' ()) Integer String (Maybe Int))
#+end_src

*** Write tests algorithm

1. Pick the right language/stack to implement features.
2. How expensive breakage can be.
3. Pick the right tools to test this.

*** <<<Shrinking>>> :drill:
:properties:
:ID:       bebb2732-e73d-4d2b-92e1-090ffa883c77
:end:

Process of reducing coplexity in the test case - re-run with smaller values and make sure that the test still fails.

** Logic
:properties:
:ID:       4960f252-a074-41d3-9bf1-ce46d09052bc
:end:

*** <<<Proposition>>> :drill:
SCHT: <2020-07-08 Wed>
:properties:
:ID:       8f814f63-6331-4179-abb5-264b9727ecf7
:DRILL_LAST_INTERVAL: 121.4785
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:58]
:end:

Purely abtract & theoretical logical object (idea) that has a Boolean value.

/*/ is expressed by a statement.

**** /*/

<<<Propositions>>>

**** <<<Atomic proposition>>> :drill:
SCHT: <2020-06-01 Mon>
:properties:
:ID:       ce77faac-95af-4b60-804c-52bc8ce125bc
:DRILL_LAST_INTERVAL: 129.0591
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-23 Thu 23:26]
:end:

Logically undividable unit. Does not contain logical connectives.

***** /*/

<<<Atomic propositions>>>

**** <<<Compound proposition>>> :drill:
:properties:
:ID:       ac4054a2-b6e0-48ee-afa1-38be7c122690
:end:

Formed by connecting propositions by logical connectives.

***** /*/

<<<Compound propositions>>>

**** <<<Propositional logic>>> :drill:
:properties:
:ID:       2640c170-c125-4f34-ad16-608686554075
:end:

Studies propositions and argument flow.

Refers to logically indivisible units (atomic propositions) as such, for theory - they are abstractions with Boolean properties.

Not Turing-complete, impossible to construct an arbitrary loop.

***** /*/

<<<Proposition logic>>>
<<<Proposition calculus>>>
<<<Propositional calculus>>>
<<<Statement logic>>>
<<<Sentential logic>>>
<<<Sentential calculus>>>
<<<Zeroth-order logic>>>

***** <<<First-order logic>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       fbfe3772-5c3a-41c4-9d53-6b2bc571236e
:DRILL_LAST_INTERVAL: 100.1508
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 2.917
:DRILL_EASE: 2.04
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-04 Wed 01:26]
:end:

Notation systems that use quantifiers, relations, variables over non-logical objects, allows the use of expressions that contain variables.

Turing-complete.

Extension of a propositional logic.

****** /*/

<<<Predicate logic>>>
<<<First-order predicate logic>>>
<<<First-order predicate calculus>>>

****** <<<Second-order logic>>> :drill:
:properties:
:ID:       cbc5e8e2-5a97-4bad-8fe7-d5ca067c7c48
:end:

Extension over first-order logic that quantifies over relations.

******* <<<Higher-order logic>>> :drill:
:properties:
:ID:       b72dbeaa-ea81-4442-956b-5ab009afa82d
:end:

Extension over second-order logic that uses additional quantifiers, stronger semantics.

Is more expressive, but model-theoretic properties are less well-behaved.

*** <<<Logical connective>>> :drill:
:properties:
:ID:       0e5b50bc-8b00-463f-b9ad-f04fd3a525ac
:end:

Logical operation.

**** /*/

<<<Logical connectives>>>

**** <<<Conjunction>>> :drill:
SCHT: <2020-04-23 Thu>
:properties:
:ID:       3f47a5a4-aa8a-43a5-a834-b16f02ee343d
:DRILL_LAST_INTERVAL: 162.2449
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.42
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-13 Wed 19:10]
:end:

Logical AND.

Denotation:
\( \land \)

Multiplies cardinalities.

Haskell kind:
#+begin_src haskell
 * *
#+end_src

**** <<<Disjunction>>> :drill:
SCHT: <2020-03-26 Thu>
:properties:
:ID:       beba897a-84ca-42c9-a094-ba48487c587b
:DRILL_LAST_INTERVAL: 159.6473
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 02:35]
:end:

Logical \( OR \)
Denotation:
\( \lor \)

Summs cardinalities.

*** <<<Predicate>>> :drill:
SCHT: <2020-04-08 Wed>
:properties:
:ID:       6f4b0532-ca5f-4ec6-b827-bceb4afb0d3f
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-08 Sun 22:51]
:end:

Function with Boolean codomain.
\( P: X \to \{ true, \ false \} \) - /*/ on \( X \).

Notation: \( P(x) \)

Im many cases includes relations, quantifiers.

*** <<<Statement>>> :drill:
SCHT: <2020-08-26 Wed>
:properties:
:ID:       0fbcd5d9-8c13-4486-aabe-47c831900548
:DRILL_LAST_INTERVAL: 225.1278
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.4
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:59]
:end:

Declarative expression that is a bearer of a proposition.

When we talk about expression or statement being true/false - in fact we refer to the proposition that they represent.

Difference between proposition, statement, expression:
1. "2 + 3 = 5"
2. "two plus three equals five"

  * 1 & 2 are statements. Each of them is a collection of transmission symbols (linguistic objects) from a symbol systems \( \equiv \) expression. Each of them is expression that bears proposition (an idea resulting in a Boolean value) \( \equiv \) statement.

  * 1 & 2 represent the same proposition. Proposition from 1 \( \equiv \) proposition from 2.

  * Statement 1 \( \ne \) statement 2. They are two different statements, written in different systems. And statement "2 + 3 = 5" \( \ne \) statement "3 + 2 = 5".

**** /*/

<<<Assertion>>>
<<<Assertions>>>
<<<Statements>>>

*** <<<Iff>>> :drill:
SCHT: <2020-10-08 Thu>
:properties:
:ID:       50d0c8a8-4e41-4ddd-92fa-8135124c1809
:DRILL_LAST_INTERVAL: 268.496
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:01]
:end:

If and only if, exectly when, just.
Denotation:
\( \iff \)

** Haskell structure
:properties:
:ID:       f4eaf80a-e339-4205-801e-d956292d3b27
:end:

*** /*/
Haskell structures

*** <<<Pattern match>>> :drill:
:properties:
:ID:       fdc19b86-7e7d-465b-a6e6-0de994590325
:end:

Are not first-class. It is a set of patter match semantic notations.

Must be linear.

/*/ precedence (especially with more then one parameter, especially with =_= used) often changes the function.

**** <<<As-pattern>>> :drill:
SCHT: <2020-10-11 Sun>
:properties:
:ID:       a2d762f7-549b-4aa1-ba3e-183c2e757a35
:DRILL_LAST_INTERVAL: 215.8069
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 7
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.714
:DRILL_EASE: 2.38
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:57]
:end:

#+begin_src haskell
f list@(x, xs) = ...
#+end_src

#+begin_src haskell
f (x:xs)   = x:x:xs -- Can be compiled with reconstruction of x:xs
f a@(x:_) = x:a -- Reuses structure without reconstruction
#+end_src

***** /*/

<<<As-patterns>>>
<<<As pattern>>>
<<<As patterns>>>

**** <<<Wild-card>>> :drill:
:properties:
:ID:       582d6116-1313-484e-a69e-7439ece1a28a
:end:

Matches anything and can not be binded. For matching someting that should pass not checked and is not used.

#+begin_src haskell
head (x:_)             = x
tail (_:xs)            = xs
#+end_src

***** /*/
<<<Wild-cards>>>
<<<Wildcard>>>
<<<Wildcards>>>

**** <<<Case>>> :drill:
SCHT: <2020-02-27 Thu>
:properties:
:ID:       14309b50-3648-47ba-a4b1-eb5aa4bd7a3c
:DRILL_LAST_INTERVAL: 90.4721
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.3
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:33]
:end:

#+begin_src haskell
case x of
  pattern1  -> ex1
  pattern2  -> ex2
  pattern3  -> ex3
  otherwise -> exDefault
#+end_src

Bolting guards & expressions with syntatic sugar on case:
#+begin_src haskell
case () of _
  | expr1     -> ex1
  | expr2     -> ex2
  | expr3     -> ex3
  | otherwise -> exDefault
#+end_src

Pattern matching in function definitions is realized with case expressions.

**** <<<Guard>>> :drill:
:properties:
:ID:       9b4971e7-2d30-453d-abb8-44bb21c06c55
:end:

Check values against the predicate and use the first match definition:

#+begin_src haskell
f x
  | predicate1 = definition1
  | predicate2 = definition2
  ...
  | x < 0      = definitionN
  ...
  | otherwise  = definitionZ
#+end_src

***** /*/

<<<Guards>>>

**** <<<Pattern guard>>> :drill:
SCHT: <2020-04-09 Thu>
:properties:
:ID:       4ab85a6a-7e60-47fb-996a-c4d5263c3f62
:DRILL_LAST_INTERVAL: 30.9894
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 17
:DRILL_FAILURE_COUNT: 5
:DRILL_AVERAGE_QUALITY: 3.117
:DRILL_EASE: 1.9
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:00]
:end:

Allows check a list of pattern matches against functions, and then proceed.

| (/patternMatch1/) <- (/funcCheck1/)
, (/patternMatch2/) <- (/funcCheck2/)
= /RHS/

#+begin_src haskell
lookup :: Eq a => a -> [(a, b)] -> Maybe b

addLookup l a1 a2
   | Just b1 <- lookup a1 l
   , Just b2 <- lookup a2 l
   = b1 + b2
{-...other equations...-}
#+end_src
Run functions, they must succeed. Then pattern match results to =b1=, =b2=. Only if successful - execute the equation.

Default in Haskell 2010.

***** /*/

<<<Pattern guards>>>

**** <<<Lazy pattern>>> :drill:
:properties:
:ID:       82076e4d-b5fd-48e1-858b-1d15858661bb
:end:

Defers the pattern match directly to the last moment of need during execution of the code.

#+begin_src haskell
f (a, b) = g a b -- It would be checked that the pattern of the pair constructor
-- is present, and that parameters are present in the constructor.
-- Only after that success - work would start on the RHS, aka then construction
-- g would start only then.

f ~(a, b) = g a b -- Pattern match of (a, b) deferred to the last moment,
-- RHS starts, construction of g starts.
-- For this lazy pattern the  equivalent implementation would be:
-- f p = g (fst p) (snd p)  -- RHS starts, during construction of g
-- the arguments would be computed and found, or error would be thrown.
#+end_src

Due to full laziness deferring everything to the runtime execution - the lazy pattern is one-size-fits all (irrefutable), analogous to =_=, and so it does not produce any checks during compilation, and raises errors during runtime.

/*/ is very useful during recursive construction of recursive structure/process, especially infinite.

***** /*/

<<<Lazy-pattern>>>
<<<Lazy patterns>>>

**** <<<Pattern binding>>> :drill:
:properties:
:ID:       5fcc52b7-e84e-4434-9d84-0239f3122264
:end:

Entire LHS is a pattern, is a lazy pattern.

#+begin_src haskell
fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
#+end_src

***** /*/

<<<Pattern bindings>>>

*** <<<Smart constructor>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       e2aded58-a463-4762-97c4-7fc2238d386d
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Process/code placing extra rules & constraints on the construction of values.

*** <<<Level of code>>> :drill:
SCHT: <2020-09-20 Sun>
:properties:
:ID:       c0196ee9-7ddc-4b66-b2bb-0d52f1051d75
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-27 Fri 12:57]
:end:

There are these levels of Haskell code:

**** /*/

<<<Code level>>>

**** <<<Type level>>> :drill:
:properties:
:ID:       2d900462-89be-4f77-be51-2d1867e82922
:end:

Level of code that works with data types.

***** <<<Type level declaration>>> :drill:
:properties:
:ID:       c345f226-b6e3-42ca-8ca4-cd8c454e3ae3
:end:

#+begin_src haskell
type ...
newtype ...
data ...
class ...
instance ...
#+end_src

****** /*/

<<<Type level declarations>>>
<<<Type-level declaration>>>
<<<Type-level declarations>>>


***** <<<Type check>>> :drill:
:properties:
:ID:       f4b3cb1f-1860-49f0-bd56-8eddbd4bfe4d
:end:

=if= The type level information is complete (strongly connected graph)

  =then=

    Generalize the types and check if type level consistent to term level.

  =else=

    Infer the missing type level part from the term level. There are certain situations and structures where ambiguity arises and is unsolvable from the information of the term level (most basic example is polymorphic recursion).

****** /*/

<<<Typecheck>>>
<<<Typechecking>>>
<<<Typechecks>>>

****** <<<Complete user-specific kind signature>>> :drill:
:properties:
:ID:       a510aee8-b732-4022-bd77-bb08f7383e04
:end:

Type level declaration is considered to "have a CUSK" is it has enough syntatic information to warrant completeness (strongly connected graph) and start checking type level correspondence to term level, it is a ad-hock state ot type inferring.

In the future GHC would use other algorythm over/instead of CUSK.

******* /*/

<<<CUSK>>>
<<<CUSKs>>>
<<<Complete user-specific kind signatures>>>
<<<Complete, user-specific kind signature>>>

**** <<<Term level>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       6bc4fbee-38e5-4612-ae28-8344a0f6028c
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Level of code that does logical execution.

**** <<<Compile level>>> :drill:
SCHT: <2020-09-20 Sun>
:properties:
:ID:       37ac8b2b-af11-4b67-976c-84bd00d5f1bc
:DRILL_LAST_INTERVAL: 269.6572
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Level of code, about compilation processes/results.

***** /*/

<<<Compilation level>>>

**** <<<Runtime level>>> :drill:
SCHT: <2020-07-23 Thu>
:properties:
:ID:       99d21c80-6b3d-4818-aef0-6c7796571883
:DRILL_LAST_INTERVAL: 209.4486
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.75
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-27 Fri 13:03]
:end:

Level of code of main program operation, when machine does computations with compiled binary code.

**** <<<Kind level>>> :drill:
:properties:
:ID:       22d0e2bf-e879-4e90-80c6-0892b939d9a6
:end:

Level of code where kinds & kind declarations are situated, infered and checked.

***** <<<Kind check>>> :drill:
:properties:
:ID:       75185d70-0d08-4f13-b355-feaa559e3a76
:end:

Applying the type check to kind check:

=if= The kind level information is complete (strongly connected graph)

  =then=

    Check if kind level consistent to term level.

  =else=

    Infer the missing kind level parts from the type level. There are certain situations and structures where ambiguity arises and is unsolvable from the information of the kind level.

With =StandaloneKindSignatures= kind completeness happens against found (standalone) kind signature.

With =CUSKs= extension <<<kind>>> completeness happens agains "complete user-specific kind signature"

****** /*/

<<<Kindcheck>>>
<<<Kind checks>>>

*** <<<Orphan type instance>>> :drill:
SCHT: <2020-03-26 Thu>
:properties:
:ID:       9a4837d3-82e9-49f1-860d-e198013a60b5
:DRILL_LAST_INTERVAL: 117.6412
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.167
:DRILL_EASE: 2.08
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:38]
:end:

Hanging type instance from inconsistent code base.
1) Supporting structure not fully present.
2) Several implementations of instance present.

*** <<<undefined>>> :drill:
SCHT: <2020-08-04 Tue>
:properties:
:ID:       c2bc65ee-1d9b-4633-9aa1-780fa07752a8
:DRILL_LAST_INTERVAL: 203.0039
:DRILL_REPEATS_SINCE_FAIL: 7
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.28
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 13:57]
:end:

Placeholder value that helps to do typechecking.

*** <<<Hierarchical module name>>>
:properties:
:ID:       0f94cac9-1a80-47a8-96b4-c57de3d5d046
:end:

Hierarchical naming scheme:

#+begin_src text
Algebra                 -- Was this ever used?
    DomainConstructor   -- formerly DoCon
    Geometric           -- formerly BasGeomAlg

Codec                   -- Coders/Decoders for various data formats
    Audio
       Wav
       MP3
       ...
    Compression
       Gzip
       Bzip2
       ...
    Encryption
       DES
       RSA
       BlowFish
       ...
    Image
       GIF
       PNG
       JPEG
       TIFF
       ...
    Text
       UTF8
       UTF16
       ISO8859
       ...
    Video
       Mpeg
       QuickTime
       Avi
       ...
    Binary                 -- these are for encoding binary data into text
       Base64
       Yenc

Control
    Applicative
    Arrow
    Exception           -- (opt, inc. error & undefined)
    Concurrent          -- as hslibs/concurrent
        Chan            -- these could all be moved under Data
        MVar
        Merge
        QSem
        QSemN
        SampleVar
        Semaphore
    Parallel            -- as hslibs/concurrent/Parallel
        Strategies
    Monad               -- Haskell 98 Monad library
        ST              -- ST defaults to Strict variant?
            Strict      -- renaming for ST
            Lazy        -- renaming for LazyST
        State           -- defaults to Lazy
            Strict
            Lazy
        Error
        Identity
        Monoid
        Reader
        Writer
        Cont
        Fix              -- to be renamed to Rec?
        List
        RWS

Data
    Binary              -- Binary I/O
    Bits
    Bool                -- &&, ||, not, otherwise
    Tuple               -- fst, snd
    Char                -- H98
    Complex             -- H98
    Dynamic
    Either
    Int
    Maybe               -- H98
    List                -- H98
    PackedString
    Ratio               -- H98
    Word
    IORef
    STRef               -- Same as Data.STRef.Strict
        Strict          
        Lazy            -- The lazy version (for Control.Monad.ST.Lazy)
    Binary              -- Haskell binary I/O
    Digest
        MD5
        ...             -- others (CRC ?)
    Array               -- Haskell 98 Array library
        Unboxed
        IArray
        MArray
        IO              -- mutable arrays in the IO/ST monads
        ST
    Trees
        AVL
        RedBlack
        BTree
    Queue
        Bankers
        FIFO
    Collection
    Graph               -- start with GHC's DiGraph?
    FiniteMap
    Set
    Memo                -- (opt)
    Unique

    Edison              -- (opt, uses multi-param type classes)
        Prelude         -- large self-contained packages should have
        Collection      -- their own hierarchy?  Like a vendor branch.
        Queue           -- Or should the whole Edison tree be placed

Database
    MySQL
    PostgreSQL
    ODBC

Dotnet
    ...                 -- Mirrors the MS .NET class hierarchy

Debug                   -- see also: Test
    Trace
    Observe             -- choose a default amongst the variants
        Textual            -- Andy Gill's release 1
        ToXmlFile          -- Andy Gill's XML browser variant
        GHood              -- Claus Reinke's animated variant

Foreign
    Ptr
    StablePtr
    ForeignPtr  -- rename to FinalisedPtr?  to void confusion with Foreign.Ptr
    Storable
    Marshal
        Alloc
        Array
        Errors
        Utils
    C
        Types
        Errors
        Strings

GHC
    Exts                -- hslibs/lang/GlaExts
    ...

Graphics
    HGL
    Rendering
       Direct3D
       FRAN
       Metapost
       Inventor
       Haven
       OpenGL
          GL
          GLU
       Pan
    UI
       FranTk
       Fudgets
       GLUT
       Gtk
       Motif
       ObjectIO
       TkHaskell
    X11
       Xt
       Xlib
       Xmu
       Xaw

Hugs
    ...

Language
    Haskell             -- hslibs/hssource
        Syntax
        Lexer
        Parser
        Pretty
    HaskellCore
    Python
    C
    ...

Nhc
    ...

Numeric                 -- exports std. H98 numeric type classes
    Statistics

Network                 -- (== hslibs/net/Socket), depends on FFI only
    BER                 -- Basic Encoding Rules
    Socket              -- or rename to Posix?
    URI                 -- general URI parsing
    CGI                 -- one in hslibs is ok?
    Protocol
        HTTP
        FTP
        SMTP

Prelude                 -- Haskell98 Prelude (mostly just re-exports
                           other parts of the tree).

Sound                   -- Sound, Music, Digital Signal Processing
    ALSA
    JACK
    MIDI
    OpenAL
    SC3                 -- SuperCollider

System                  -- Interaction with the "system"
    Cmd                 -- ( system )
    CPUTime             -- H98
    Directory           -- H98
    Exit                -- ( ExitCode(..), exitWith, exitFailure )
    Environment         -- ( getArgs, getProgName, getEnv ... )
    Info                -- info about the host system
    IO                  -- H98 + IOExts - IOArray - IORef
        Select
        Unsafe          -- unsafePerformIO, unsafeInterleaveIO
    Console
        GetOpt
        Readline
    Locale              -- H98
    Posix
        Console
        Directory
        DynamicLinker
            Prim
            Module
        IO
        Process
        Time
    Mem                 -- rename from cryptic 'GC'
        Weak            -- (opt)
        StableName      -- (opt)
    Time                -- H98 + extensions
    Win32               -- the full win32 operating system API

Test
    HUnit
    QuickCheck

Text
    Encoding
        QuotedPrintable
        Rot13
    Read
        Lex             -- cut down lexer for "read"
    Show
        Functions       -- optional instance of Show for functions.
    Regex               -- previously RegexString
        Posix           -- Posix regular expression interface
    PrettyPrint         -- default (HughesPJ?)
        HughesPJ
        Wadler
        Chitil
        ...
    HTML                -- HTML combinator lib
    XML
        Combinators
        Parse
        Pretty
        Types
    ParserCombinators   -- no default
        ReadP           -- a more efficient "ReadS"
        Parsec
        Hutton_Meijer
        ...

Training                --  Collect study and learning materials
    <name of the tutor>
#+end_src

**** /*/
<<<Top-level module name>>>
<<<Top-level module names>>>

*** <<<Reserved word>>>
:properties:
:ID:       5d6b7d02-c0ac-436e-9691-f96eba56cbf2
:end:

Haskell has special meaning for:
#+begin_src haskell
case, class, data, deriving, do,else, if, import, in, infix, infixl,infixr, instance, let, of, module,newtype, then, type, where
#+end_src

**** /*/
<<<Reserved words>>>

**** <<<import>>> :drill:
:properties:
:ID:       3114f612-aa52-4a50-9378-c4697b0635b6
:end:

=import= statement by default imports identifiers from the other module, using hierarchical module name, brings into scope the identifiers to the global scope both into unqualified and qualifies by the hierarchical module name forms.

This possibilities can mix and match:
  * =<modName> ()= - import only instances of type classes.
  * =<modName> (x, y)= - import only declared indentifiers.
  * =qualified <modName>= - discards unqialified names, forse obligatory namespace for the imports.
  * =hiding (x, y)= - skip import of declared identifies.
  * =<modName> as <modName>= - renames module namespace.
  * =<type/class> (..)= - import class & it's methods, or type, all its data constructors & field names.

**** <<<let>>> :drill:
:properties:
:ID:       424f4e78-750c-4f67-b1f5-d76e398ca223
:end:

/*/ expression is a set of cross-recursive lazy pattern bindings.

Declarations permitted:
  * type signatures
  * function bindings
  * pattern bindings

It is an expression (macro) and that integrates in external lexical scope expression it applied in.

Form:
#+begin_src haskell
let
  b1
  bn
in
  c
#+end_src

***** /*/

<<<Let expression>>>
<<<Let expressions>>>

**** <<<where>>> :drill:
:properties:
:ID:       db6c2ddb-9fb3-4416-81d5-bac6c8fad6a6
:end:

Part of the syntax of the whole function declaration, has according scope.

As part of whole declaration - can extend over definitions of the funtion (pattern matches, guards).

Form:
#+begin_src haskell
f match1 = y
f match2 = y
f x =
  | cond1 x = y
  | cond2 x = y
  | otherwise = y
 where
  y = ... x ...
#+end_src

***** /*/

<<<Where clause>>>

*** <<<Haskell Language Report>>> :drill:
:properties:
:ID:       6f26be1d-e057-4bcf-ad63-3e404e78db1f
:end:

Document that is a standart of language.

**** /*/
<<<Report>>>
<<<Haskell Report>>>
<<<Haskell 98 Language Report>>>
<<<Haskell 98 Report>>>
<<<Haskell 1998 Language Report>>>
<<<Haskell 2010 Language Report>>>
<<<Haskell 2010 Report>>>

*** <<<Haskell'>>> :drill:
:properties:
:ID:       e13a30ca-dc6a-4fb8-8a20-2476971bd70a
:end:

Current language development mod.

https://prime.haskell.org/

**** /*/

<<<Haskell prime>>>

*** <<<Lense>>> :drill:
SCHT: <2020-10-24 Sat>
:properties:
:ID:       b8d107f0-cbf4-42cb-acb5-5d987de3c7d1
:DRILL_LAST_INTERVAL: 228.9343
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:58]
:end:

Library of combinators to provide Haskell (functional language without mutation) with the emulation of =get=-ters and =set=-ters of imperative language.

** Computer science
:properties:
:ID:       c197198c-c8c0-40ab-bfbf-f22c80f6f3b4
:end:

*** <<<Guerrilla patch>>> :drill:
SCHT: <2020-09-21 Mon>
:properties:
:ID:       500e9e31-5960-4275-a8e3-3190b3b63f8f
:DRILL_LAST_INTERVAL: 268.496
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-28 Sat 17:47]
:end:

/*/ changing code/applying patch sneakily - and possibility incompatibility with other at runtime.
Monkey patch is derivative term.

**** <<<Monkey patch>>> :drill:
SCHT: <2020-08-24 Mon>
:properties:
:ID:       8b05451a-ed92-464d-884a-654d9b5dad6a
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:16]
:end:

/From Guerrilla patch./

/*/ is a way for program to modify supporting system software affecting only the running instance of the program.

*** <<<Interface>>> :drill:
:properties:
:ID:       2ef38e57-e693-490c-af8e-f92b3c31e6b3
:end:

Point of mutual meeting. Code behind interface determines how data is consumed.

*** <<<Module>>> :drill:
:properties:
:ID:       d96e515e-8f88-413f-a12c-50bdb5f0a096
:end:

Importable organizational unit.

*** <<<Scope>>> :drill:
SCHT: <2020-03-26 Thu>
:properties:
:ID:       a2989c15-2adc-403a-add7-35855e9de65c
:DRILL_LAST_INTERVAL: 159.6473
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-18 Fri 03:25]
:end:

Area where binds are accessible.

**** <<<Dynamic scope>>> :drill:
:properties:
:ID:       477d92da-63ca-4929-b54c-aa16f6d2c71e
:end:

The name resolution depends upon the program state when the name is encountered, which is determined by the execution context or calling context.

**** <<<Lexical scope>>> :drill:
SCHT: <2020-07-07 Tue>
:properties:
:ID:       989a2a14-8faf-4edb-a1cf-c3ae3a929425
:DRILL_LAST_INTERVAL: 224.8335
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:16]
:end:

Scope bound by the structure of source code where the named entity is defined.

***** /*/

<<<Static scope>>>

**** <<<Local scope>>> :drill:
SCHT: <2020-07-28 Tue>
:properties:
:ID:       4dba73c1-5cb4-4612-b9dc-f7a05d463baa
:DRILL_LAST_INTERVAL: 241.6651
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-29 Fri 00:41]
:end:

Scope applies only in (current) area.

***** /*/

<<<Local>>>

*** <<<Shadowing>>> :drill:
SCHT: <2020-07-07 Tue>
:properties:
:ID:       45b1bebf-431f-45dd-8522-ea688968090f
:DRILL_LAST_INTERVAL: 224.8335
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:15]
:end:

When in the local scope bigger scope variable overriden by same name variable from the local scope.

*** <<<Syntatic sugar>>> :drill:
SCHT: <2020-08-23 Sun>
:properties:
:ID:       244e15a8-9ae5-4842-82b1-279387d088fd
:DRILL_LAST_INTERVAL: 267.3
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-30 Sat 02:16]
:end:

Artificial way to make language easier to read and write.

*** <<<System F>>> :drill:
SCHT: <2020-09-11 Fri>
:properties:
:ID:       a33a26ee-f5e0-4a70-b01e-dbf9b41b8681
:DRILL_LAST_INTERVAL: 185.8455
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.2
:DRILL_EASE: 2.56
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:57]
:end:

Is parametric polymorphism in programming.

Extends the Lambda calculus by introducing \( \forall \) (universal quantifier) over types.

**** /*/

<<<Girard–Reynolds polymorphic lambda calculus>>>
<<<Girard-Raynolds>>>

*** <<<Tail call>>> :drill:
SCHT: <2020-04-19 Sun>
:properties:
:ID:       0d5c9709-660d-47c7-b573-7dd06d9cb936
:DRILL_LAST_INTERVAL: 113.5462
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 12
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.334
:DRILL_EASE: 2.24
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-12-27 Fri 12:56]
:end:

Final evaluation inside the function. Produces the function result.

*** <<<Thunk>>> :drill:
:properties:
:ID:       bd66aa1b-4a01-445d-bca2-48dc193e5657
:end:

Not evaluated calculation. Can be dragged around, until be lazily evaluated.

*** <<<Application memory>>> :drill:
:properties:
:ID:       49209cb4-a094-4b16-8803-884efd701706
:end:

#+caption: Application memory structural parts
#+name: tab--application-memory-structural-parts
| Storage of                        | Block name    |
|-----------------------------------+---------------|
| All not currently processing data | <<<Heap>>>   |
| Function call, local variables    | <<<Stack>>>  |
| Static and global variables       | Static/Global |
| Instructions                      | Binary code   |

When even Main invoked - it work in Stack, and called Stack frame. Stack frame size for function calculated when it is compiled.
When stacked Stack frames exceed the Stack size - stack overflow happens.

*** <<<Turing machine>>> :drill:
:PROPERTIES:
:ID:       30386543-0e34-4d6c-8c83-34b5e919af28
:END:

Mathematical model of computation that defines abstract Turing machine. Abstract machine which manipulates symbols on a strip of tape, according to a table of rules.

**** <<<Turing complete>>>

Set of action rules that can simulate any Turing machine.

***** /*/

<<<Turing incomplete>>>
<<<Turing incompleteness>>>
<<<Turing completeness>>>
<<<Computationally universal>>>

*** <<<REPL>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       f77f5734-1b15-4192-be41-f0ee8ac15441
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:26]
:end:

Read-eval-print loop, aka interactive shell.

*** <<<Domain specific language>>> :drill:
:PROPERTIES:
:ID:       519f588a-5a5d-4426-b39f-671c2ae6f4f7
:END:

Language design/fitted for particular domain of application. Mainly should be Turing incomplete, since general-purpose language implies Turing completeness.

**** /*/

<<<Domain-specific language>>>
<<<DSL>>>

**** <<<Embedded domain specific language>>>

DSL used inside outer language.

Two levels of embedding:

  * Shallow: DSL translates into Haskell directly
  * Deep: Between DSL and Haskell there is a data structure that reflects the expression tree, AKA stores the syntax tree.

***** /*/

<<<eDSL>>>

*** <<<Data structure>>> :drill:
:properties:
:ID:       34418701-bc96-4c96-ab01-c59ec2ee5741
:end:

**** <<<Cons cell>>> :drill:
SCHT: <2020-04-19 Sun>
:properties:
:ID:       db0f5189-b0a4-4554-af3d-dae7145516c5
:DRILL_LAST_INTERVAL: 40.5335
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.18
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:01]
:end:

Cell that values may inhabit.

**** <<<Construct>>> :drill:
:properties:
:ID:       09d6089a-5e26-4a2a-b805-23941be3e63e
:end:

#+begin_src haskell
(:) :: a -> [a] -> [a]
#+end_src

***** /*/

<<<Cons>>>

**** <<<Leaf>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       8ca6b84c-9c42-4f2c-948e-39a94246ad14
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:25]
:end:

#+begin_src text
 _
#+end_src

**** <<<Node>>> :drill:
SCHT: <2020-07-26 Sun>
:properties:
:ID:       44946197-24dd-48fd-810c-6af851f6a0cf
:DRILL_LAST_INTERVAL: 213.8621
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.6
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 12:37]
:end:

#+begin_src text
 *
/ \
#+end_src

**** <<<Spine>>> :drill:
SCHT: <2020-07-07 Tue>
:properties:
:ID:       9f1c254b-a3dd-4ba5-bdec-7b43be39d49f
:DRILL_LAST_INTERVAL: 224.8335
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.8
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-25 Mon 00:16]
:end:

Is a chain of memory cells, each points to the both value of element and to the next memory cell.
#+begin_src text
Array:

  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

Spine:
  :
 / \
_   :
   / \
  _   :
     / \
    _  []

#+end_src

** <<<Graph theory>>>
:properties:
:ID:       e8c25704-bba0-40b2-8ee1-a99014ba7a9f
:end:

*** <<<Successor>>> :drill:
:properties:
:ID:       33a188ed-1cb4-435d-bae2-6065dec4dfcb
:end:

Object that recieves the arrow.

**** <<<Direct successor>>> :drill:
:properties:
:ID:       0a7e03d8-d305-4739-b44f-f4b183fdf618
:end:

Immidiate successor.

*** <<<Predecessor>>> :drill:
:properties:
:ID:       cd19ada7-93b3-4efb-829c-37325f082ff5
:end:

Object that sends arrow.

**** <<<Direct predecessor>>> :drill:
SCHT: <2020-03-15 Sun>
:properties:
:ID:       4ddb51b6-c250-4a00-9029-ed90b86ca085
:DRILL_LAST_INTERVAL: 23.5701
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.5
:DRILL_EASE: 2.46
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:24]
:end:

Immidiate predecessor.


*** <<<Degree>>> :drill:
:properties:
:ID:       51b34488-d123-4228-b806-5bb02ce0384e
:end:

Number of arrows of object.

**** <<<Indegree>>> :drill:
:properties:
:ID:       cc8a4af2-40ac-4f5c-9f1e-b057a8cb195c
:end:

Number of ingoing arrows.

**** <<<Outdegree>>> :drill:
:properties:
:ID:       44e08d7b-af1a-4d4d-a9e2-1af7165ec7c7
:end:

Number of outgoinf arrows.

*** <<<Adjacency matrix>>> :drill:
:properties:
:ID:       75984947-e25f-4385-b7db-32157e63377c
:end:

Matrix of connection of odjects ={-1,0,1}=.

***** <<<InstanceSigs>>> :drill:
:properties:
:ID:       827b53ca-20a8-4534-94e7-3ed28aaaac9c
:end:

Allow adding type signatures to type class function instance declaration.


*** <<<Strongly connected>>> :drill:
:properties:
:ID:       e505d89b-4675-48d9-98be-1bda838a069d
:end:

If every vertex in a graph is reachable from every other vertex.

It is possible to find all strongly connected components (and that way also test graph for strong connectivity), in linear time (=Θ(V+E)=).

Binary relation of being strongly connected is an equivalence relation.

**** /*/

<<<Strongly-connected>>>

**** <<<Strongly connected component>>> :drill:
:properties:
:ID:       220d953d-f39a-476d-88ed-93c1f73c846c
:end:

Full strongly connected subgraph of some graph.

/*/ of a directed graph G is a subgraph that is strongly connected, and has property: no additional edges or vertices from G can be included in the subgraph without breaking its property of being strongly connected.

***** /*/

<<<SCC>>>
<<<Strongly connected components>>>
<<<Strongly-connected component>>>
<<<Strongly-connected components>>>

** <<<Tagless-final>>> :drill:
:PROPERTIES:
:ID:       08e3d23b-a5ee-4b80-a6c8-062dad701fc2
:END:

Method of embedding eDSL in a typed functional host language (Haskell). Alternative to the embedding as a (generalized) algebraic data type. For parsers of DLS expressions: (1/partial) evaluator, compiler, pretty printer, multi-pass optimizer.

/*/ embedding is writing denotational semantics for the DSL in the host language.

Approach can be used iff eDSL is typed. Only well-typed terms become embeddable, and host language can implemen also a eDSL type system. Approach that eDSL code interpretations are type-preserving.

One of main pros of /*/ - extensibility: implementation of DSL can be used to analyze/evaluate/transform/pretty-print/compile and interpreters can be extended to more passes, optimizations, and new versions of DSL while keeping/using/reusing the old versions.

Example fields of application: language-integrated queries, non-deterministic & probabilistic programming, delimiter continuation, computability theory, stream processsing, hardware description languages, generation of specialized numerical kernels, semantics of natural language.

* Give definitions


** <<<Identity type>>>

** <<<Constant type>>>

** <<<Gen>>>


** <<<Tensorial strength>>>

** <<<Strong monad>>>

** <<<Weak head normal form>>>

*** /*/

<<<WHNF>>>

** <<<Function image>>>

*** /*/

<<<Image>>>

** <<<Invertible>>>
** <<<Invertibility>>>
** <<<Define LANGUAGE pragma options>>>

*** <<<ExistentialQuantification>>>

*** <<<GADTs>>>

GADT is a generalization over parametric algebraic data types which allow explicitly denote the types (type matching) of the constructors and define data types using pattern matching on the left side of "data" statements.

*** /*/

<<<GADT>>>
<<<Generalized algebraic data type>>>
<<<First-class phantom data type>>>
<<<Guarded recursive data type>>>
<<<Equality-qualified data type>>>

*** <<<GeneralizedNewTypeClasses>>>

*** <<<FuncitonalDependencies>>>

** <<<GHC check keys>>>

*** <<<-Wno-partial-type-signatures>>>

Supresses PartialTypeSignatures wildcard infer warning.

** <<<Generalised algebraic data types>>>

LANGUAGE GADTs

*** /*/

<<<GADT>>>

** <<<Order theory>>>

Investigates in thepth the intuitive notion of order using binary relations.

*** <<<Domain theory>>>

Formalizes approximation and convergense.
Has close relation to Topology.

*** <<<Lattice>>>

Abstract structure that consists of partially ordered set, where every two elements have unique supremum and infinum. == /*/ algebraic structure satisfying certain axiomatic identities.
/*/ order-theory & algebraic.

*** <<<Order>>>

**** <<<Preorder>>>

R^{X \to X} : Reflexive & Transitive:
\( aRa \)
\( aRb, bRc \Rightarrow aRc \)

Generalization of equivalence relations partial orders.

/*/ Antisymmetric \Rightarrow Partial ordering.
/*/ Symmetric \Rightarrow Equivalence.

***** /*/

<<<Preordered>>>

***** <<<Total preorder>>>

\( \forall a,b : a \le b \lor b \le a \) \Rightarrow Total Preorder.

**** <<<Partial order>>>

A binary relation must be reflexive, antisymmetric and transitive.

Partial - not every elempents between them need to be comparable.

Good example of /*/ is a genealogical descendancy. Only related people produce relation, not related do not.

***** /*/

<<<Partial orders>>>
<<<Partially ordered set>>>
<<<Partially ordered sets>>>
<<<Poset>>>
<<<Posets>>>

*** <<<Partial order>>>

*** <<<Total order>>>

** <<<Universal algebra>>>

Studies algebraic structures.

** <<<Relation>>>

*** <<<Reflexivity>>>

\( R^{X \to X}, \forall x \in X : x R x \)
Order theory: \( a \le a \)

/*/ - each element is comparable to itself.

Corresponds to Identity and Automorphism.

**** /*/

<<<Reflexive>>>
<<<Reflexive relation>>>

*** <<<Irreflexivity>>>

\( R^{X \to X}, \forall x \in X : \nexists R(x, x) \)

**** /*/

<<<Anti-reflexive>>>
<<<Anti-reflexive relation>>>
<<<Irreflexive>>>
<<<Irreflexive relation>>>

*** <<<Transitivity>>>

\( \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc \)

/*/ - the start of a chain of precedence relations must precede the end of the chain.

**** /*/

<<<Transitive>>>
<<<Transitive relation>>>

*** <<<Symmetry>>>

\( \forall a,b \in X : (aRb \iff bRa) \)

**** /*/

<<<Symmetric>>>
<<<Symmetric relation>>>

*** <<<Equivalence>>>

| Reflexive                  | Symmetric                        | Transitive                                      |
|----------------------------+----------------------------------+-------------------------------------------------|
| \( \forall x \in X, \exists R : x R x \) | \( \forall a,b \in X : (aRb \iff bRa) \) | \( \forall a,b,c \in X, \forall R^{X \to X} : (aRb \land bRc) \Rightarrow aRc \) |
| \( a = a \)                | \( a = b \iff b = a \)           | \( a = b, b = c \Rightarrow a = c \)                      |

**** /*/

<<<Equivalent>>>
<<<Equivalent relation>>>

*** <<<Antisymmetry>>>

\( \forall a, b \in X : aRb, bRa \Rightarrow a = b \) ~ \( aRb, a \ne b \Rightarrow \nexists bRa \).
Antisymmetry does not say anything about \( R(a,a) \).

/*/ - no two different elements precede each other.

**** /*/

<<<Antisymmetric>>>
<<<Antisymmetric relation>>>

*** <<<Asymmetry>>>

\( \forall a,b \in X (aRb \Rightarrow \neg (bRa)) \)
/*/ \( \iff \) Antisymmetric \land Irreflexive.
Asymmetry \ne "not symmetric"
Symmetric \land Asymmetric is only empty relation.

**** /*/

<<<Asymmetric>>>
<<<Asymmetric relation>>>

** <<<Cryptomorphism>>>

Equivalent, interconvertable with no loss of information.

*** /*/

<<<Crypromorphic>>>

** <<<Lexically scoped type variables>>>

Enable lexical scope for forall quantifier defined type variables

Implemented in ScopedTypeVariables

** <<<Abstract data type>>>

Several definitions here, reduce them.

Data type mathematical model, defined by its semantics from the user point of view, listing possible values, operations on the data of the type, and behaviour of these operations.

/*/ class of objects whose logical behaviour is defined by a set of values and set of operations (analogue to algebraic structure in mathematics).

A specification of a data type like a stack or queue where the specification does not contain any implementation details at all, only the operations for that data type. This can be thought of as the contract of the data type. 

*** /*/

<<<AbsDT>>>

** <<<Functional dependencies>>>

** <<<MonoLocalBinds>>>

** <<<KindSignatures>>>

** <<<ExplicitNamespaces>>>

** <<<Combinator pattern>>>

** <<<Symbolic expression>>> :drill:
SCHT: <2020-03-18 Wed>
:properties:
:ID:       62a62e62-5b76-42d5-a971-9b9d3f72ec8f
:DRILL_LAST_INTERVAL: 27.4107
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 3.455
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:48]
:end:

Nested tree data structure.

Introduced & used in Lisp. Lisp code and data are /*/.

/*/ in Lisp: Atom or expression of the form =(x . y)=, =x= and =y= are /*/.

Modern abbriviated notation of /*/: =(x y)=.

*** /*/

<<<S-expression>>>
<<<S-expressions>>>
<<<Sexpression>>>
<<<Sexpressions>>>
<<<Sexp>>>
<<<Sexps>>>
<<<Sexpr>>>
<<<Sexprs>>>

** <<<Polynomial>>> :drill:
:properties:
:ID:       2d7eeed7-766f-4261-8976-dffc939794b0
:end:

Expression consisting of:
  * variables
  * coefficients
  * addition
  * substraction
  * multiplication (including positive integer variable exponentiation)

Polynomials form a ring. Polynomial ring.

*** /*/

<<<Polynomials>>>

** <<<Data family>>>
:properties:
:ID:       a1a5a51c-bd64-41dd-8162-2bf25b9dccc4
:end:

Indexed form of data and newtype definitions.

** <<<Type synonym family>>>
:properties:
:ID:       db5fa6be-f1fc-4baa-b31b-0b7520fe2b2a
:end:

Indexed form of type synonyms.

** <<<Indexed type family>>>
:properties:
:ID:       db9d2215-e851-4257-90bb-26a03647663b
:end:

/*/ additional stucture in language that allows ad-hoc overloading of data types. AKA are to types as type class to methods.

Variaties:
  * data family
  * type synonym families

Defined by pattern matching the partial functions between types.
Associates data types by type-level function defined by open-ended collection of valid instances of input types and corresponding output types.

Normal type classes define partial functions from types to a collection of named values by pattern matching on the input types, while type families define partial functions from types to types by pattern matching on the input types. In fact, in many uses of type families there is a single type class which logically contains both values and types associated with each instance. A type family declared inside a type class is called an associated type.

*** /*/

<<<Type family>>>

** <<<TypeFamilies>>>
SCHT: <2019-07-17 Wed>
:properties:
:ID:       8bd84ba4-4ba0-4907-a19e-1312d2e4ab22
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-13 Sat 00:12]
:end:

Allow use and definition of indexed type families and data families.

/*/ are type-level programming.
/*/ are overload data types in the same way that type classes overload functions.
/*/ allow handling of dependent types. Before it Functional dependencies and GADTs were used to solve that.
/*/ useful for generic programming, creating highly parametrised interfaces for libraries, and creating interfaces with enhanced static iformation (much like dependent types).

Implies: MonoLocalBinds, KindSignatures, ExplicitNamespaces

Two types of /*/ are:

** <<<Error>>>
:properties:
:ID:       0f11555b-90c5-4374-8bb9-6e195cd2df39
:end:

Mistake in the program that can be resolved only by fixing the program.

=error= is a sugar for =undefined=.

Distinct from Exception.

*** /*/

<<<Errors>>>

** <<<Exception>>>
:properties:
:ID:       06ad9cca-a768-498c-906a-dab3ff922217
:end:

Expected but irregular situation.

Distinct from Error. Also see <<<Exception vs Error>>>

*** /*/

<<<Exceptions>>>

** <<<ConstraintKinds>>>
SCHT: <2019-07-21 Sun>
:properties:
:ID:       39b1ef68-42be-4430-b7ca-c8a1fc511622
:DRILL_LAST_INTERVAL: 3.855
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-07-17 Wed 22:59]
:end:

Constraints are just handled as types of a particular kind (Constraint).
Any type of the kind Constraints can be used as a constraint.
  * Anything which is already allowed in code as a constraint without /*/. Saturated applications to type classes, implicit parameter and equality constraints.
  * Tuples, all of whose component types have kind Constraint.
  #+begin_src haskell
  type Some a = (Show a, Ord a, Arbitrary a) -- is of kind Constraint.
  #+end_src
  * Anything form of which is not yet known, but the user has declared for it to have kind Constraint (for which they need to import it from GHC.Exts):
  #+begin_src haskell
  Foo (f :: Type -> Constraint) = forall b. f b => b -> b -- is allowed
  -- as well as examples involving type families:
  type family Typ a b :: Constraint
  type instance Typ Int  b = Show b
  type instance Typ Bool b = Num b

  func :: Typ a b => a -> b -> b
  func = ...
  #+end_src

** <<<Specialisation>>>
:properties:
:ID:       a9e7fcd2-2334-4a4d-940f-b3c20268aec6
:end:

Turns ad hoc polymorphic function into compiled type-specific inmpementations.

*** /*/

<<<Specialise>>>
<<<Specialize>>>
<<<Specialization>>>

** <<<Diagram>>>

For categories C and J, a diagram of type J in C is a covariant functor D : J → C.

** Cathegory theoretical <<<presheaf>>>

For categories C and J, a J-presheaf on C is a contravariant functor D : C → J. 

** Topological <<<presheaf>>>

If X is a topological space, then the open sets in X form a partially ordered set Open(X) under inclusion. Like every partially ordered set, Open(X) forms a small category by adding a single arrow U → V if and only if U ⊆ V. Contravariant functors on Open(X) are called presheaves on X. For instance, by assigning to every open set U the associative algebra of real-valued continuous functions on U, one obtains a presheaf of algebras on X. 

** <<<Diagonal functor>>>

The diagonal functor is defined as the functor from D to the functor category D^C which sends each object in D to the constant functor at that object.

** <<<Limit functor>>>

For a fixed index category J, if every functor J → C has a limit (for instance if C is complete), then the limit functor C^J → C assigns to each functor its limit. The existence of this functor can be proved by realizing that it is the right-adjoint to the diagonal functor and invoking the Freyd adjoint functor theorem. This requires a suitable version of the axiom of choice. Similar remarks apply to the colimit functor (which is covariant). 

** <<<Dual vector space>>>

The map which assigns to every vector space its dual space and to every linear map its dual or transpose is a contravariant functor from the category of all vector spaces over a fixed field to itself.

** <<<Fundamental group>>>

Consider the category of pointed topological spaces, i.e. topological spaces with distinguished points. The objects are pairs (X, x0), where X is a topological space and x0 is a point in X. A morphism from (X, x0) to (Y, y0) is given by a continuous map f : X → Y with f(x0) = y0.

To every topological space X with distinguished point x0, one can define the fundamental group based at x0, denoted π1(X, x0). This is the group of homotopy classes of loops based at x0. If f : X → Y is a morphism of pointed spaces, then every loop in X with base point x0 can be composed with f to yield a loop in Y with base point y0. This operation is compatible with the homotopy equivalence relation and the composition of loops, and we get a group homomorphism from π(X, x0) to π(Y, y0). We thus obtain a functor from the category of pointed topological spaces to the category of groups.

In the category of topological spaces (without distinguished point), one considers homotopy classes of generic curves, but they cannot be composed unless they share an endpoint. Thus one has the fundamental groupoid instead of the fundamental group, and this construction is functorial.

** <<<Algebra of continuous function>>>

A contravariant functor from the category of topological spaces (with continuous maps as morphisms) to the category of real associative algebras is given by assigning to every topological space X the algebra C(X) of all real-valued continuous functions on that space. Every continuous map f : X → Y induces an algebra homomorphism C(f) : C(Y) → C(X) by the rule C(f)(φ) = φ ∘ f for every φ in C(Y).

** <<<Tangent and cotangent bundle>>>

The map which sends every differentiable manifold to its tangent bundle and every smooth map to its derivative is a covariant functor from the category of differentiable manifolds to the category of vector bundles.

Doing this constructions pointwise gives the tangent space, a covariant functor from the category of pointed differentiable manifolds to the category of real vector spaces. Likewise, cotangent space is a contravariant functor, essentially the composition of the tangent space with the dual space above.

** <<<Group action / representation>>>

Every group G can be considered as a category with a single object whose morphisms are the elements of G. A functor from G to Set is then nothing but a group action of G on a particular set, i.e. a G-set. Likewise, a functor from G to the category of vector spaces, Vect_K, is a linear representation of G. In general, a functor G → C can be considered as an "action" of G on an object in the category C. If C is a group, then this action is a group homomorphism.

** <<<Lie algebra>>>

Assigning to every real (complex) Lie group its real (complex) Lie algebra defines a functor.

** <<<Tensor product>>>

If C denotes the category of vector spaces over a fixed field, with linear maps as morphisms, then the tensor product V ⊗ W defines a functor C × C → C which is covariant in both arguments.

** <<<Forgetful functor>>>

The functor U : Grp → Set which maps a group to its underlying set and a group homomorphism to its underlying function of sets is a functor.[8] Functors like these, which "forget" some structure, are termed forgetful functors. Another example is the functor Rng → Ab which maps a ring to its underlying additive abelian group. Morphisms in Rng (ring homomorphisms) become morphisms in Ab (abelian group homomorphisms).

** <<<Free functor>>>

Going in the opposite direction of forgetful functors are free functors. The free functor F : Set → Grp sends every set X to the free group generated by X. Functions get mapped to group homomorphisms between free groups. Free constructions exist for many categories based on structured sets. See free object.

** <<<Homomorphism group>>>

To every pair A, B of abelian groups one can assign the abelian group Hom(A, B) consisting of all group homomorphisms from A to B. This is a functor which is contravariant in the first and covariant in the second argument, i.e. it is a functor Abop × Ab → Ab (where Ab denotes the category of abelian groups with group homomorphisms). If f : A1 → A2 and g : B1 → B2 are morphisms in Ab, then the group homomorphism Hom(f, g): Hom(A2, B1) → Hom(A1, B2) is given by φ ↦ g ∘ φ ∘ f. See Hom functor.

** <<<Representable functor>>>

We can generalize the previous example to any category C. To every pair X, Y of objects in C one can assign the set Hom(X, Y) of morphisms from X to Y. This defines a functor to Set which is contravariant in the first argument and covariant in the second, i.e. it is a functor Cop × C → Set. If f : X1 → X2 and g : Y1 → Y2 are morphisms in C, then the group homomorphism Hom(f, g) : Hom(X2, Y1) → Hom(X1, Y2) is given by φ ↦ g ∘ φ ∘ f.

Functors like these are called representable functors. An important goal in many settings is to determine whether a given functor is representable.

** <<<Corecursion>>>
** <<<Coinduction>>>

/proper definition/

/*/ dual to induction.
Generalises to corecursion.

** <<<Initial algebra of an endofunctor>>>
** <<<Terminal coalgebra for an endofunctor>>>
* Citations

"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))

* Good code :drill:
:properties:
:ID:       0061ec53-dc1b-40a8-a00a-f07fd4213be2
:end:

** <<<Good: Type aliasing>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       db5d6252-f9b1-4c2e-ab00-a4a99d026c2a
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:54]
:end:

Use data type aliases to deferentiate logic of values.

** <<<Good: Type wideness>>> :drill:
SCHT: <2020-02-17 Mon>
:properties:
:ID:       f84197b4-6d5d-4f8f-bb4d-3c6a1460a37b
:DRILL_LAST_INTERVAL: 127.433
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.32
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2019-10-13 Sun 02:00]
:end:

Wider the type the more it is polymorphic, means it has broader application and fits more types.

The more constrained system has more usefulness.

Unconstrained means most flexible, but also most useless.

** <<<Good: Print>>> :drill:
SCHT: <2020-10-24 Sat>
:properties:
:ID:       1d0f6f0e-2d81-4c35-a9b3-a362557121f2
:DRILL_LAST_INTERVAL: 228.9343
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.167
:DRILL_EASE: 2.76
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:59]
:end:

#+begin_src haskell
print :: Show a => a -> IO ()
print a = putStrLn (show a)
#+end_src

** <<<Good: Fold>>> :drill:
SCHT: <2020-03-19 Thu>
:properties:
:ID:       e646277c-54f3-47c4-b721-b3721acc6a6f
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.667
:DRILL_EASE: 2.7
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:24]
:end:

=foldr= spine recursion intermediated by the folding. Can terminate at any point.
=foldl= spine recursion is unconditional, then folding starts. Unconditionally recurses across the whole spine, if it infinite - infinitely.

** <<<Good: Computation model>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       a6b88a42-c287-47ae-9db0-f7c2aa0d0cd3
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.5
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:51]
:end:

Model the domain and types before thinking about how to write computations.

** <<<Good: Make bottoms only local>>> :drill:
:properties:
:ID:       8d96eb06-0984-4325-a447-4e751ff820e0
:end:

** <<<Good: Newtype wrap is ideally transparent for compiler and does not change performance>>> :drill:
:properties:
:ID:       0a8b1bec-1a25-42e0-b137-232fb01b25d7
:end:

** <<<Good: Instances of types/type classes must go with code you write>>> :drill:
:properties:
:ID:       2bafb381-43ce-44b0-9abf-ffa1f3f0c6e1
:end:

** <<<Good: Functions can be abstracted as arguments>>> :drill:
:properties:
:ID:       714c9ca5-052c-4c5b-b3c6-fcd7741250b0
:end:

** <<<Good: Infix operators can be bind to arguments>>> :drill:
:properties:
:ID:       defb1467-4b50-451b-8fb3-ab12af4409af
:end:

** <<<Good: Arbitrary>>> :drill:
SCHT: <2020-05-18 Mon>
:properties:
:ID:       7c3cb682-9b20-471b-9483-7a22c3ec468d
:DRILL_LAST_INTERVAL: 87.1562
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 11
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 3.727
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:10]
:end:

Product types can be tested as a product of random generators.
Sum types require to implement generators with separate constructors, and picking one of them, use =oneof= or =frequency= to pick generators.

** <<<Good: Principle of Separation of concerns>>> :drill:
:properties:
:ID:       a07f55f7-1a15-4aa9-b8c8-fb58149924d7
:end:

** <<<Good: Function composition>>> :drill:
:properties:
:ID:       ade1516e-44f1-4a8e-bfe4-5b773d0f27d6
:end:

In Haskell inline composition requires:
#+begin_src haskell
h.g.f $ i
#+end_src

Function application has a higher priority than composition. That is why parentheses over argument are needed.
This precedence allows idiomatically compose partially applied functions.

But it is a way better then:
#+begin_src haskell
h (g (f i))
#+end_src

** <<<Good: Point-free>>> :drill:
SCHT: <2020-03-22 Sun>
:properties:
:ID:       62f8356a-69a2-46e9-ab0f-1a9b5bdfe797
:DRILL_LAST_INTERVAL: 30.8887
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.8
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:25]
:end:

Use Tacit very carefully - it hides types and harder to change code where it is used.
Use just enough Tacit to communicate a bit better. Mostly only partial point-free communicates better.

*** <<<Good: Point-free is great in multi-dimentions>>> :drill:
SCHT: <2020-10-07 Wed>
:properties:
:ID:       0eb49ad1-9992-4707-88c8-64ff7f8c3cbb
:DRILL_LAST_INTERVAL: 267.3
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-01-14 Tue 14:00]
:end:

BigData and OLAP analysis.

** <<<Good: Functor application>>> :drill:
SCHT: <2020-09-18 Fri>
:properties:
:ID:       67dab545-6f12-4d3a-b8c7-acfc0f267d03
:DRILL_LAST_INTERVAL: 268.457
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 5
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 3.0
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-12-25 Wed 18:53]
:end:

Function application on n levels beneath:
#+begin_src haskell
(fmap . fmap) function twoLevelStructure
#+end_src

How =fmap . fmap= typechecks:
#+begin_src haskell
(.)         :: (b -> c) -> (a -> b) -> a -> c
fmap        :: Functor f => (m -> n) -> f m -> f n
fmap        :: Functor g => (x -> y) -> g x -> g y

fmap . fmap :: (Functor f, Functor g)
              => ((g x -> g y) -> f . g x -> f . g y)
              -> ((  x ->   y) ->     g x  ->    g y)
              -> (   x ->   y) -> f . g x -> f . g y
fmap . fmap ::   (x    ->   y) -> f . g x -> f . g y
#+end_src

** <<<Good: Parameter order>>> :drill:
:properties:
:ID:       05494702-c932-47ef-a91b-6ffd27a6b51f
:end:

In functions parameter order is important.
It is best to use first the most reusable parameters.
And as last one the one that can be the most variable, that is important to chain.

** <<<Good: Applicative monoid>>> :drill:
:properties:
:ID:       e417b5f0-fc63-45e0-971a-68b2c6ae4d22
:end:

There can be more than one valid Monoid for a data type. &&
There can be more than one valid Applicative instance for a data type. ->
There can be differnt Applicatives with different Monoid implementations.

** <<<Good: Creative process>>> :drill:
:properties:
:ID:       b5b69b79-144b-49f0-a997-ed7c056e182b
:end:

*** Pick phylosophy principles one to three the more - the harder the implementation

*** Draw the most blurred representation

*** Deduce abstractions and write remotely what they are

*** Model of computation

**** Model the domain

**** Model the types

**** Think how to write computations

*** Create

** <<<Good: About operators =(<$ )= =( **>)= =(<* )= =(>> )= >>> :drill:
SCHT: <2020-03-26 Thu>
:properties:
:ID:       25e19a69-21f7-435a-b2ff-f1a489e9a159
:DRILL_LAST_INTERVAL: 34.5423
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 9
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.556
:DRILL_EASE: 2.14
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:32]
:end:

Where character is not present - discard the according processing of a parameter.
=(>> )= is an exception, it does the reverse. ignores the first parameter.

*** <<<= *>=>>> :drill:
SCHT: <2020-03-13 Fri>
:properties:
:ID:       52ea3b25-cfae-4a95-9703-6baa39159536
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:10]
:end:

Do calculation, but ignore the value from the first argument.

\( *> \ \equiv \ >> \)

** <<<Good: About functions like {mapM, sequence}_>>> :drill:
SCHT: <2020-08-09 Sun>
:properties:
:ID:       03ad3fac-221c-42de-8b63-e7ccf645f183
:DRILL_LAST_INTERVAL: 170.0329
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.833
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:14]
:end:

Trailing =_= means ignoring the result.

** <<<Good: Guideliles>>> :drill:
:properties:
:ID:       30bdcb7b-27f5-4d34-993d-d4a710d41969
:end:

*** Wiki.haskell

**** Documentation

***** Comments write in application terms, not technical.

***** Tell what code needs to do not how it does.

**** Haddoc

***** Put haddock comments to ever exposed data type and function.

***** Haddock header
#+begin_src haskell
{- |
Module      :  <File name or $Header$ to be replaced automatically>
Description :  <optional short text displayed on contents page>
Copyright   :  (c) <Authors or Affiliations>
License     :  <license>

Maintainer  :  <email>
Stability   :  unstable | experimental | provisional | stable | frozen
Portability :  portable | non-portable (<reason>)

<module description starting at first column>
-}
#+end_src

**** Code

***** Try to stay closer to portable (Haskell98) code

***** Try make lines no longer 80 chars

***** Last char in file should be newline

***** Symbolic infix identifiers is only library writer right

***** Every function does one thing.

** <<<Good: Use Typed holes to progress the code>>> :drill:
SCHT: <2020-02-22 Sat>
:properties:
:ID:       27c029f7-9299-4d74-b2e3-5064b57dce4a
:DRILL_LAST_INTERVAL: 89.9157
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.9
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2019-11-24 Sun 02:33]
:end:

Typed holes help build code in complex situations.

** <<<Good: Haskell allows infinite terms but not infinite types>>> :drill:
SCHT: <2020-04-19 Sun>
:properties:
:ID:       6299a8fe-2bb5-4d63-94a6-4aa8561027ad
:DRILL_LAST_INTERVAL: 59.4154
:DRILL_REPEATS_SINCE_FAIL: 5
:DRILL_TOTAL_REPEATS: 8
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.876
:DRILL_EASE: 2.52
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 22:37]
:end:

That is why infinite types throw infinite type error.

** <<<Good: Use type sysnonims to differ the information>>> :drill:
SCHT: <2020-05-13 Wed>
:properties:
:ID:       43181c5d-630a-4b5d-815c-272e26c8e42f
:DRILL_LAST_INTERVAL: 182.0624
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.66
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2019-11-13 Wed 19:27]
:end:

Even if there is types - define type synonims. They are free.
That distinction with synonims, would allow TypeSynonymInstances, which would allow to create a diffrent type class instances and behaviour for different information.

** <<<Good: Control.Monad.Error -> Control.Monad.Except>>> :drill:
:properties:
:ID:       4ba41ec2-5115-4be9-9aa4-4892322db1e8
:end:

** <<<Good: Monad OR Applicative>>>

**** Start writing monad using 'return', 'ap', 'liftM', 'liftM2', '>>' instead of 'do','>>='

If you wrote code and really needed only those - move that code to Applicative.
#+begin_src haskell
return -> pure
ap -> <*>
liftM -> liftA -> <$>
>> -> *>
#+end_src

**** Basic case when Applicative can be used

Can be rewriten in Applicative:
#+begin_src haskell
func = do
  a <- f
  b <- g
pure (a, b)
#+end_src

Can't be rewritten in Applicative:
#+begin_src haskell
somethingdoSomething' n = do
a <- f n
b <- g a
pure (a, b)
#+end_src
(f n) creates monadic structure, binds ot to /a/ wich is consumed then by g.

**** Applicative block vs Monad block

With Type Applicative every condition fails/succseeds independently. It needs a boilerplate data constructor/value pattern matching code to work. And code you can write only for so many cases and types, so boilerplate can not be so flexible as Monad that allows polymorphism.
With Type Monad computation can return value that dependent from the previous computation result. So abort or dependent processing can happen.

** <<<Good: Haskell Package Versioning Policy>>>

Version policy and dependency management.

#+downloaded: https://pvp.haskell.org/pvp-decision-tree.svg @ 2019-06-17 15:49:21
[[file:Good_code/pvp-decision-tree_2019-06-17_15-49-21.svg]]

*** /*/

<<<PVP>>>
<<<Good: PVP>>>

** <<<Good: Linear type>>> :drill:
:properties:
:ID:       820c915d-e3fe-4ff5-acb3-9ef205f70639
:end:
Linear types are great to control/minimize resource usage.

** <<<Good: Exception vs Error>>> :drill:
:properties:
:ID:       3d6d7f0f-252c-4cfb-b25c-18687fd762ca
:end:

Many languages and Haskell have it all mixup. Here is table showing what belongs to one or other in standard libraries:

|-----------+---------------------------------------------------------------------------------------------|
| Exception | Prelude.catch, Control.Exception.catch, Control.Exception.try, IOError, Control.Monad.Error |
| Error     | error, assert, Control.Exception.catch, Debug.Trace.trace                                   |

** <<<Good: Let vs. Where>>> :drill:
:properties:
:ID:       4ded4b6f-3593-4203-88a6-ce1b6f5fa71e
:end:

=let ... in ...= is a separate expression. In contrast, =where= is bound to a surrounding syntactic construct (namespace).

** <<<Good: RankNTypes>>> :drill:
:properties:
:ID:       f13bc2c3-be6c-4bde-96c9-09c9447a1c94
:end:

Can powerfully synergyze with ScopedTypeVariables.

** <<<Good: Orphan type instance>>> :drill:
:properties:
:ID:       8fb7360d-a105-4827-bba0-232e89c3558d
:end:

Practice to address orphan instances:

Does type class or type defined by you:
| Type class | Type | Recommendation                                     |
|------------+------+----------------------------------------------------|
|            | \check    | {Type, instance} in the same module             |
| \check          |      | {Typeclass & instance} in the same module          |
|            |      | {Define newtype wrap, its instances} in the same module |

** <<<Good: Smart constructor>>> :drill:
:properties:
:ID:       068296b6-24b3-4694-bb2c-4229584d150f
:end:

Only proper smart constructors should be exported. Do not export data type constructor, only a type.

** <<<Good: Thin category>>> :drill:
:properties:
:ID:       8e9abcba-09fa-465b-90a1-b93c3941ec93
:end:

In /*/ all morphisms are epimorphisms and monomorphisms.

** <<<Good: Recursion>>> :drill:
:properties:
:ID:       ec8407dd-2c5f-4fef-9e8e-99a4a45a44b4
:end:

Writing/thinking about recursion:

  1. Find the base cases, om imput of which the answer can be provided right away. There is mosly one base case, but sometimes there can be several of them. Typical base cases are: zero, the empty list, the empty tree, null, etc.
  2. Do inductive case. The recursive invocation. The argument of a recursive call needs to be smaller then the current argument. So it would be gradually closer to the base case. The idea is that processes eventually hits the base case.

Simple functional application is used in the recursion.
Assume that the functions would return the right result.


** <<<Good: Monoid>>> :drill:
:properties:
:ID:       fcafc131-d995-4712-8fa7-35ea6668cd27
:end:

=<>=:
Sets - union.
Maps - left-biased union.
Number - =Sum=, =Product= form separate monoid categories.

** <<<Good: Free monad>>> :drill:
SCHT: <2020-03-30 Mon>
:properties:
:ID:       e5c45f71-de00-48fb-bb31-a65a2893abdc
:DRILL_LAST_INTERVAL: 21.1996
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.22
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 13:07]
:end:

The main case of usage of Free monads in Haskell:

Start implementation of the monad from a Free monad, drafting the base monadic operations, then add custom operations.

Gradually build on top of Free monad and try to find homomorphisms from monad to objects, and if only objects are needed - get rid of the free monad.

** <<<Good: Use mostly where clauses>>> :drill:
:properties:
:ID:       08aaf74e-7f08-4422-9750-5548dcf4d4df
:end:

** <<<Good: Where clause is in a scope with function parameters>>> :drill:
:properties:
:ID:       80f5570c-7c7b-425c-bfc6-de236bcfe567
:end:

** <<<Good: Strong preference towards pattern matching over {head, tail, etc.} functions>>> :drill:
:properties:
:ID:       bbe1acaf-7bda-4b47-b595-dff92f011b46
:end:

=head= and =tail= and alike functions are often partial (unsafe) funcitons.

** <<<Good: Patternmatching is possible on monadic bind in do>>> :drill:
:properties:
:ID:       b9a31f63-ff7b-4d56-bae5-96c5eabbd038
:end:

Example:
#+begin_src haskell
instance (Monad m) => Functor (StateT s m) where
	fmap f m = StateT $ \s -> do
		(x, s') <- runStateT m s  -- Here is a pattern matching bind
		return (f x, s')
#+end_src
** <<<Good: Applicative vs Monad>>> :drill:
:properties:
:ID:       0b5589bb-1426-434d-a018-69a9cd29731e
:end:

Giving not =Monad= but =Applicative= requirement allows parralel computation, but if there should be a chaining of the intemidiate state - it must be monadic.

** <<<Good: StateT, ReaderT, WriterT>>> :drill:
:properties:
:ID:       dcfdc4bf-88cb-4310-b40b-3c3d68aff3db
:end:

=Reader= trait: =(r ->)=.

=Writer= trait: =(a, w)=.

=State= trait is combination of both:
#+begin_src haskell
newtype StateT s m a =
  StateT  { runStateT  :: s -> m (a, s) }

newtype ReaderT r m a =
  ReaderT { runReaderT :: r -> m   a    }

newtype WriterT w m a =
  WriterT { runWriterT ::     m (a, w) }
#+end_src

=State= trait fully replaces =writer=.

** <<<Good: Working with MonadTrans and lift>>> :drill:
:properties:
:ID:       052f4701-8343-4b6c-af42-b45818a00595
:end:

From the =lift . pure = pure= follows that =MonadTrans= type can have a =pure= defined with =lift=.

Stacking of =MonadTrans= monads can result in a lot of chained =lift= and unwraps. There is many ways to cope with that but the most robust and common is to abstract representation with =newtype= on the =Monad= stack. This can reduce caining or remove the manual lifting withing the Monad.
For perfect combination for contributors to be able to extend the code - keep the =Internal= module that has a raw representation.

** <<<Good: Don't mix Where and Let>>> :drill:
:properties:
:ID:       0287a360-05cd-41a3-b744-2ec5af34be6a
:end:

=let= and =where= create a recursive set of definitions with can explode, don't mix them togather in code.

** <<<Good: Where vs. Let>>> :drill:
:properties:
:ID:       6318ed75-8584-4f73-8ef8-6708521a7cd9
:end:

Let is self-recursive lazy pattern. It is checked and errors only at execution time. Binds only inside expression it is binded to.

Where is a part of definition, scoped over definition implemetations and guards, not self-recursive.

** <<<Good: The proper nature algorithm that models behaviour of many objects is computation heavy>>> :drill:
:properties:
:ID:       9ed1a3db-196a-4994-bf3f-372880a9cc72
:end:

#+begin_quote
God does not care about our mathematical difficulties. He integrates empirically.
#+end_quote

One who is found of mathematical meaning loves to apply it. But if we implement the "real" algorithms behind nature processes, we face the need to go through the computations of laws of all particles.

Computation of nature is always a middle way between ideal theory behaviour and computation simplification.

** <<<Good: In Haskell parameters bound by lambda declaration instantiate to only one concrete type>>> 
:properties:
:ID:       25061918-c9bb-42b8-a7a5-13e109f44c53
:end:

Because of let-bound polymorphism:

This is illegal in Haskell:
#+begin_src haskell
foo :: (Int, Char)
foo = (\f -> (f 1, f 'a')) id
#+end_src

Lambda-bound function (i.e., one passed as argument to another function) cannot be instantiated in two different ways, if there is a let-bound polymorphism.


** <<<Good: Instance is a good structure to drew a type line>>>

Instances for data type can differentiate by constraints & types of arguments. So instance can preserve type boundary, and data type declaration can stay very polymorphic. If the need to extend the type boundaries arrive - the instances may extend, or new instances are created, while used data type still the same and unchanged.

** <<<Good: MTL vs. Transformers>>> :drill:
:PROPERTIES:
:ID:       e0994280-e18b-4b6a-afde-b2a8748aebb9
:END:

Default ot =mtl=.

=Transformers= is Haskell-98, doesn't have funcitonal dependencies, lacks the monad classes, has manual lift of operations to the composite monad.

=MTL= extends =trasformers=, providing more instances, features and possibilities, may include alternative packages features as =mtl-tf=.

* Bad code :drill:
:properties:
:ID:       e60a3084-2f70-4363-8f47-6df2e610d4ad
:end:

** <<<Bad pragma>>>

*** Bad: Dangerous LANGUAGE pragma option

  - DatatypeContexts
  - OverlappingInstances
  - IncoherentInstances
  - ImpredicativeTypes
  - AllowAmbigiousTypes
  - UndecidableInstances - often

* Useful functions to remember

** Prelude
#+begin_src haskell
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
#+end_src

*** Ord
compare

*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo

*** List operations
#+begin_src haskell
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
#+end_src

** Data.List
#+begin_src haskell
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
#+end_src

** Data.Char
#+begin_src haskell
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
#+end_src

** QuickCheck
#+begin_src haskell
quickCheck :: Testable prop => prop -> IO ()

quickCheck . verbose - run verbose mode
#+end_src

* Tools :drill:
:properties:
:ID:       756dd451-6df6-4c86-8ff8-b431f2943685
:end:

** ghc-pkg

List installed packages:
#+begin_src fish
ghc-pkg list
#+end_src

** Search over the Haskell packages code: Codesearch from Aelve
https://codesearch.aelve.com/

** Integration of NixOS/Nix with Haskell IDE Engine (HIE) and Emacs (Spacemacs)
:properties:
:ID:       cd7eefc7-9fed-4ea0-8273-17ef478265f2
:end:

*** 1. Install the Cachix

Upstream doc: https://github.com/cachix/cachix

*** 2. Installation of HIE

Upstream doc: https://github.com/infinisil/all-hies/#cached-builds

**** 2.1. Provide cached builds

#+begin_src fish
cachix use all-hies
#+end_src

**** 2.2.a. Installation on NixOS distribution:

#+begin_src nix
{ config, pkgs, ... }:

let

  all-hies = import (fetchTarball "https://github.com/infinisil/all-hies/tarball/master") {};

in {
  environment.systemPackages = with pkgs; [

    (all-hies.selection { selector = p: { inherit (p) ghc865 ghc864; }; })

  ];
}
#+end_src

Insert your GHC versions.

Switch to new configuration:

#+begin_src fish
sudo -i nixos-rebuild switch
#+end_src

**** 2.2.b. Installation with Nix package manager:

#+begin_src fish
nix-env -iA selection --arg selector 'p: { inherit (p) ghc865 ghc864; }' -f 'https://github.com/infinisil/all-hies/tarball/master'
#+end_src

Insert your GHC versions.

*** 3. Emacs (Spacemacs) configuration:

#+begin_src elisp

  dotspacemacs-configuration-layers
  '(

    auto-completion

    (lsp :variables
         default-nix-wrapper (lambda (args)
                               (append
                                (append (list "nix-shell" "-I" "." "--command" )
                                        (list (mapconcat 'identity args " "))
                                        )
                                (list (nix-current-sandbox))
                                )
                               )

         lsp-haskell-process-wrapper-function default-nix-wrapper
         )

    (haskell :variables
             haskell-enable-hindent t
             haskell-completion-backend 'lsp
             haskell-process-type 'cabal-new-repl
             )

  )

   dotspacemacs-additional-packages '(
                                      direnv
                                      nix-sandbox
                                      )

(defun dotspacemacs/user-config ()

  (add-hook 'haskell-mode-hook 'direnv-update-environment) ;; If direnv configured

  )
#+end_src

Where:

=auto-complettion= configures =YASnippet=.

=nix-sandbox= (https://github.com/travisbhartwell/nix-emacs) has a great helper functions. Using =nix-current-sandbox= function in =default-nix-wrapper= that used to properly configure =lsp-haskell-process-wrapper-function=.

Configuration of the =lsp-haskell-process-wrapper-function default-nix-wrapper= is a key for HIE to work in =nix-shell=

Inside =nix-shell= the =haskell-process-type 'cabal-new-repl= is required.

/Configuration was reassembled from: [[https://github.com/emacs-lsp/lsp-haskell/blob/8f2dbb6e827b1adce6360c56f795f29ecff1d7f6/lsp-haskell.el#L57]] & its authors config: [[https://github.com/sevanspowell/dotfiles/blob/master/.spacemacs]]/

Refresh Emasc.

*** 4. Open the Haskell file from a project

Open system monitor, observe the process of environment establishing, packages loading & compiling.

*** 5. Be pleased writing code

[[file:images/Screenshot_20190727_134446.png]]

Now, the powers of the Haskell, Nix & Emacs combined. It's fully in your hands now. Be cautious - you can change the world.

*** 6. (optional) Debugging

1. If recieving sort-of:

#+begin_src text
readCreateProcess : cabal-helper-wrapper failure
#+end_src

HIE tries to run =cabal= operations like on the non-Nix system. So it is a problem with detection of =nix-shell= environment, running inside it.

2. If HIE keeps getting ready, failing & restarting - check that the projects =ghc --version= is declared in your =all-hie= NixOS configuration.

** Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

Breakpoints
#+begin_src text
:break 2
  :show breaks
  :delete 0
:continue
#+end_src

Step-by-step
#+begin_src text
:step main
#+end_src

List information at the breakpoint
#+begin_src text
:list
#+end_src

What been evaluated already
#+begin_src text
:sprint name
#+end_src

** <<<GHCID>>>

Commands to run the compile/check loop:

=cabal= > =3.0= command:
#+begin_src fish
ghcid --command='cabal v2-repl --repl-options=-fno-code --repl-options=-fno-break-on-exception --repl-options=-fno-break-on-error --repl-options=-v1 --repl-options=-ferror-spans --repl-options=-j'
#+end_src

=cabal= < =3.0= command:
#+begin_src fish
ghcid --command='cabal new-repl --ghc-options=-fno-code --ghc-options=-fno-break-on-exception --ghc-options=-fno-break-on-error --ghc-options=-v1 --ghc-options=-ferror-spans --ghc-options=-j'
#+end_src

=nix-shell= =cabal= > =3.0= command:
#+begin_src fish
nix-shell --command 'ghcid --command="cabal v2-repl --repl-options=-fno-code --repl-options=-fno-break-on-exception --repl-options=-fno-break-on-error --repl-options=-v1 --repl-options=-ferror-spans --repl-options=-j" '
#+end_src

=nix-shell= =cabal= < =3.0= command:
#+begin_src fish
nix-shell --command 'ghcid --command="cabal new-repl --ghc-options=-fno-code --ghc-options=-fno-break-on-exception --ghc-options=-fno-break-on-error --ghc-options=-v1 --ghc-options=-ferror-spans --ghc-options=-j" '

#+end_src

** Continuous integration platrorms (CIs) for Open Source Haskell projets

Since Open Source projects mostly use free tiers of CIs, and different CIs have different features - there is a constant flux of how to construct the best possible integration pipeline for Haskell projects.

The current state of affairs is best put in this quote:
#+html: <caption class="t-above"><span class="quote-number">Quote: </span><a href="https://github.com/dhall-lang/dhall-haskell/issues/1678#issuecomment-592960057">2020-02-29: Gabriel Gonzalez about CIs for Haskell Opens Source projects</a></caption>
#+latex: \caption{\href{https://github.com/dhall-lang/dhall-haskell/issues/1678#issuecomment-592960057}{Quote: 2020-02-29: Gabriel Gonzalez about CIs for Haskell Opens Source projects}}
#+caption: [[https://github.com/dhall-lang/dhall-haskell/issues/1678#issuecomment-592960057][2020-02-29: Gabriel Gonzalez about CIs for Haskell Opens Source projects]]
#+name: quote--gonzales-ci
#+begin_quote
Probably the biggest constraint is whether or not CI needs to test Windows or OS X, since build machines for those are harder to come by. We currently use AppVeyor for Windows builds and Travis for OS X builds since they are free. For Linux you can basically use any CI provider, but in this case I pay for a Linode VM which I use to host all Dhall-related infrastructure (i.e. all of the *.dhall-lang.org domains), so I reuse that to host Hydra for Nix-related CI so that I can use more parallelism and more efficient caching to test a wider range of GHC versions on a budget.

For testing OS X and Windows platforms we use stack. The main reason we don't use Nix for either platform is that Nix only supports building release binaries on Linux (and even then it's still experimental).

So the basic summary I can give is:

    For testing everything other than cross-platform support: Nix + Linux is best in my opinion

    ... because you get much more control and intelligent build caching, which is usually where most CI solutions fall short

    For cross-platform support: stack + whatever CI provider provides free builds for that platform

Also, if you ever can pay for your own NixOS VM and you want to reuse the setup I built, you can find the NixOS configuration for dhall-lang.org here:

https://github.com/dhall-lang/dhall-lang/tree/master/nixops
#+end_quote

* Libs :drill:
:properties:
:ID:       dfc5ca16-c4ee-4ef5-bee6-b44a4b29f51d
:end:

** Exceptions

*** Exceptions - optionally pure extensible exceptions that are compatible with the mtl
*** Safe-exceptions - safe, simple API equivalent to the underlying implementation in terms of power, encourages best practices minimizing the chances of getting the exception handling wrong. 
*** Enclosed-exceptions - capture exceptions from the enclosed computation, while reacting to asynchronous exceptions aimed at the calling thread.

** Memory management

*** membrain - type-safe memory units

** Parsers - megaparsec

** CLIs - optparse-applicative

** HTML - Lucid

** Web applications - Servant

** IO libraries

*** Conduit - practical, monolythic, guarantees termination return

*** Pipes + Pipes Parse - modular, more primitive, theoretically driven

** JSON - aeson

** <<<Backpack>>> :drill:
SCHT: <2020-03-19 Thu>
:properties:
:ID:       bb77bcce-6d34-408e-bbc8-ad16e843eeb1
:DRILL_LAST_INTERVAL: 27.8572
:DRILL_REPEATS_SINCE_FAIL: 4
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.333
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-02-20 Thu 23:25]
:end:

On 1-st compilation - /*/ analyzes the abstract signatures without loading side modules, doing the type check with assumption that modules provide right type signatures, the process does not emitt any binary code and stores the intermediate code in a special form that allows flexibily connect modules provided. Which allows later to compile project with particular instanciations of the modules. Major work of this process being done by internal Cabal /*/ support and /*/ system that modifies the intermediate code to fit the module.

* Drafts

** Exception handling

Exception must include all context information that may be useful.
Store information in a form for further probable deeper automatic diagnostic.
Sensitive data/dummies for it - can be useful during development.
Sensitive data should be stripped from a program logging & exceptions.
Exception system should be extendable, data storage & representation should be easily extendable.
Exception system should allow easy exaustive checking of errors, since the different errors can happen.
Exception system should be automatically well-documented and transparent.
Exception system should have controllable breaking changes downstream.
Exception system should allow complex composite (sets) exceptions.
Exception system should be lightweight on the type signatures of other functions.
Exception system should automate the collection of context for a exception.
Exception system should have properties and according functions for particular types of errors.

=String= is simple and convinient to throw exception, but really a mistake because it the most cumbersome choise:
  + Any Exception instance can be converted to a =String= with either =show= or =displayException.=
  - Does not include key debugging information in the error message.
  - Does not allow developer to access/manage the Exception information.
  - Exception messages need to be constructed ahead of time, it can not be internationalized, converted to some data/file format.
  - Exception can have a sensitive information that can be useful for developer during work, but should not be logged/shown to end-user. Stripping it from =Strings= in the changing project is a hard task.
  - Impossible to rely on this representation for further/deeper inspection.
  - Impossible to have exhaustive checking - no knowledge no check, no warning if some cases are not handled.

Universal exception type:
  + Able to inspect every possible error case with pattern match.
  + Self-documenting. Shows the hierarchical system of all exceptions.
  + Transparent. Ability to discern in current situation what exceptions can happen
  - New exception constructor causes breaking change to downstream.
  - Wrongly implies completeness. Untreated Errors can happen, different exception can arrive from the outside code.

Sum type must be separate, and product type structure over it.
Separate exception type of 

Individual exception types:
  + Writing & seing & working with exactly what will go wrong because there is only one possible error for this type of exception. Pattern match happens only onconditions, constructors that should happen.
  + Knowledge what exectly goes wrong allows wide usage of Either.
  - It is hard to handle complex exceptions in the unitary system. Real wrorld can return not a particular case, but a set of cases {object not found, path is unreachable, access is denied}.
  - Type signatures grow, and even can become complex, since every case of exception has its own type.
  - Impure =throw= that users can/should use for your code must account for all your exception types.

Abstract exception type:
Exception type entirely opague and inspectable only by accessor functions.
  + Updating the internals without breaking the API
  + Semi-automates the context of exception with passing it to accessors.
  + Predicates can be applied to more than one constructor. Which are properties that allows to make complex exceptions much easier to handle.
  - Not self-documenting.
  - Possible options by design are hidden from the downstream, documentation must be kept.
  - When you change the exception handling/throwing errors it does not shows to the downstream.

Composit approach:
Provide the set of constructors and also a set of predicates and set of accessors.
Use pattern synonyms to provide a documented accessor set without exposing internal data type.

In GHC 8.8 the change was made:
#+begin_quote
The fail method of Monad has been removed in favor of the method of the same name in the MonadFail class.

MonadFail(..) is now exported from the Prelude and Control.Monad modules.
The MonadFailDesugaring language extension is now deprecated, as its effects are
always enabled.
#+end_quote

So:
#+begin_src haskell
import           Control.Monad.Fail
...
class MonadFail m => MonadFile m
...
-- use error instead of fail
Nothing     -> error ("Message " <> show x)
#+end_src

** Constraints

Very strong Haskell type system makes possible to work with code from the top down, an axiomatic semantics approach, from constraints into types.

+ Helps to form the type level code (aka join points of the code).
+ Uses the piling up of constraints/types information. At some point pick and satisfy constraints, can be done one at a time.
- Provides hints through type level formulation for term level calculations, does not formulate the term level.
- Tedious method (a lot of boilerplate and rewriting it) but pretty simple and relaxing.

1. Set of constraints.

2. When it is needed or convenient, single constraint gets a little more realistically concrete/abstracted.

Main type detail annotation thread can happen in =main= or special wrapper function, localization is inside functions.

3. Rest of constraints set shifts to source type.

3.a. For the class handled or known how to handle - writte a base case instance description.

#+begin_src haskell
instance (Monad m) => MonadReader r (ReaderT r m)
#+end_src

3.b. For others write recursive instance descriptions:

All other unsolved constraints move into the source polymorphic variable.

#+begin_src haskell
instance (MonadError e m) => MonadError e (ReaderT r m)
instance (MonadState s m) => MonadState s (ReaderT r m)
#+end_src

4. Repeat from 1 until considered done.

5. Code condensed into terse form.

=MonadError= constraints is =IOException=, not for the =String=. =IOException= vs =String=.

Reverse pluck =MonadReader= constraint with =runReader= on the object.

=MonadState= - =StateT=

** Monad transformers and their type classes

** Layering monad transformers

Different layering of the same monad transformers is functionality is the same, but the form is different. Surrounding handling functions would need to be different. 

** Hoogle

*** Search

Text search (case insensitive):
  * =a=
  * =map=
  * =con map=

Type search:
  * =:: a=
  * =:: a -> a=

Text & type:
  * =id :: a -> a=

*** Scope

**** Default

Scope is [[http://hackage.haskell.org/platform][Haskell Platform]] (and [[http://haskell.org/haskellwiki/Keywords][Haskell keywords)]].

All [[http://hackage.haskell.org/][Hackage]] packages are available to search with:

**** Hierarchical module name system (from big letter):

  * =fold +Data.Map= finds results in the =Data.Map= module
  * =file -System= excludes results from modules such as =System.IO=, =System.FilePath.Windows= and =Distribution.System=

**** Packages (lower case):
  * =mode +platform=
  * =mode +cmdargs= (only)
  * =mode +platform +cmdargs=
  * =file -base= (Haskell Platform, excluding the "base" package)

** <<<ST-Trick monad>>>

ST is like a lexical scope, where all the variables/state disappear when the function returns
https://wiki.haskell.ohttps://www.schoolofhaskell.com/school/to-infinity-and-beyond/older-but-still-interesting/deamortized-strg/Monad/ST
https://dev.to/jvanbruegge/what-the-heck-is-polymorphism-nmh

*** /*/

<<<ST-Trick>>>

** <<<Either>>>

Allows to separate and preserve information about happened, ex. error handling.

*** /*/

<<<Either data type>>>

** <<<Inverse>>>

1. Inverse function

2. In logic: \( P \to Q \Rightarrow \neg P \to \neg Q \), & same for category duality.

3. For operation: element that allows reversing operation, having an element that with the dual produces the identity element.

4. See Inversion.

** <<<Inversion>>>

1. Is a permutation where two elements are out of order.

2. See Inverse

** <<<Inverse function>>>

\( f_{x \to y} \circ ({f_{x \to y}})^{-1} = {1}_{x} \)

/*/ \( \iff \) function is bijective.
Otherwise - partial inverse

** <<<Inverse morphism>>> :drill:
SCHT: <2020-11-12 Thu>
:properties:
:ID:       97593115-a31b-4016-8de4-9356b4a89991
:DRILL_LAST_INTERVAL: 248.4478
:DRILL_REPEATS_SINCE_FAIL: 6
:DRILL_TOTAL_REPEATS: 10
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 3.8
:DRILL_EASE: 2.72
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [2020-03-09 Mon 12:57]
:end:

For \( f: x \to y \):
\( \exists g \ : \ g \circ f = 1^{x} \) - \( g \) is left inverse of \( f \).
\( \exists g \ : \ f \circ g = 1^{y} \) - \( g \) is right inverse of \( f \).

** <<<Partial inverse>>>

/*/ when function is now bijective. When bijective see inverse function.

** <<<PatternSynonyms>>>
:properties:
:ID:       5b29fb7d-11a2-4c8f-a993-39f97e5cc93d
:end:

Enables pattern synonym declaration, which always begins with the =pattern= word.
Allows to abstract-away the structures of pattern matching.

*** /*/

<<<Pattern synonym>>>
<<<Pattern synonyms>>>

** <<<GHC debug keys>>>

*** <<<-ddump-ds>>>

Dump desugarer output.

**** /*/

<<<Desugar>>>
<<<GHC desugar>>>

** <<<GHC optimize keys>>>

*** <<<-foptimal-applicative-do>>>

\( O(n^3) \)
Always finds optimal reduction into <*> for ApplicativeDo do notation.

** <<<Computational trinitarianism>>>

Taken from: https://ncatlab.org/nlab/show/computational+trinitarianism

Under the statements:

  * propositions as types

  * programs as proofs

  * relation between type theory and category theory

the following notions are equivalent:

  == proposition proof (Logic)

  == generalized element of an object (Category theory)

  == typed program with output (Type theory & Computer science)

#+caption: Computational trinitarianism
#+name: tab--computational-trinitarianism
#+attr_latex: :environment longtable
| [[https://ncatlab.org/nlab/show/logic][Logic]]                             | [[https://ncatlab.org/nlab/show/category+theory][Category theory]]                                                 | [[https://ncatlab.org/nlab/show/type+theory][Type theory]]                                    |
|-----------------------------------+-----------------------------------------------------------------+------------------------------------------------|
| [[https://ncatlab.org/nlab/show/true][true]]                              | [[https://ncatlab.org/nlab/show/terminal+object][terminal object]]/[[https://ncatlab.org/nlab/show/%28-2%29-truncated+object][(-2)-truncated object]]                           | [[https://ncatlab.org/nlab/show/h-level+0][h-level 0]]-[[https://ncatlab.org/nlab/show/type][type]]/[[https://ncatlab.org/nlab/show/unit+type][unit type]]                       |
| [[https://ncatlab.org/nlab/show/false][false]]                             | [[https://ncatlab.org/nlab/show/initial+object][initial object]]                                                  | [[https://ncatlab.org/nlab/show/empty+type][empty type]]                                     |
| [[https://ncatlab.org/nlab/show/proposition][proposition]]                       | [[https://ncatlab.org/nlab/show/%28-1%29-truncated+object][(-1)-truncated object]]                                           | [[https://ncatlab.org/nlab/show/h-proposition][h-proposition]], [[https://ncatlab.org/nlab/show/mere+proposition][mere proposition]]                |
| [[https://ncatlab.org/nlab/show/proof][proof]]                             | [[https://ncatlab.org/nlab/show/generalized+element][generalized element]]                                             | [[https://ncatlab.org/nlab/show/program][program]]                                        |
| [[https://ncatlab.org/nlab/show/cut+rule][cut rule]]                          | [[https://ncatlab.org/nlab/show/composition][composition]] of [[https://ncatlab.org/nlab/show/classifying+morphisms][classifying morphisms]] / [[https://ncatlab.org/nlab/show/pullback][pullback]] of [[https://ncatlab.org/nlab/show/display+maps][display maps]] | [[https://ncatlab.org/nlab/show/substitution][substitution]]                                   |
| [[https://ncatlab.org/nlab/show/cut+elimination][cut elimination]] for [[https://ncatlab.org/nlab/show/implication][implication]]   | [[https://ncatlab.org/nlab/show/counit][counit]] for hom-tensor adjunction                                | [[https://ncatlab.org/nlab/show/beta+reduction][beta reduction]]                                 |
| introduction rule for [[https://ncatlab.org/nlab/show/implication][implication]] | [[https://ncatlab.org/nlab/show/unit][unit]] for hom-tensor adjunction                                  | [[https://ncatlab.org/nlab/show/eta+conversion][eta conversion]]                                 |
| [[https://ncatlab.org/nlab/show/logical+conjunction][logical conjunction]]               | [[https://ncatlab.org/nlab/show/product][product]]                                                         | [[https://ncatlab.org/nlab/show/product+type][product type]]                                   |
| [[https://ncatlab.org/nlab/show/disjunction][disjunction]]                       | [[https://ncatlab.org/nlab/show/coproduct][coproduct]] ([[https://ncatlab.org/nlab/show/%28-1%29-truncation][(-1)-truncation]] of)                                  | [[https://ncatlab.org/nlab/show/sum+type][sum type]] ([[https://ncatlab.org/nlab/show/bracket+type][bracket type]] of)                     |
| [[https://ncatlab.org/nlab/show/implication][implication]]                       | [[https://ncatlab.org/nlab/show/internal+hom][internal hom]]                                                    | [[https://ncatlab.org/nlab/show/function+type][function type]]                                  |
| [[https://ncatlab.org/nlab/show/negation][negation]]                          | [[https://ncatlab.org/nlab/show/internal+hom][internal hom]] into [[https://ncatlab.org/nlab/show/initial+object][initial object]]                                | [[https://ncatlab.org/nlab/show/function+type][function type]] into [[https://ncatlab.org/nlab/show/empty+type][empty type]]                  |
| [[https://ncatlab.org/nlab/show/universal+quantification][universal quantification]]          | [[https://ncatlab.org/nlab/show/dependent+product][dependent product]]                                               | [[https://ncatlab.org/nlab/show/dependent+product+type][dependent product type]]                         |
| [[https://ncatlab.org/nlab/show/existential+quantification][existential quantification]]        | [[https://ncatlab.org/nlab/show/dependent+sum][dependent sum]] ([[https://ncatlab.org/nlab/show/%28-1%29-truncation][(-1)-truncation]] of)                              | [[https://ncatlab.org/nlab/show/dependent+sum+type][dependent sum type]] ([[https://ncatlab.org/nlab/show/bracket+type][bracket type]] of)           |
| [[https://ncatlab.org/nlab/show/equivalence][equivalence]]                       | [[https://ncatlab.org/nlab/show/path+space+object][path space object]]                                               | [[https://ncatlab.org/nlab/show/identity+type][identity type]]                                  |
| [[https://ncatlab.org/nlab/show/equivalence+class][equivalence class]]                 | [[https://ncatlab.org/nlab/show/quotient][quotient]]                                                        | [[https://ncatlab.org/nlab/show/quotient+type][quotient type]]                                  |
| [[https://ncatlab.org/nlab/show/induction][induction]]                         | [[https://ncatlab.org/nlab/show/colimit][colimit]]                                                         | [[https://ncatlab.org/nlab/show/inductive+type][inductive type]], [[https://ncatlab.org/nlab/show/W-type][W-type]], [[https://ncatlab.org/nlab/show/M-type][M-type]]                 |
| higher [[https://ncatlab.org/nlab/show/induction][induction]]                  | [[https://ncatlab.org/nlab/show/%28infinity%2C1%29-colimit][higher colimit]]                                                  | [[https://ncatlab.org/nlab/show/higher+inductive+type][higher inductive type]]                          |
| [[https://ncatlab.org/nlab/show/completely+presented+set][completely presented set]]          | [[https://ncatlab.org/nlab/show/discrete+object][discrete object]]/[[https://ncatlab.org/nlab/show/0-truncated+object][0-truncated object]]                              | [[https://ncatlab.org/nlab/show/h-level+2][h-level 2]]-[[https://ncatlab.org/nlab/show/type][type]]/[[https://ncatlab.org/nlab/show/preset][preset]]/[[https://ncatlab.org/nlab/show/h-set][h-set]]                    |
| [[https://ncatlab.org/nlab/show/set][set]]                               | [[https://ncatlab.org/nlab/show/groupoid+object+in+an+%28infinity%2C1%29-category][internal 0-groupoid]]                                             | [[https://ncatlab.org/nlab/show/Bishop+set][Bishop set]]/[[https://ncatlab.org/nlab/show/setoid][setoid]]                              |
| [[https://ncatlab.org/nlab/show/universe][universe]]                          | [[https://ncatlab.org/nlab/show/object+classifier][object classifier]]                                               | [[https://ncatlab.org/nlab/show/type+of+types][type of types]]                                  |
| [[https://ncatlab.org/nlab/show/modality][modality]]                          | [[https://ncatlab.org/nlab/show/closure+operator][closure operator]], ([[https://ncatlab.org/nlab/show/idempotent+monad][idemponent]]) [[https://ncatlab.org/nlab/show/monad][monad]]                            | [[https://ncatlab.org/nlab/show/modal+type+theory][modal type theory]], [[https://ncatlab.org/nlab/show/monad+%28in+computer+science%29][monad (in computer science)]] |
| [[https://ncatlab.org/nlab/show/linear+logic][linear logic]]                      | ([[https://ncatlab.org/nlab/show/symmetric+monoidal+category][symmetric]], [[https://ncatlab.org/nlab/show/closed+monoidal+category][closed]]) [[https://ncatlab.org/nlab/show/monoidal+category][monoidal category]]                           | [[https://ncatlab.org/nlab/show/linear+type+theory][linear type theory]]/[[https://ncatlab.org/nlab/show/quantum+computation][quantum computation]]         |
| [[https://ncatlab.org/nlab/show/proof+net][proof net]]                         | [[https://ncatlab.org/nlab/show/string+diagram][string diagram]]                                                  | [[https://ncatlab.org/nlab/show/quantum+circuit][quantum circuit]]                                |
| (absence of) [[https://ncatlab.org/nlab/show/contraction+rule][contraction rule]]     | (absence of) [[https://ncatlab.org/nlab/show/diagonal][diagonal]]                                           | [[https://ncatlab.org/nlab/show/no-cloning+theorem][no-cloning theorem]]                             |
|                                   | [[https://ncatlab.org/nlab/show/synthetic+mathematics][synthetic mathematics]]                                           | [[https://ncatlab.org/nlab/show/domain+specific+embedded+programming+language][domain specific embedded programming language]]  |

*** /*/
<<<Trinitarism>>>

** Techniques functional programming deals with the state

*** Minimizing

Do not rely on state, try not to change the state. Use it only when it is very necessary.

*** Concentrating

Concentrate the state in one place.

*** Deferring

Defer state to the last step of the program, or to external system.

** Monadic Error handling

#+begin_src haskell
(>>=) :: m a -> (a -> m b) -> m b -- λA.E ∨ A - computes and drops if error value happens.
catch :: c a -> (e -> c a) -> c a -- λE.E ∨ A - handles "errors" as "normal" values and stops when an "error" is finally handled.
#+end_src

** Functions

Total function uses domain fully, but takes only part of the codomain.
Function allows to collapse domain values into codomain value. Meaning the function allows to loose the information.
So total function is a computation that looses the information or into bigger codomains.
That is why the function has a directionality, and inverse total process is partially possible.

Directionality and invertability are terms.

** <<<Void>>>

Emptiness.

Can not be grasped, touched.

A logically uninhabited data type.

(Since basis of logic is tautologically True and Void value can not be addressed - there is a logical paradox with the Void).

Is an object includded into the Hask category, since:
#+begin_src haskell
:t (id :: Void -> Void)
(id :: Void -> Void) :: Void -> Void
#+end_src

=id= for it exists.

Type system corresponds to constructive logic and not to the classical logic.
Classical logic answers the question "Is this actually true".
Constuctive (Intuitionistic) logic answers the question "Is this provable".

Also has functions:
#+begin_src haskell
-- Represents logical principle of explosion: from falsehood, anything follows.
absurd :: Void -> a

-- If Functor holds only Void - it holds no values.
vacuous :: Functor f => f Void -> f a

-- If Monad holds only Void - it holds no values.
vacuousM :: Monad m => m Void -> m a
#+end_src

Design pattern: use polymorphic data types and Void to get rid of possibilities when you need to.

*** /*/
<<<Nothing>>>, Haskell expressions can't return Void.

Also see: Maybe.

** Constructive proof

Method of proof that demonstrates the existence of a mathematical object by creating or providing a method for creating the object.

** Intuitionistic logic

Proposition considered =True= due to direct evidence of existence through constructive proof using Curry-Howard isomorphism.

/*/ does not include classic logic fundamental axioms of the excluded middle and double negation elimination. Hense /*/ is weaker then classical logic. Classical logic includes /*/, all theorems of /*/ are also in classical logic.

*** /*/

<<<Constructive logic>>>

** <<<Principle of explosion>>> :drill:
:PROPERTIES:
:ID:       0ef25f89-1023-480a-8f5f-e075960d9385
:END:

From asserted statement that contains contradiction - anything can be proven.
Ancient principle of logic. Both in classical & intuitionistic logic.

*** /*/

<<<Ex falso quodlibet>>>
<<<Ex falso sequitur quodlibet>>>
<<<EFG>>>
<<<Ex contradictione quodlibet>>>
<<<Ex contradictione sequitur quodlibet>>>
<<<ECQ>>>
<<<Deductive explosion>>>
<<<Pseudo-Scotus>>>

** Universal property

A property of some construction which boils down to (is manifestly equivalent to) the property that an associated object is a universal initial object of some (auxiliary) category.

** Yoneda lemma

Allows the embedding of any category into a category of functors (contravariant set-valued functors) defined on that category. It also clarifies how the embedded category, of representable functors and their natural transformations, relates to the other objects in the larger functor category.

The Yoneda lemma suggests that instead of studying the (locally small) category C {\displaystyle {\mathcal {C}}} \mathcal{C} , one should study the category of all functors of C {\displaystyle {\mathcal {C}}} \mathcal{C} into S e t {\displaystyle \mathbf {Set} } \mathbf{Set} (the category of sets with functions as morphisms). S e t {\displaystyle \mathbf {Set} } \mathbf{Set} is a category we think we understand well, and a functor of C {\displaystyle {\mathcal {C}}} \mathcal{C} into S e t {\displaystyle \mathbf {Set} } \mathbf{Set} can be seen as a "representation" of C {\displaystyle {\mathcal {C}}} \mathcal{C} in terms of known structures. The original category C {\displaystyle {\mathcal {C}}} \mathcal{C} is contained in this functor category, but new objects appear in the functor category, which were absent and "hidden" in C {\displaystyle {\mathcal {C}}} \mathcal{C} . Treating these new objects just like the old ones often unifies and simplifies the theory.

** Monoidal category, functoriality of ADTs, Profunctors

Category equipped with tensor product.
#+begin_src haskell
<>
#+end_src
wich is a functor for /*/.

Set category can be monoidal under both product (having terminal object) or coproduct (having initial object) operations, if according operation exist for all objects.

Any one-object category is /*/.

\( (a, ()) \sim a \) up to unique isomorphism, which is called Lax monoidal functor.

Product and coproduct are functorial, so, since:
Algebraic data type construction can use:
  * Type constructor
  * Data constructor
  * Const functor
  * Identity functor
  * Product
  * Coproduct

Any algebraic data type is functorial.

** <<<Const functor>>>

Maps all objects of source category into one (fixed) object of target category, and all morphisms to identity morphism of that fixed object.

#+begin_src haskell
instance Functor (Const c)
 where
  fmap :: (a -> b) -> Const c a -> Const c b
  fmap _ (Const c) = Const c
#+end_src

In Category theory denoted:
#+begin_src text
Δ
#+end_src

Last type parameter that bears the target type of lifted function (=b=) and is a proxy type.

Analogy: the container that allways has an object attached to it, and everything that is put inside - changes the container type accordingly, and dissapears.

** <<<Arrow in Haskell>>>

#+begin_src haskell
(->) a b = a -> b
#+end_src
Functorial in the last argument & called Reader functor.

#+begin_src haskell
newtype Reader c a = Reader (c -> a)

  fmap = ( . )
#+end_src

** Contravariant functor

#+begin_src haskell
fmap :: (a -> b) -> Op c a -> Op c b
                (a -> c) -> (b -> c)
#+end_src

\begin{tikzcd}
a \arrow[r] \arrow[rd] & b \arrow[d, dashed] \\
                       & c                  
\end{tikzcd}

\( (a \to b)^{C} = (a \leftarrow b)^{C^{op}} \)

#+begin_src haskell
class Contravariant f
 where
  contramap :: (b -> a) -> (f a -> f b)
#+end_src

\begin{tikzcd}
a \arrow[r] \arrow[rd] & b \arrow[d, "contravariant", dashed] \\
                       & c                                   
\end{tikzcd}

If arrows does not commute Contravatiant funtor anyway allows to construct transformation between these such arrows to other arrow.

** Profunctor

#+begin_src haskell
(->) a b
#+end_src

\( C^{op} \times C \to C \)

It is called profunctor.

#+begin_src haskell
dimap :: (a' -> a) -> (b -> b') -> p a b -> p a' b'
#+end_src

So, profunctor in case of arrow:

\begin{tikzcd}
a \arrow[d, "h"] & a' \arrow[l, "f"] \arrow[d, "profunctor", dashed] \\
b \arrow[r, "g"] & b'                                       
\end{tikzcd}

#+begin_src haskell
dimap :: (a' -> a) -> (b -> b') -> p a b -> p a' b'
dimap ::    f          g     -> (a -> b) -> (a' -> b') 
dimap ::    f          g     ->    h    -> (a' -> b')
dimap = g . h . f
#+end_src

It is contravariant functor in the first argument, and covariant functor in the second argument.

#+begin_src haskell
dimap id <==> fmap
(flip dimap) id <==> contramap
#+end_src

** Coerce

Operates under condition that source and target types have same representation.
Same representation means they are type aliases, or it the compiler can infer that they have the same representation. 
Directly shares the values from the source type to the target type.
Conversion is free, there is no run-time computations.

The function implementing the transition:
#+begin_src haskell
coerce :: Coercible a b => a -> b
#+end_src

Type class implementing the instances for transitions:
#+begin_src haskell
class a ~R# b => Coercible (a :: k0) (b :: k0)
#+end_src
When compiler detects types have same structure, type class instances coerse implementation for this pairs of types. This type class does not have regular instances; instead they are created on-the-fly during type-checking. Trying to manually declare an instance of Coercible is an error.

*** /*/

Coercible

* Reference

** <<<Functor-Applicative-Monad Proposal>>> :drill:
:properties:
:ID:       bfe7e9bf-1683-433d-949f-0c4240226074
:end:

Well known event in Haskell history: https://github.com/quchen/articles/blob/master/applicative_monad.md.

Math justice was restored with a RETroactive CONtinuity. Invented in computer science term Applicative (lax monoidal functor) become a superclass of Monad.

& that is why:
  * =return = pure=
  * =ap = <*>=
  * =>> = *>=
  * =liftM = liftA = fmap=
  * =liftM* = liftA*=

Also, a side-kick - Alternative became a superclass of MonadPlus. Hense:
  * =mzero = empty=
  * =mplus = (<|>)=

Work of unification continues under: https://gitlab.haskell.org/ghc/ghc/wikis/proposal/monad-of-no-return

*** /*/

<<<Applicative-Monad proposal>>>
<<<AMP>>>

** Haskell-98

*** <<<Old instance termination rules>>>

  1. \forall class constraint (C t1 .. tn):
    1.1. type variables have occurances \le head
    1.2. constructors+variables+repetitions < head
    1.3. \not type functions (type func application can expand to arbitrary size)
  2. \forall functional dependencies, ⟨tvs⟩_left \to ⟨tvs⟩_right, of the class, every type variable in S(⟨tvs⟩_right) must appear in S(⟨tvs⟩_left), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance head.

** Performance results and comparisons of types & solutions
[[https://github.com/haskell-perf][Haskell performance]]

* Liturgy
λειτ       <- λαός  /Laos/       the people
    ουργός <- ἔργο  /ergon/      work
λειτουργία          /leitourgia/ giving back to the community

The life is beautiful.
For all humans that make the life have more uniqueness.

This study would not be possible without mathematicians, Haskellers, scientists, creators, contributors. These people are the most fascinating in my life.

Special accolades for the guys at Serokell. They were the force that got me inspired & gave resources to seriously learn Haskell and create this pocket guide.
