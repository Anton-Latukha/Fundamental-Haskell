* Functions to remember
** Prelude
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo 
*** List operations
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
** Data.List
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
** Data.Char
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
** QuickCheck
quickCheck :: Testable prop => prop -> IO ()

quickCheck . verbose - run verbose mode
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints 
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
** What been evaluated already
:sprint name
* FunFunc
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
* Good code
Use datatype aliases to deferentiate logic of values.

Unconstrained means most flexible, but the most useless.
The more constrained system has more usefulness.

*** Read Conventions of variables (page 176)
*** Polymorphism 
Parametric polymorphism is broader then constrained polymorphism
*** Damas–Hindley–Milner type system
*** Print
print :: Show a => a -> IO ()
print a = putStrLn (show a)
*** Read code evaluation (488 on-ward)
*** Fold
foldr spine recursion intermediated by the folding
foldl spine folding is unconditional, then solding starts.

So foldr can terminate at any point, while foldl unconditionally recurses across the spine, even if it infinite.
*** Computation model
Model the domain and types before thinking about how to wriet computations.
*** Make bottoms only local
*** Newtype wrap is ideally transparent for compiler and does not change performance
*** Instances of types/typeclasses must go with code you write
*** Functions can be abstracted as arguments
*** Infix operators can be bind to arguments
*** Arbitrary
Product types can be tested as a product of random generators.
Sum types require to implement generators with separate constructors, and picking one of them, use `oneof` or `frequency` to pick generators.

*** Principle of Separation of concerns
*** Function composition
In Haskell inline composition requires:
#+BEGIN_SRC haskell
h.g.f $ i
#+END_SRC
Function application has a higher priority than composition. That is why parentheses over argument are needed.
This precedence allows idiomatically compose partially applied functions.

But it is a way better then:
#+BEGIN_SRC haskell
h (g (f i))
#+END_SRC
*** Functor application
Function application on n levels beneath:
#+BEGIN_SRC haskell
(fmap.fmap) function twoLevelStructure
#+END_SRC

How fmap.fmap typechecks:
#+BEGIN_SRC haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
fmap :: Functor f => (m -> n) -> f m -> f n
fmap :: Functor g => (x -> y) -> g x -> g y

(.) :: (Functor f, Functor g) => ((g x -> g y) -> f.g (x) -> f.g (y))
                                      -> ((x -> y) -> g x -> g y)
                                      -> (x -> y) -> f.g (x) -> f.g. (y)
fmap.fmap :: (x -> y) -> f.g (x) -> f.g. (y)
#+END_SRC
*** Paramenter order
In functions parameter order is important.
It is best to use first the most reusable parameters.
And as last one the one that can be the most variable, that is important to chain.
* Definitions
** Abstraction
Generalization of process from concrete instance of a problem mainly by introduction of names.
** Actual type
[[Datatype]] recieved by execution.
** Ad hoc polymorphism
Artificial [[Polymorphism][polymorphism]] dependent on incoming [[Datatype][datatype]].
Achieved by creating a [[Typeclass][typeclass]] [[Function][functions]].
So it is a dispatch mechanism, that is how polymorphism achieved.
** Algebraic datatype
Composite type formed by combining other types.
** Alpha equivalence
If names of parameters in [[Expression][expressions]] accordingly different, but process is literally the same - that means that names are synonyms and [[Expression][expression]] are alpha equivalent.
** Anamorphism
Morphism from a coalgebra to the final coalgebra for that endofunctor
** Anonymous function
Lambda function without the name to bind to.
** Application
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen
** Argument
Is an input value to a function.
** Arity
Number of parameters of the function.
- nullary - f()
- unary   - f(x)
- binary  - f(x,y)
- ternary - f(x,y,z)
- n-ary   - f(x,y,z..)
** As-pattern
f list@(x, xs) =
** Base case
A part of a [[Recursion][recursive]] [[Function][function]] that produces result trivially.
** Beta normal form
No [[Beta reduction][beta reduction]] is possible
** Beta reduction
Applying [[Function][function]] to an [[Argument][argument]].
** Binary tree
data BinaryTree a =
    [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)
** Bind
Eq between two objects.
Parameter of the function = argument that applied to the function
Variables = values.
** Bottom value
'_' fits *.

Is a non-value used to denote the program cannot return a values.
** Cardinality
Number of elements.

Number of possible implementations for a given type signature.

On sum - add cardinalities.
On product - multiply cardinalities.
** Catamorphism
(from the Greek: κατά "downwards" and μορφή "form, shape") denotes the unique homomorphism from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
** Combinator
Lambda term without free variables.

Higher-order [[Function][function]] that uses only function application and earlier defined combinators to define a result from its arguments.

Narrow meaning: A function or definition with no free variables.

Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Compose
See: [[Function composition]]
** Concatenate
Link together sequences.
** Concrete type
** Cons
See: Construct
** Cons cell
Conceptual space that values may inhabit.
** Constant
Nullary constructor
** Constrain
See: [[Ad hoc polymorphism]]
** Construct
#+BEGIN_SRC haskell
(:) :: a -> [a] -> [a]
#+END_SRC
** Constructor
1. [[Type constructor]]
2. [[Data onstructor]]

Also see: [[Constant]]
** Currying
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Data constant
See: [[Constant]]
** Data constructor
Values that [[Inhabit][inhabit]] [[Datatype][datatype]]

Constant value - nullary data constructor
** Data declaration
[[Datatype]] definition
** Datatype
Data type, type.
** Declaration
Top-level [[Bind][bindings]] which allow us to name [[Expression][expressions]].
** Derived instance
Typeclasses such as Eq, Enum, Ord, Show can have instances generated based definition of datatype.
** Dispatch
Send, transmission, reference.
** Effect
Observable action.
** Evaluation
For FP see [[Bind]].
** Expected type
[[Datatype]] infered from the text of the code
** Expression
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class
1. Can be used as [[Value][value]].
2. Passed as an [[Argument][argument]].
** Fold
Higher-order function ruturns accumulated result from recursive data structure applying a function.
** Free variables
Variables in the fuction that is not bound by the head.
They live empty and fuction as so is not fully applied.
** Function
Idealization of how a varying quantity depends on another quantity.

$x \in X, y \in Y : f^{X \to Y} = \overset{\rightharpoonup}{G}(x,y)$

Directionality and property of invariability emerge from one another.

 *      ->   *
domain func codomain

Function is a mathematical [[Operation][operation]].

Function = Total function = Pure function. Function theoretically posible to momoized.
[[Partial function]].
Inverse function - often partially exists (partial function).
** Function body
[[Expression]] that haracterizes the process.
** Function composition
#+BEGIN_SRC haskell
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
#+END_SRC

In Haskell inline composition requires:
#+BEGIN_SRC haskell
h.g.f $ i
#+END_SRC
** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
** Higher-kinded datatype
Any combination of * and ->

Type that take more types as arguments.
** Higher-order function
Function arity > 1.

----

A) Has function as an argument.
B) Evaluates to function.
** HOF
See: [[Higher-order function]]
** Identity function
Return itself.
(\x.x)
#+BEGIN_SRC haskell
id :: a -> a
#+END_SRC
** Infix
Operaton in-between variables.
** Inhabit
What [[Values][values]] inhabit [[Datatype][datatype]]
** Interface
Point of mutual meeting. Code behind interface determines how data is consumed.
** IO
Type for values whose evaluations has a posibility to cause side effects.
** Kind
Kind -> Type -> Data
** Lambda calculus
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and application using variable [[Bind][binding]] and substitution.
** Leaf
 _
** Left associative
Same level [[Exression][expression]] parts in reality follow grouping from left to right.
(\x.x)(\y.y)z = ((\x.x)(\y.y))z
** Level of code
There are mainly three levels of Haskell code.
- [[Type level]]: part that works with [[Datatype][datatypes]]
- [[Term level]]: logical execution part of the code
- Compile level: level when code compiles/compiled
** Lexical scope
Scope search sourcecode blocks structure determined.
** Local
[[Scope]] applies only in an area
** Module
Importable organization unit.
** Modulus
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Monomorphic
Made of one form.
** Node
 *
/ \
** Normal form
In context: [[Beta normal form]]
** Nothing
Any Haskell expression can't return nothing.
** Operator
[[Infix]] [[Function][function]].
** Parameter
Or Formal Parameter - named varible of a [[Function][function]].
** Parametric polymorphism
Achieved by [[Abstraction][abstracting]] using [[Parametep][parameter]].
** Partial application
Part of [[Function][function]] [[parameter][parameters]] [[Application][applied]].
** Partial function
Does not cover all cases.
Unsafe and causes trouble.
** Pointfree
Point-free style, or Tacit programming is a paradigm in which function definition does not notate arguments. Instead definitions merely compose other functions.
** Polymorphism
Interface to entities of different [[Datatypes][datatypes]] by quality of [[Abstraction][abstraction]].
Antonym - [[Monomorphism]].
** Principal type
The most generic [[Datatype][datatype]] that still typechecks.
** Product datatype
Logical conjunction.
A datatype that consists of AND areas
** Purity
[[Referantial transparency][Referential transparent]] [[Function][function]]
** Recursion
Repeated function application allow computing results that may require indefinite amount of work.
** Redex
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction
See [[Beta Reduction]]
** Referential transparency
Function returns the same output given the same values to evaluate.

[[Expression]] is referentially transparent if can be replaced with its corresponding resulting value without change for program's behavior.
Such [[Functions][functions]] are called [[Pure][pure]].
** REPL
Interactive CLI. Read-eval-print loop.
** Scope
Area where [[Bind][bind]] is accessible.
** Sectioning
Writing [[Function][function]] in a parentheses. Allows to pass around [[Partial application][partially applied]] [[Function][functions]].
** Shadowing
Global scope variable overriden by variable in local scope.
** Smart constructor
Place extra constraints on the construction of values.
** Spine
  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

  :
 / \
_   :
   / \
  _   :
     / \
    _  []

** Statement
Declarative sentence that is true or false.
Gonzales: "What code does."
** Static typing
Static typechecking occurs at [[Level of code][compile time]]
** Sum datatype
Logical disjunction.
A datatype that consists of OR areas.
** Superclass
Broader parent class.
** Syntatic sugar
Artificial way to make language easier to read and write.
** Tail call
Final result of the function
** Tail recursion
Tail calls are recursive invocantions of itself.
** Term level
See: [[Level of code]]
** Tuple
Datatype that stores multiple values withing a single value.
Tuples by [[Arity][arity]]:
- empty, [[Unit][unit]]          - 0
- pair, two-tuples     - 2
- thriple, three-tuple - 3
** Type
Type - [[Set][set]] of values.
See [[Datatype]]
** Type alias
Create type constructor, not data constructor.
** Set
Well-defined collection of distinct objects.
** Type constant
See: [[Constant]]
** Type constructor
Name of [[Datatype][datatype]]

Nullary type constructor is [[Type constant]]
** Type inference
Automatic [[Datatype][datatype]] detection of [[Expresion][expression]].
** Type level
See: [[Level of code]]
** Type variable
Refer to an unspecified type in Haskell type signature.
** Typeclass
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
** Typeclass inheritance
[[Typeclass]] has a [[Superclass][superclass]]
** Type instance
Unique [[Typeclass][typeclass]]->[[Datatype][type]] pairing.
Defines typeclass->type methods.
** Uncurry
Replace number of [[Function][functions]] with [[Tuple][tuple]] of number of values
** Undefined
Value helps to do typechecking
** Unit
Value, [[Datatype][type]]. Represents nothing. Empty [[Tuple][tuple]]
** Unsafe
[[Function]] that does not cover some edge case.
** Variable
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funсtions]].
** Variadic
Assepting a variable number of [[Argument][arguments]].
** Associative law
$\forall (a,b,c) \in S : P(a,P(b,c))=P(P(a,b),c)$,
Etymology:
Joined by a common purpose.
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".
** Monoid
[[Semigroup]] that has [[Identity]] value.

#+BEGIN_SRC haskell
class Monoid m where
mempty :: m
mappend :: m -> m -> m
mconcat :: [m] -> m
mconcat = foldr mappend mempty
#+END_SRC
*** Abelian or commutative monoid
Very helpful at concurrent or distributed processing.
*** Monoid laws
#+BEGIN_SRC haskell
-- left identity
mappend mempty x = x
-- right identity
mappend x mempty = x
-- associativity
mappend x (mappend y z) = mappend (mappend x y) z
mconcat = foldr mappend mempty
#+END_SRC
** Binary
Two of something.
** Operation
As also called [[Function][function]].
Used in mathematics. Word often used for [[Infix][infix]] operations.
** Identity
*** Two-sided identity of a [[Predicate][predicate]]
$P()$ is [[Commutative][commutative]].
$\exist e \in S, \forall a \in S : P(e,a)=P(a,e)=a$
*** Left identity of a [[Predicate][predicate]]
$\exist e \in S, \forall a \in S : P(e,a)=a$
*** Right identity of a [[Predicate][predicate]]
$\exist e \in S, \forall a \in S : P(a,e)=a$

Identity only possible with morphism.
** Predicate
[[Assertion]] includes variable.
Notation: $P(x)$
[[Application]] of [[Argument][argument]] results in true or false predicate.
** Assertion
Statement.
Утверждение.
** Commutative Law
$\forall (a,b) \in S : P(a,b)=P(b,a)$
** Conjunction
AND
** Disjunction
OR
** Orphan type instance
[[Type instance]] that appeared from inconsistent code base. Duplicate of instance, or instance present on [[Typeclass][typeclass]] or on [[type]] level.

Solution for addressing orphan instances:
1. You defined the type but not the typeclass?
Put the instance in the same module as the type so that the type cannot be imported without its instances.
2. You defined the typeclass but not the type?
Put the instance in the same module as the typeclass definition so that the typeclass cannot be imported without its instances.
3. Neither the type nor the typeclass are yours?
Define your own newtype wrapping the original type and now you’ve got a type that “belongs” to you for which you can rightly define typeclass instances. There are means of making this less annoying which we’ll discuss later.
** Semigroup
$\forall (a,b,c) \in S : P(a,P(b,c))=P(P(a,b),c)$

Semigroup - a set (S) with a binary operation (P) and [[Associative law][associative law]].
Semigroup is closed (forms a closed set).
A [[Magma]] with associative law.

Defined in Haskell as:

#+BEGIN_SRC haskell
class Semigroup a where
(<>) :: a -> a -> a
#+END_SRC

** Magma
Set with a single binary operation.

The category of magmas, denoted $Mag$, has as objects sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).
** Binary operation
$\forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S$
** data declaration
Data type declaration is the most general and versatile form to create a new datatype.
Form:
#+BEGIN_SRC haskell
data [context =>] type typeVars1..n
  = con1  c1t1..i
  | ...
  | conm  cmt1..q
  [deriving]
#+END_SRC haskell
** type declaration
Synonim for existing type. Uses the same data constructor.
#+BEGIN_SRC haskell
type FirstName = String
#+END_SRC haskell
Used to distinct one entities from other entities, while they have the same type.
Also main type functions can operate on a new type.
** newtype declaration
Creates a new type from old type using a new constructor.
#+BEGIN_SRC haskell
newtype FirstName = FirstName String
#+END_SRC haskell

Data will have exactly the same representation at runtime, as the type that is wrapped.

#+BEGIN_SRC haskell
newtype Book = Book (Int, Int)
#+END_SRC haskell

      (,)
      / \
Integer Integer
** Gen type
Generator. List it returns gets infinitely cycled.
** Arbitrary typeclass
[[Typeclass]] of [[QuickCheck]].Arbitrary (that is reexported by QuickCheck) for creating a generator/distribution of values.
Useful function is arbitrary - that autoassumes/generates values.
** Arbitrary function
Depends on type and generates values of the type.
** NonEmpty list datatype
Data.List.NonEmpty
Has a Semigroup instance but can't have a Monoid instance. It never can be an empty list.

#+BEGIN_SRC haskell
data NonEmpty a = a :| [a]
  deriving (Eq, Ord, Show)
#+END_SRC haskell

:| - an infix data costructor that takes two (type) arguments. In other words :| returns a product type of left and right
* Investigate
** Control.monad
* Citations:
"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))
* TeX examples

$\displaystyle L(f,P)=\sum_{i=0}^{n-1} inf_{t\in[x_i,x_{i+1}]}f(t)(x_{i+1}-x_{i})$,

\begin{equation}
x=\sqrt{b}
\end{equation}

If $a^2=b$ and \( b=2 \), then the solution must be
either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].

