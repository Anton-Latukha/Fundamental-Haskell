* Functions to remember
** Prelude
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo 
*** List operations
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
** Data.List
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
** Data.Char
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints 
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
* FunFunc
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
* Definitions
** Abstraction
Generalization of process from concrete instance of a problem mainly by introduction of names.
** Alpha equivalence
If names of parameters in [[Expression][expressions]] accordingly different, but process is literally the same - that means that names are synonyms and [[Expression][expression]] are alpha equivalent.
** Anonymous function
In Haskell it is a Lambda function expression without the name to bind to.
** Application
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen
** Argument
Is an input value to a function
** Beta normal form
No [[Beta reduction][beta reduction]] is possible
** Beta reduction
Applying [[Function][function]] to an [[Argument][argument]].
** Bind
Parameter of the function = argument that applied to the function
** Catamorphism
(from the Greek: κατά "downwards" and μορφή "form, shape") denotes the unique homomorphism from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
** Combinator
Lambda term without free variables.

Higher-order [[Function][function]] that uses only function application and earlier defined combinators to define a result from its arguments.

Narrow meaning: A function or definition with no free variables.

Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Datatype
Data type, type.
** Declaration
Top-level [[Bind][bindings]] which allow us to name [[Expression][expressions]].
** Evaluation
For FP see [[Bind]].
** Expression
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class
1. Can be used as [[Value][value]].
2. Passed as an [[Argument][argument]].
** Free variables
Variables in the fuction that is not bound by the head.
They live empty and fuction as so is not fully applied.
** Function
The idealization of how a varying quantity depends on another quantity.

A function f from a set X to a set Y is defined by a set G of ordered pairs (x, y), such that x ∈ X, y ∈ Y, and every element of X is the first component of exactly one ordered pair in G.[4] In other words, for every x in X there is exactly one element y, such that the ordered pair (x, y) belongs to the set of pairs defining the function f.
** Function body
[[Expression]] that haracterizes the process.
** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
** Identity
Return itself.
(\x.x)
id :: a -> a
** Lambda calculus
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and application using variable [[Bind][binding]] and substitution.
** Left associative
Same level [[Exression][expression]] parts in reality follow grouping from left to right.
(\x.x)(\y.y)z = ((\x.x)(\y.y))z
** Parameter
Or Formal Parameter - named varible of a [[Function][function]].
** Purity
[[Referantial transparency][Referential transparent]] [[Function][function]]
** Redex
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction
See [[Beta Reduction]]
** Referential transparency
Function returns the same output given the same values to evaluate.

[[Expression]] is referentially transparent if can be replaced with its corresponding resulting value without change for program's behavior.
Such [[Functions][functions]] are called [[Pure][pure]].
** REPL
Interactive CLI. Read-eval-print loop.
** Type
See [[Datatype]]
** Variable
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funtions]].
** Currying
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Normal form
In context: [[Beta normal form]]
** Infix
Operaton in-between variables.
** Modulus
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Syntatic sugar
Artificial way to make the language easier to read and write.
** Sectioning
Writing [[Function][function]] in a parentheses. Allows to pass around partially applied functions.
** Scope
Area where [[Bind][bind]] is accessible.
** Operator
[[Infix]] [[Function][function]].
** Type alias
** Concatenate
Link together sequences.
** Polymorphism
Interface to entities of different [[Datatypes][datatypes]] by quality of [[Abstraction][abstraction]].
** Ad hoc polymorphism
Artificial [[Polymorphism]] that depending on incoming [[Datatype][datatype]] has different behaviour.
Achieved by creating a [[Typeclass][typeclass]] [[Function][functions]].
** Parametric polymorphism
Achieved by [[Abstraction][abstracting]] using [[Parametep][parameter]].
** Typeclass
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
