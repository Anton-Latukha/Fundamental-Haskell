* Functions to remember
** Prelude
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo 
*** List operations
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
** Data.List
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
** Data.Char
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints 
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
** What been evaluated already
:sprint name
* FunFunc
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
* Good code
Use datatype aliases to deferentiate logic of values.

Unconstrained means most flexible, but the most useless.
The more constrained system has more usefulness.

*** Read Conventions of variables (page 176)
*** Polymorphism 
Parametric polymorphism is broader then constrained polymorphism
*** Damas–Hindley–Milner type system
*** Print
print :: Show a => a -> IO ()
print a = putStrLn (show a)
*** Read code evaluation (488 on-ward)
*** Fold
foldr spine recursion intermediated by the folding
foldl spine folding is unconditional, then solding starts.

So foldr can terminate at any point, while foldl unconditionally recurses across the spine, even if it infinite.
*** Computation model
Model the domain and types before thinking about how to wriet computations.
*** Make bottoms only local
* Definitions
** Abstraction
Generalization of process from concrete instance of a problem mainly by introduction of names.
** Actual type
[[Datatype]] recieved by execution.
** Ad hoc polymorphism
Artificial [[Polymorphism][polymorphism]] dependent on incoming [[Datatype][datatype]].
Achieved by creating a [[Typeclass][typeclass]] [[Function][functions]].
So it is a dispatch mechanism, that is how polymorphism achieved.
** Algebraic datatype
Composite type formed by combining other types.
** Alpha equivalence
If names of parameters in [[Expression][expressions]] accordingly different, but process is literally the same - that means that names are synonyms and [[Expression][expression]] are alpha equivalent.
** Anamorphism
Morphism from a coalgebra to the final coalgebra for that endofunctor
** Anonymous function
Lambda function without the name to bind to.
** Application
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen
** Argument
Is an input value to a function.
** Arity
Number of parameters of the function.
- nullary - f()
- unary   - f(x)
- binary  - f(x,y)
- ternary - f(x,y,z)
- n-ary   - f(x,y,z..)
** As-pattern
f list@(x, xs) =
** Base case
A part of a [[Recursion][recursive]] [[Function][function]] that produces result trivially.
** Beta normal form
No [[Beta reduction][beta reduction]] is possible
** Beta reduction
Applying [[Function][function]] to an [[Argument][argument]].
** Binary tree
data BinaryTree a =
    [[Leaf]]
  | [[Node]] (BinaryTree a) a (BinaryTree a)
  deriving (Eq, Ord, Show)
** Bind
Eq between two objects.
Parameter of the function = argument that applied to the function
Variables = values.
** Bottom value
'_' fits *.

Is a non-value used to denote the program cannot return a values.
** Cardinality
Number of elements.

Number of possible implementations for a given type signature.

On sum - add cardinalities.
On product - multiply cardinalities.
** Catamorphism
(from the Greek: κατά "downwards" and μορφή "form, shape") denotes the unique homomorphism from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
** Combinator
Lambda term without free variables.

Higher-order [[Function][function]] that uses only function application and earlier defined combinators to define a result from its arguments.

Narrow meaning: A function or definition with no free variables.

Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Compose
See: [[Function composition]]
** Concatenate
Link together sequences.
** Concrete type
** Cons
See: Construct
** Cons cell
Conceptual space that values may inhabit.
** Constant
Nullary constructor
** Constrain
See: [[Ad hoc polymorphism]]
** Construct
(:) :: a -> [a] -> [a]
** Constructor
1. [[Type constructor]]
2. [[Data onstructor]]

Also see: [[Constant]]
** Currying
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Data constant
See: [[Constant]]
** Data constructor
Values that [[Inhabit][inhabit]] [[Datatype][datatype]]

Constant value - nullary data constructor
** Data declaration
[[Datatype]] definition
** Datatype
Data type, type.
** Declaration
Top-level [[Bind][bindings]] which allow us to name [[Expression][expressions]].
** Derived instance
Typeclasses such as Eq, Enum, Ord, Show can have instances generated based definition of datatype.
** Dispatch
Send, transmission, reference.
** Effect
Observable action.
** Evaluation
For FP see [[Bind]].
** Expected type
[[Datatype]] infered from the text of the code
** Expression
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class
1. Can be used as [[Value][value]].
2. Passed as an [[Argument][argument]].
** Fold
Higher-order function ruturns accumulated result from recursive data structure applying a function.
** Free variables
Variables in the fuction that is not bound by the head.
They live empty and fuction as so is not fully applied.
** Function
Idealization of how a varying quantity depends on another quantity.

A function f from a set X to a set Y is defined by a set G of ordered pairs (x, y), such that x ∈ X, y ∈ Y, and every element of X is the first component of exactly one ordered pair in G.[4] In other words, for every x in X there is exactly one element y, such that the ordered pair (x, y) belongs to the set of pairs defining the function f.

Function is an [[Operation][operation]].
** Function body
[[Expression]] that haracterizes the process.
** Function composition
(.) :: (b -> c) -> (a -> b) -> a -> c

a -> (a -> b) -> (b -> c) -> c
** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
** Higher-kinded datatype
Any combination of * and ->

Type that take more types as arguments.
** Higher-order function
Function arity > 1.

----

A) Has function as an argument.
B) Evaluates to function.
** HOF
See: [[Higher-order function]]
** Identity function
Return itself.
(\x.x)
id :: a -> a
** Infix
Operaton in-between variables.
** Inhabit
What [[Values][values]] inhabit [[Datatype][datatype]]
** Interface
Point of mutual meeting. Code behind interface determines how data is consumed.
** IO
Type for values whose evaluations has a posibility to cause side effects.
** Kind
Kind -> Type -> Data
** Lambda calculus
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and application using variable [[Bind][binding]] and substitution.
** Leaf
 _
** Left associative
Same level [[Exression][expression]] parts in reality follow grouping from left to right.
(\x.x)(\y.y)z = ((\x.x)(\y.y))z
** Level of code
There are mainly three levels of Haskell code.
- [[Type level]]: part that works with [[Datatype][datatypes]]
- [[Term level]]: logical execution part of the code
- Compile level: level when code compiles/compiled
** Lexical scope
Scope search sourcecode blocks structure determined.
** Local
[[Scope]] applies only in an area
** Module
Importable organization unit.
** Modulus
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Monomorphic
Made of one form.
** Node
 *
/ \
** Normal form
In context: [[Beta normal form]]
** Nothing
Any Haskell expression can't return nothing.
** Operator
[[Infix]] [[Function][function]].
** Parameter
Or Formal Parameter - named varible of a [[Function][function]].
** Parametric polymorphism
Achieved by [[Abstraction][abstracting]] using [[Parametep][parameter]].
** Partial application
Part of [[Function][function]] [[parameter][parameters]] [[Application][applied]].
** Partial function
Does not cover all cases.
Unsafe and causes trouble.
** Pointfree
Point-free style, or Tacit programming is a paradigm in which function definition does not notate arguments. Instead definitions merely compose other functions.
** Polymorphism
Interface to entities of different [[Datatypes][datatypes]] by quality of [[Abstraction][abstraction]].
** Principal type
The most generic [[Datatype][datatype]] that still typechecks.
** Product datatype
Logical conjunction.
A datatype that consists of AND areas
** Purity
[[Referantial transparency][Referential transparent]] [[Function][function]]
** Recursion
Repeated function application allow computing results that may require indefinite amount of work.
** Redex
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction
See [[Beta Reduction]]
** Referential transparency
Function returns the same output given the same values to evaluate.

[[Expression]] is referentially transparent if can be replaced with its corresponding resulting value without change for program's behavior.
Such [[Functions][functions]] are called [[Pure][pure]].
** REPL
Interactive CLI. Read-eval-print loop.
** Scope
Area where [[Bind][bind]] is accessible.
** Sectioning
Writing [[Function][function]] in a parentheses. Allows to pass around [[Partial application][partially applied]] [[Function][functions]].
** Shadowing
Global scope variable overriden by variable in local scope.
** Smart constructor
Place extra constraints on the construction of values.
** Spine
  :
 / \
1   :
   / \
  2   :
     / \
    3  []

1:2:3:[]

  :
 / \
_   :
   / \
  _   :
     / \
    _  []

** Statement
Declarative sentence that is true or false.
Gonzales: "What code does."
** Static typing
Static typechecking occurs at [[Level of code][compile time]]
** Sum datatype
Logical disjunction.
A datatype that consists of OR areas.
** Superclass
Broader parent class.
** Syntatic sugar
Artificial way to make language easier to read and write.
** Tail call
Final result of the function
** Tail recursion
Tail calls are recursive invocantions of itself.
** Term level
See: [[Level of code]]
** Tuple
Datatype that stores multiple values withing a single value.
Tuples by [[Arity][arity]]:
- empty, [[Unit][unit]]          - 0
- pair, two-tuples     - 2
- thriple, three-tuple - 3
** Type
See [[Datatype]]
** Type alias
Create type constructor, not data constructor
** Type constant
See: [[Constant]]
** Type constructor
Name of [[Datatype][datatype]]

Nullary type constructor is [[Type constant]]
** Type inference
Automatic detection expression datatype.
** Type level
See: [[Level of code]]
** Type variable
Refer to an unspecified type in Haskell type signature.
** Typeclass
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
** Typeclass inheritance
[[Typeclass]] has a [[Superclass][superclass]]
** Type instance
Unique [[Typeclass][typeclass]]->[[Datatype][type]] pairing.
Defines typeclass->type methods.
** Uncurry
Replace number of [[Function][functions]] with [[Tuple][tuple]] of number of values
** Undefined
Value helps to do typechecking
** Unit
Value, [[Datatype][type]]. Represents nothing. Empty [[Tuple][tuple]]
** Unsafe
[[Function]] that does not cover some edge case.
** Variable
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funtions]].
** Variadic
Assepting a variable number of [[Argument][arguments]].
** Associative law
$\forall (a,b,c) \in S : P(a,P(b,c))=P(P(a,b),c)$,
Etymology:
Joined by a common purpose.
Latin /associatus/ past participle of /associare/ "/join with/", from assimilated form of /ad/ "/to/" + /sociare/ "/unite with/", from /socius/ "/companion, ally/" from PIE /*sokw-yo-/, suffixed form of root /*sekw-/ "/to follow/".
** Monoid
Binary associative operation with an identity.
Semigroup with identity.

class Monoid m where
mempty :: m
mappend :: m -> m -> m
mconcat :: [m] -> m
mconcat = foldr mappend mempty
*** Abelian or commutative monoid
Very helpful at concurrent or distributed processing.
*** Monoid laws
-- left identity
mappend mempty x = x
-- right identity
mappend x mempty = x
-- associativity
mappend x (mappend y z) = mappend (mappend x y) z
mconcat = foldr mappend mempty
** Binary
Two of something.
** Operation
As also called [[Function][function]].
Used in mathematics. Word often used for [[Infix][infix]] operations.
** Identity
*** Two-sided identity of a [[Predicate][predicate]]
$P()$ is [[Commutative][commutative]].
$\exist e \in S, \forall a \in S : P(e,a)=P(a,e)=a$
*** Left identity of a [[Predicate][predicate]]
$\exist e \in S, \forall a \in S : P(e,a)=a$
*** Right identity of a [[Predicate][predicate]]
$\exist e \in S, \forall a \in S : P(a,e)=a$

Identity only possible with morphism.
** Predicate
[[Assertion]] includes variable.
Notation: $P(x)$
[[Application]] of [[Argument][argument]] results in true or false predicate.
** Assertion
Утверждение.
** Commutative Law
$\forall (a,b) \in S : P(a,b)=P(b,a)$
** Conjunction
AND
** Disjunction
OR
** Orphan type instance
[[Type instance]] that appeared from inconsistent code base. Duplicate of instance, or instance present on [[Typeclass][typeclass]] or on [[type]] level.

Solution for addressing orphan instances:
1. You defined the type but not the typeclass?
Put the instance in the same module as the type so that the type cannot be imported without its instances.
2. You defined the typeclass but not the type?
Put the instance in the same module as the typeclass definition so that the typeclass cannot be imported without its instances.
3. Neither the type nor the typeclass are yours?
Define your own newtype wrapping the original type and now you’ve got a type that “belongs” to you for which you can rightly define typeclass instances. There are means of making this less annoying which we’ll discuss later.
** Semigroup
$\forall (a,b,c) \in S : P(a,P(b,c))=P(P(a,b),c)$

A set (S) with an operation (P) and [[Associative law][associative law]] - Semigroup.

Defined in Haskell as:

class Semigroup a where
(<>) :: a -> a -> a
** Magma
Set with a single binary operation.

The category of magmas, denoted $Mag$, has as objects sets with a binary operation, and morphisms given by homomorphisms of operations (in the universal algebra sense).
** Binary operation
$\forall (a,b) \in S, \exists P(a,b)=f(a,b): S \times S \to S$
* Investigate
** Control.monad
* Citations:
"One of the finer points of the Haskell community has been
its propensity for recognizing abstract patterns in code which
have well-defined, lawful representations in mathematics." (Chris Allen, Julie Moronuki - "Haskell Programming from First Principles" (2017))
