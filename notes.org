* Functions to remember
** Prelude
enumFromTo
enumFromThenTo
reverse
show :: Show a => a -> String
flip
sequence - Evaluate each monadic action in the structure from left to right, and collect the results.
:sprint - show variables to see what has been evaluated already.
minBound - smaller bound
maxBound - larger bound
*** Ord
compare
*** Calc
div - always makes rounding down, to infinity
divMod - returns a tuple containing the result of integral division and modulo 
*** List operations
concat - [ [a] ] -> [a]
elem x xs - is element a part of a list
zip :: [a] -> [b] -> [(a, b)] - zips two lists together. Zip stops when one list runs out.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] - do the action on corresponding elements of list and store in the new list
** Data.List
intersperse :: a -> [a] -> [a]  -  gets the value and incerts it between values in array
nub - remove duplicates from the list
** Data.Char
ord (Char -> Int)
chr (Int -> Char)
isUpper (Char -> Bool)
toUpper (Char -> Char)
* Debugger

Provides:
  * set a breakpoints
  * observe step-by-step evaluation
  * tracing mode

** Commands
:list

** Breakpoints 
:break 2
  :show breaks
  :delete 0
:continue

** Step-by-step
:step main
* FunFunc
cycle :: [a] -> [a] - indefinitely cycle s list
repeat - indefinit lis from value
elemIndex e l - return first index, returns Maybe
fromMaybe (default if Nothing) e ::Maybe a -> a
lookup :: Eq a => a -> [(a, b)] -> Maybe b
* Good code
Use datatype aliases to deferentiate logic of values.

Unconstrained means most flexible, but the most useless.
The more constrained system has more usefulness.

*** Read Conventions of variables (page 176)
*** Polymorphism 
Parametric polymorphism is broader then constrained polymorphism
*** Damas–Hindley–Milner type system
* Definitions
** Abstraction
Generalization of process from concrete instance of a problem mainly by introduction of names.
** Actual type
[[Datatype]] recieved by execution
** Ad hoc polymorphism
Artificial [[Polymorphism]] that depending on incoming [[Datatype][datatype]] has different behaviour.
Achieved by creating a [[Typeclass][typeclass]] [[Function][functions]].
So it is a dispatch mechanism, that is how polymorphism achieved.
** Alpha equivalence
If names of parameters in [[Expression][expressions]] accordingly different, but process is literally the same - that means that names are synonyms and [[Expression][expression]] are alpha equivalent.
** Anonymous function
In Haskell it is a Lambda function expression without the name to bind to.
** Application
For FP see [[Bind]]. And then [[Beta reduction][beta reduction]] happen
** Argument
Is an input value to a function
** Arity
Number of parameters of the function
- nullary - f()
- unary   - f(x)
- binary  - f(x,y)
- ternary - f(x,y,z)
- n-ary   - f(x,y,z..)
** Beta normal form
No [[Beta reduction][beta reduction]] is possible
** Beta reduction
Applying [[Function][function]] to an [[Argument][argument]].
** Bind
Parameter of the function = argument that applied to the function
** Bottom
'_' fits *.
** Catamorphism
(from the Greek: κατά "downwards" and μορφή "form, shape") denotes the unique homomorphism from an initial algebra into some other algebra.

In functional programming, catamorphisms provide generalizations of folds of lists to arbitrary algebraic data types, which can be described as initial algebras. The dual concept is that of anamorphism that generalize unfolds. A hylomorphism is the composition of an anamorphism followed by a catamorphism.
** Combinator
Lambda term without free variables.

Higher-order [[Function][function]] that uses only function application and earlier defined combinators to define a result from its arguments.

Narrow meaning: A function or definition with no free variables.

Informal broad meaning: referring to the style of organizing libraries centered around the idea of combining things.
** Concatenate
Link together sequences.
** Constrain
See: [[Ad hoc polymorphism]]
** Currying
Translating the [[Evaluation][evaluation]] of a multiple [[Argument][argument]] function (or a tuple of arguments) into evaluating a sequence of [[Function][functions]], each with a single argument.
** Data constructor
Values that [[Inhabit][inhabit]] [[Datatype][datatype]]
** Data declaration
[[Datatype]] definition
** Datatype
Data type, type.
** Declaration
Top-level [[Bind][bindings]] which allow us to name [[Expression][expressions]].
** Evaluation
For FP see [[Bind]].
** Expected type
[[Datatype]] infered from the text of the code
** Expression
Finite combination of a symbols that is well-formed according to rules that depend on the context.
** First-class
1. Can be used as [[Value][value]].
2. Passed as an [[Argument][argument]].
** Free variables
Variables in the fuction that is not bound by the head.
They live empty and fuction as so is not fully applied.
** Function
The idealization of how a varying quantity depends on another quantity.

A function f from a set X to a set Y is defined by a set G of ordered pairs (x, y), such that x ∈ X, y ∈ Y, and every element of X is the first component of exactly one ordered pair in G.[4] In other words, for every x in X there is exactly one element y, such that the ordered pair (x, y) belongs to the set of pairs defining the function f.
** Function body
[[Expression]] that haracterizes the process.
** Function head
Is a part with Name of the [[Function][function]] and it's [[Parameter][paramenter]].
AKA: f(x)
** Higher-order function
Function arity > 1.

Function returns function.
** Identity
Return itself.
(\x.x)
id :: a -> a
** Infix
Operaton in-between variables.
** Inhabit
What [[Values][values]] inhabit [[Datatype][datatype]]
** Interface
Point of mutual meeting. Code behind interface determines how data is consumed.
** Lambda calculus
Universal model of computation that can be used to simulate any Turing machine.
Based on [[Function][function]] [[Abstraction][abstraction]] and application using variable [[Bind][binding]] and substitution.
** Left associative
Same level [[Exression][expression]] parts in reality follow grouping from left to right.
(\x.x)(\y.y)z = ((\x.x)(\y.y))z
** Level of code
There are mainly three levels of Haskell code.
- [[Type level]]: part that works with [[Datatype][datatypes]]
- [[Term level]]: logical execution part of the code
- Compile level: level when code compiles/compiled
** Local
[[Scope]] applies only in an area
** Module
Importable organization unit.
** Modulus
Modular arithmetic is a system of arithmetic for integers where number wraps around upon reacing a modulus.
** Monomorphic
Made of one form.
** Normal form
In context: [[Beta normal form]]
** Operator
[[Infix]] [[Function][function]].
** Parameter
Or Formal Parameter - named varible of a [[Function][function]].
** Parametric polymorphism
Achieved by [[Abstraction][abstracting]] using [[Parametep][parameter]].
** Partial application
Part of [[Function][function]] [[parameter][parameters]] [[Application][applied]].
** Partial function
Does not cover all cases.
Unsafe.
Causes trouble.
** Polymorphism
Interface to entities of different [[Datatypes][datatypes]] by quality of [[Abstraction][abstraction]].
** Principal type
The most generic [[Datatype][datatype]] that still typechecks.
** Product datatype
Logical conjunction.
A datatype that consists of AND areas
** Purity
[[Referantial transparency][Referential transparent]] [[Function][function]]
** Redex
[[Reduction][Reducible]] [[Expression][expression]]
** Reduction
See [[Beta Reduction]]
** Referential transparency
Function returns the same output given the same values to evaluate.

[[Expression]] is referentially transparent if can be replaced with its corresponding resulting value without change for program's behavior.
Such [[Functions][functions]] are called [[Pure][pure]].
** REPL
Interactive CLI. Read-eval-print loop.
** Scope
Area where [[Bind][bind]] is accessible.
** Sectioning
Writing [[Function][function]] in a parentheses. Allows to pass around [[Partial application][partially applied]] [[Function][functions]].
** Static typing
Static typechecking occurs at [[Level of code][compile time]]
** Sum datatype
Logical disjunction.
A datatype that consists of OR areas.
** Syntatic sugar
Artificial way to make language easier to read and write.
** Term level
See: [[Level of code]]
** Tuple
Datatype that stores multiple values withing a single value.
Tuples by [[Arity][arity]]:
- empty, [[Unit][unit]]          - 0
- pair, two-tuples     - 2
- thriple, three-tuple - 3
** Type
See [[Datatype]]
** Type alias
** Type constructor
Name of [[Datatype][datatype]]
** Type inference
Automatic detection expression datatype.
** Type level
See: [[Level of code]]
** Type variable
Refer to an unspecified type in Haskell type signature.
** Typeclass
Type system construct that adds a support of [[Ad hoc polymorphism][ad hoc polymorphism]].
** Uncurry
Replace number of [[Function][functions]] with [[Tuple][tuple]] of number of values
** Undefined
Value helps to do typechecking
** Unsafe
[[Function]] that does not cover some edge case.
** Variable
A name for [[Expression][expression]].

Haskell has immutable variables.
Except when you hack it with explicit [[Function][funtions]].
** Variadic
Assepting a vatiable number of [[Argument][arguments]]
** Superclass
Broader parent class.
** Unit
Value, [[Datatype][type]]. Represents nothing. Empty [[Tuple][tuple]]
** Nothing
Any Haskell expression can't return nothing.
** Typeclass instance
Unique [[Typeclass][typeclass]]-[[Datatype][type]] pairing.
Defines type-typeclass methods.
** Dispatch
Send, transmission, reference.
** Concrete type

